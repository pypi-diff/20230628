# Comparing `tmp/patato-0.5.1-pp39-pypy39_pp73-win_amd64.whl.zip` & `tmp/patato-0.5.2-cp38-cp38-musllinux_1_1_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,98 +1,161 @@
-Zip file size: 233368 bytes, number of entries: 96
--rw-rw-rw-  2.0 fat     2183 b- defN 23-Jun-16 11:00 patato/__init__.py
--rw-rw-rw-  2.0 fat      216 b- defN 23-Jun-16 11:00 patato/convenience_scripts/__init__.py
--rw-rw-rw-  2.0 fat     1247 b- defN 23-Jun-16 11:00 patato/convenience_scripts/convert_binary_to_hdf5.py
--rw-rw-rw-  2.0 fat     1053 b- defN 23-Jun-16 11:00 patato/convenience_scripts/convert_simpa.py
--rw-rw-rw-  2.0 fat     6648 b- defN 23-Jun-16 11:00 patato/convenience_scripts/copy_rois.py
--rw-rw-rw-  2.0 fat    20250 b- defN 23-Jun-16 11:00 patato/convenience_scripts/draw_roi.py
--rw-rw-rw-  2.0 fat     2153 b- defN 23-Jun-16 11:00 patato/convenience_scripts/generate_core.py
--rw-rw-rw-  2.0 fat     1294 b- defN 23-Jun-16 11:00 patato/convenience_scripts/import_clinical_data.py
--rw-rw-rw-  2.0 fat     1666 b- defN 23-Jun-16 11:00 patato/convenience_scripts/import_ithera_recons.py
--rw-rw-rw-  2.0 fat     1541 b- defN 23-Jun-16 11:00 patato/convenience_scripts/print_speeds.py
--rw-rw-rw-  2.0 fat     4611 b- defN 23-Jun-16 11:00 patato/convenience_scripts/process_msot.py
--rw-rw-rw-  2.0 fat      962 b- defN 23-Jun-16 11:00 patato/convenience_scripts/rename_scan.py
--rw-rw-rw-  2.0 fat     1895 b- defN 23-Jun-16 11:00 patato/convenience_scripts/scan_status.py
--rw-rw-rw-  2.0 fat     1793 b- defN 23-Jun-16 11:00 patato/convenience_scripts/split_rois.py
--rw-rw-rw-  2.0 fat     8438 b- defN 23-Jun-16 11:00 patato/convenience_scripts/tune_speed_of_sound.py
--rw-rw-rw-  2.0 fat     2663 b- defN 23-Jun-16 11:00 patato/convenience_scripts/unmix.py
--rw-rw-rw-  2.0 fat     4255 b- defN 23-Jun-16 11:00 patato/convenience_scripts/view.py
--rw-rw-rw-  2.0 fat       55 b- defN 23-Jun-16 11:00 patato/convenience_scripts/data_analysis/__init__.py
--rw-rw-rw-  2.0 fat     2617 b- defN 23-Jun-16 11:00 patato/convenience_scripts/data_analysis/analyse_dce.py
--rw-rw-rw-  2.0 fat     2745 b- defN 23-Jun-16 11:00 patato/convenience_scripts/data_analysis/analyse_gas_challenge.py
--rw-rw-rw-  2.0 fat      251 b- defN 23-Jun-16 11:00 patato/core/__init__.py
--rw-rw-rw-  2.0 fat       55 b- defN 23-Jun-16 11:00 patato/core/image_structures/__init__.py
--rw-rw-rw-  2.0 fat    12664 b- defN 23-Jun-16 11:00 patato/core/image_structures/image_sequence.py
--rw-rw-rw-  2.0 fat      856 b- defN 23-Jun-16 11:00 patato/core/image_structures/image_structure_types.py
--rw-rw-rw-  2.0 fat     1430 b- defN 23-Jun-16 11:00 patato/core/image_structures/pa_raw_data.py
--rw-rw-rw-  2.0 fat     1331 b- defN 23-Jun-16 11:00 patato/core/image_structures/pa_time_data.py
--rw-rw-rw-  2.0 fat      851 b- defN 23-Jun-16 11:00 patato/core/image_structures/reconstruction_image.py
--rw-rw-rw-  2.0 fat      982 b- defN 23-Jun-16 11:00 patato/core/image_structures/single_image.py
--rw-rw-rw-  2.0 fat     1121 b- defN 23-Jun-16 11:00 patato/core/image_structures/single_parameter_data.py
--rw-rw-rw-  2.0 fat      930 b- defN 23-Jun-16 11:00 patato/core/image_structures/unmixed_image.py
--rw-rw-rw-  2.0 fat      701 b- defN 23-Jun-16 11:00 patato/data/__init__.py
--rw-rw-rw-  2.0 fat     3676 b- defN 23-Jun-16 11:00 patato/data/get_example_datasets.py
--rw-rw-rw-  2.0 fat     2132 b- defN 23-Jun-16 11:00 patato/data/simulated_datasets.py
--rw-rw-rw-  2.0 fat       53 b- defN 23-Jun-16 11:00 patato/experimental/__init__.py
--rw-rw-rw-  2.0 fat       57 b- defN 23-Jun-16 11:00 patato/experimental/simulation/__init__.py
--rw-rw-rw-  2.0 fat      194 b- defN 23-Jun-16 11:00 patato/io/__init__.py
--rw-rw-rw-  2.0 fat     2877 b- defN 23-Jun-16 11:00 patato/io/attribute_tags.py
--rw-rw-rw-  2.0 fat     3934 b- defN 23-Jun-16 11:00 patato/io/hdf5_converter.py
--rw-rw-rw-  2.0 fat    23221 b- defN 23-Jun-16 11:00 patato/io/msot_data.py
--rw-rw-rw-  2.0 fat       55 b- defN 23-Jun-16 11:00 patato/io/hdf/__init__.py
--rw-rw-rw-  2.0 fat    12302 b- defN 23-Jun-16 11:00 patato/io/hdf/fileimporter.py
--rw-rw-rw-  2.0 fat    17073 b- defN 23-Jun-16 11:00 patato/io/hdf/hdf5_interface.py
--rw-rw-rw-  2.0 fat      518 b- defN 23-Jun-16 11:00 patato/io/ipasc/__init__.py
--rw-rw-rw-  2.0 fat     2472 b- defN 23-Jun-16 11:00 patato/io/ipasc/ipasc_export.py
--rw-rw-rw-  2.0 fat     2840 b- defN 23-Jun-16 11:00 patato/io/ipasc/read_ipasc.py
--rw-rw-rw-  2.0 fat      245 b- defN 23-Jun-16 11:00 patato/io/ithera/__init__.py
--rw-rw-rw-  2.0 fat    13847 b- defN 23-Jun-16 11:00 patato/io/ithera/read_ithera.py
--rw-rw-rw-  2.0 fat       55 b- defN 23-Jun-16 11:00 patato/io/json/__init__.py
--rw-rw-rw-  2.0 fat     6868 b- defN 23-Jun-16 11:00 patato/io/json/json_reading.py
--rw-rw-rw-  2.0 fat       55 b- defN 23-Jun-16 11:00 patato/io/simpa/__init__.py
--rw-rw-rw-  2.0 fat     5192 b- defN 23-Jun-16 11:00 patato/io/simpa/read_simpa.py
--rw-rw-rw-  2.0 fat      339 b- defN 23-Jun-16 11:00 patato/processing/__init__.py
--rw-rw-rw-  2.0 fat    11603 b- defN 23-Jun-16 11:00 patato/processing/gpu_preprocessing_algorithm.py
--rw-rw-rw-  2.0 fat    12332 b- defN 23-Jun-16 11:00 patato/processing/jax_preprocessing_algorithm.py
--rw-rw-rw-  2.0 fat    10264 b- defN 23-Jun-16 11:00 patato/processing/preprocessing_algorithm.py
--rw-rw-rw-  2.0 fat      685 b- defN 23-Jun-16 11:00 patato/processing/preprocessing_types.py
--rw-rw-rw-  2.0 fat     2259 b- defN 23-Jun-16 11:00 patato/processing/processing_algorithm.py
--rw-rw-rw-  2.0 fat     1897 b- defN 23-Jun-16 11:00 patato/recon/__init__.py
--rw-rw-rw-  2.0 fat     7337 b- defN 23-Jun-16 11:00 patato/recon/backprojection_opencl.py
--rw-rw-rw-  2.0 fat     2137 b- defN 23-Jun-16 11:00 patato/recon/backprojection_reference.py
--rw-rw-rw-  2.0 fat     5070 b- defN 23-Jun-16 11:00 patato/recon/reconstruction_algorithm.py
--rw-rw-rw-  2.0 fat       55 b- defN 23-Jun-16 11:00 patato/recon/backprojection_implementation/__init__.py
--rw-rw-rw-  2.0 fat     1056 b- defN 23-Jun-16 11:00 patato/recon/backprojection_implementation/jax_implementation.py
--rw-rw-rw-  2.0 fat       55 b- defN 23-Jun-16 11:00 patato/recon/model_based/__init__.py
--rw-rw-rw-  2.0 fat     3874 b- defN 23-Jun-16 11:00 patato/recon/model_based/cuda_implementation.py
--rw-rw-rw-  2.0 fat     2806 b- defN 23-Jun-16 11:00 patato/recon/model_based/cuda_implementation_refraction.py
--rw-rw-rw-  2.0 fat     6985 b- defN 23-Jun-16 11:00 patato/recon/model_based/generate_model.cpp
--rw-rw-rw-  2.0 fat     5999 b- defN 23-Jun-16 11:00 patato/recon/model_based/generate_model.cu
--rw-rw-rw-  2.0 fat   113152 b- defN 23-Jun-16 11:08 patato/recon/model_based/generate_model.pypy39-pp73-win_amd64.pyd
--rw-rw-rw-  2.0 fat     8080 b- defN 23-Jun-16 11:00 patato/recon/model_based/generate_model_refraction.cpp
--rw-rw-rw-  2.0 fat     7990 b- defN 23-Jun-16 11:00 patato/recon/model_based/generate_model_refraction.cu
--rw-rw-rw-  2.0 fat   114176 b- defN 23-Jun-16 11:08 patato/recon/model_based/generate_model_refraction.pypy39-pp73-win_amd64.pyd
--rw-rw-rw-  2.0 fat    11229 b- defN 23-Jun-16 11:00 patato/recon/model_based/model_based.py
--rw-rw-rw-  2.0 fat     2524 b- defN 23-Jun-16 11:00 patato/recon/model_based/numpy_implementation.py
--rw-rw-rw-  2.0 fat       55 b- defN 23-Jun-16 11:00 patato/recon/numpy_backprojection/__init__.py
--rw-rw-rw-  2.0 fat     3004 b- defN 23-Jun-16 11:00 patato/recon/numpy_backprojection/recon.py
--rw-rw-rw-  2.0 fat      576 b- defN 23-Jun-16 11:00 patato/unmixing/__init__.py
--rw-rw-rw-  2.0 fat    16207 b- defN 23-Jun-16 11:00 patato/unmixing/unmixer.py
--rw-rw-rw-  2.0 fat     4290 b- defN 23-Jun-16 11:00 patato/unmixing/spectra/__init__.py
--rw-rw-rw-  2.0 fat     9837 b- defN 23-Jun-16 11:00 patato/useful_utilities/__init__.py
--rw-rw-rw-  2.0 fat      523 b- defN 23-Jun-16 11:00 patato/utils/__init__.py
--rw-rw-rw-  2.0 fat     4320 b- defN 23-Jun-16 11:00 patato/utils/mask_operations.py
--rw-rw-rw-  2.0 fat     1316 b- defN 23-Jun-16 11:00 patato/utils/plotting.py
--rw-rw-rw-  2.0 fat      585 b- defN 23-Jun-16 11:00 patato/utils/process_study.py
--rw-rw-rw-  2.0 fat     3570 b- defN 23-Jun-16 11:00 patato/utils/roi_operations.py
--rw-rw-rw-  2.0 fat     4262 b- defN 23-Jun-16 11:00 patato/utils/run_pipeline.py
--rw-rw-rw-  2.0 fat     3025 b- defN 23-Jun-16 11:00 patato/utils/time_series_analysis.py
--rw-rw-rw-  2.0 fat       55 b- defN 23-Jun-16 11:00 patato/utils/rois/__init__.py
--rw-rw-rw-  2.0 fat     3338 b- defN 23-Jun-16 11:00 patato/utils/rois/roi_type.py
--rw-rw-rw-  2.0 fat       55 b- defN 23-Jun-16 11:00 patato/utils/tests/__init__.py
--rw-rw-rw-  2.0 fat     1087 b- defN 23-Jun-16 11:08 patato-0.5.1.dist-info/LICENSE.MD
--rw-rw-rw-  2.0 fat     4949 b- defN 23-Jun-16 11:08 patato-0.5.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat      107 b- defN 23-Jun-16 11:08 patato-0.5.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat      590 b- defN 23-Jun-16 11:08 patato-0.5.1.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat        7 b- defN 23-Jun-16 11:08 patato-0.5.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     9068 b- defN 23-Jun-16 11:08 patato-0.5.1.dist-info/RECORD
-96 files, 589853 bytes uncompressed, 218690 bytes compressed:  62.9%
+Zip file size: 2276698 bytes, number of entries: 159
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato.libs/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato-0.5.2.dist-info/
+-rwxr-xr-x  2.0 unx  2447393 b- defN 23-Jun-28 13:03 patato.libs/libstdc++-a9383cce.so.6.0.28
+-rw-r--r--  2.0 unx    81257 b- defN 23-Jun-28 13:03 patato.libs/libgcc_s-a04fdf82.so.1
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/convenience_scripts/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/experimental/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/utils/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/recon/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/core/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/useful_utilities/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/unmixing/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/io/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/processing/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/data/
+-rw-r--r--  2.0 unx     2183 b- defN 23-Jun-28 13:03 patato/__init__.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/convenience_scripts/data_analysis/
+-rw-r--r--  2.0 unx     4640 b- defN 23-Jun-28 13:03 patato/convenience_scripts/process_msot.py
+-rw-r--r--  2.0 unx     1247 b- defN 23-Jun-28 13:03 patato/convenience_scripts/convert_binary_to_hdf5.py
+-rw-r--r--  2.0 unx     1666 b- defN 23-Jun-28 13:03 patato/convenience_scripts/import_ithera_recons.py
+-rw-r--r--  2.0 unx     1541 b- defN 23-Jun-28 13:03 patato/convenience_scripts/print_speeds.py
+-rw-r--r--  2.0 unx     4255 b- defN 23-Jun-28 13:03 patato/convenience_scripts/view.py
+-rw-r--r--  2.0 unx      207 b- defN 23-Jun-28 13:03 patato/convenience_scripts/__init__.py
+-rw-r--r--  2.0 unx     1793 b- defN 23-Jun-28 13:03 patato/convenience_scripts/split_rois.py
+-rw-r--r--  2.0 unx     6648 b- defN 23-Jun-28 13:03 patato/convenience_scripts/copy_rois.py
+-rw-r--r--  2.0 unx     1294 b- defN 23-Jun-28 13:03 patato/convenience_scripts/import_clinical_data.py
+-rw-r--r--  2.0 unx    20250 b- defN 23-Jun-28 13:03 patato/convenience_scripts/draw_roi.py
+-rw-r--r--  2.0 unx     8450 b- defN 23-Jun-28 13:03 patato/convenience_scripts/tune_speed_of_sound.py
+-rw-r--r--  2.0 unx     1053 b- defN 23-Jun-28 13:03 patato/convenience_scripts/convert_simpa.py
+-rw-r--r--  2.0 unx     2692 b- defN 23-Jun-28 13:03 patato/convenience_scripts/unmix.py
+-rw-r--r--  2.0 unx     1895 b- defN 23-Jun-28 13:03 patato/convenience_scripts/scan_status.py
+-rw-r--r--  2.0 unx      962 b- defN 23-Jun-28 13:03 patato/convenience_scripts/rename_scan.py
+-rw-r--r--  2.0 unx       90 b- defN 23-Jun-28 13:03 patato/convenience_scripts/run_loads.txt
+-rw-r--r--  2.0 unx     2153 b- defN 23-Jun-28 13:03 patato/convenience_scripts/generate_core.py
+-rw-r--r--  2.0 unx     2741 b- defN 23-Jun-28 13:03 patato/convenience_scripts/data_analysis/analyse_gas_challenge.py
+-rw-r--r--  2.0 unx       52 b- defN 23-Jun-28 13:03 patato/convenience_scripts/data_analysis/__init__.py
+-rw-r--r--  2.0 unx     2613 b- defN 23-Jun-28 13:03 patato/convenience_scripts/data_analysis/analyse_dce.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/experimental/simulation/
+-rw-r--r--  2.0 unx       51 b- defN 23-Jun-28 13:03 patato/experimental/__init__.py
+-rw-r--r--  2.0 unx       53 b- defN 23-Jun-28 13:03 patato/experimental/simulation/__init__.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/utils/rois/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/utils/tests/
+-rw-r--r--  2.0 unx     4320 b- defN 23-Jun-28 13:03 patato/utils/mask_operations.py
+-rw-r--r--  2.0 unx      523 b- defN 23-Jun-28 13:03 patato/utils/__init__.py
+-rw-r--r--  2.0 unx      585 b- defN 23-Jun-28 13:03 patato/utils/process_study.py
+-rw-r--r--  2.0 unx     1316 b- defN 23-Jun-28 13:03 patato/utils/plotting.py
+-rw-r--r--  2.0 unx     3570 b- defN 23-Jun-28 13:03 patato/utils/roi_operations.py
+-rw-r--r--  2.0 unx     3025 b- defN 23-Jun-28 13:03 patato/utils/time_series_analysis.py
+-rw-r--r--  2.0 unx     4262 b- defN 23-Jun-28 13:03 patato/utils/pipeline.py
+-rw-r--r--  2.0 unx       52 b- defN 23-Jun-28 13:03 patato/utils/rois/__init__.py
+-rw-r--r--  2.0 unx     3338 b- defN 23-Jun-28 13:03 patato/utils/rois/roi_type.py
+-rw-r--r--  2.0 unx       52 b- defN 23-Jun-28 13:03 patato/utils/tests/__init__.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/recon/opencl_code/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/recon/numpy_backprojection/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/recon/model_based/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/recon/backprojection_implementation/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/recon/recon_presets/
+-rw-r--r--  2.0 unx     1897 b- defN 23-Jun-28 13:03 patato/recon/__init__.py
+-rw-r--r--  2.0 unx     5070 b- defN 23-Jun-28 13:03 patato/recon/reconstruction_algorithm.py
+-rw-r--r--  2.0 unx     2137 b- defN 23-Jun-28 13:03 patato/recon/backprojection_reference.py
+-rw-r--r--  2.0 unx     7337 b- defN 23-Jun-28 13:03 patato/recon/backprojection_opencl.py
+-rw-r--r--  2.0 unx     1729 b- defN 23-Jun-28 13:03 patato/recon/opencl_code/dmascl.cl
+-rw-r--r--  2.0 unx     1633 b- defN 23-Jun-28 13:03 patato/recon/opencl_code/dascl.cl
+-rw-r--r--  2.0 unx     2920 b- defN 23-Jun-28 13:03 patato/recon/numpy_backprojection/recon.py
+-rw-r--r--  2.0 unx       52 b- defN 23-Jun-28 13:03 patato/recon/numpy_backprojection/__init__.py
+-rw-r--r--  2.0 unx    11229 b- defN 23-Jun-28 13:03 patato/recon/model_based/model_based.py
+-rw-r--r--  2.0 unx     2524 b- defN 23-Jun-28 13:03 patato/recon/model_based/numpy_implementation.py
+-rwxr-xr-x  2.0 unx  3116185 b- defN 23-Jun-28 13:03 patato/recon/model_based/generate_model_refraction.cpython-38-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx     3874 b- defN 23-Jun-28 13:03 patato/recon/model_based/cuda_implementation.py
+-rw-r--r--  2.0 unx     6985 b- defN 23-Jun-28 13:03 patato/recon/model_based/generate_model.cpp
+-rw-r--r--  2.0 unx       52 b- defN 23-Jun-28 13:03 patato/recon/model_based/__init__.py
+-rw-r--r--  2.0 unx     7990 b- defN 23-Jun-28 13:03 patato/recon/model_based/generate_model_refraction.cu
+-rw-r--r--  2.0 unx     2806 b- defN 23-Jun-28 13:03 patato/recon/model_based/cuda_implementation_refraction.py
+-rw-r--r--  2.0 unx     8080 b- defN 23-Jun-28 13:03 patato/recon/model_based/generate_model_refraction.cpp
+-rwxr-xr-x  2.0 unx  3083345 b- defN 23-Jun-28 13:03 patato/recon/model_based/generate_model.cpython-38-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx     5999 b- defN 23-Jun-28 13:03 patato/recon/model_based/generate_model.cu
+-rw-r--r--  2.0 unx       52 b- defN 23-Jun-28 13:03 patato/recon/backprojection_implementation/__init__.py
+-rw-r--r--  2.0 unx     1022 b- defN 23-Jun-28 13:03 patato/recon/backprojection_implementation/jax_implementation.py
+-rw-r--r--  2.0 unx      488 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_clinical.json
+-rw-r--r--  2.0 unx      491 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_standard_yz.json
+-rw-r--r--  2.0 unx      557 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_standard_water_correction.json
+-rw-r--r--  2.0 unx      491 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_standard.json
+-rw-r--r--  2.0 unx      488 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_clinical_xz.json
+-rw-r--r--  2.0 unx      491 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_standard_xy.json
+-rw-r--r--  2.0 unx      488 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_clinical_xy.json
+-rw-r--r--  2.0 unx      488 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_clinical_yz.json
+-rw-r--r--  2.0 unx      493 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_standard_sos.json
+-rw-r--r--  2.0 unx      491 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_standard_xz.json
+-rw-r--r--  2.0 unx      486 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_janek_sos.json
+-rw-r--r--  2.0 unx      486 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_janek.json
+-rw-r--r--  2.0 unx      485 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_noirf.json
+-rw-r--r--  2.0 unx      561 b- defN 23-Jun-28 13:03 patato/recon/recon_presets/backproject_standard_water_correction_new_ithera.json
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/core/image_structures/
+-rw-r--r--  2.0 unx      251 b- defN 23-Jun-28 13:03 patato/core/__init__.py
+-rw-r--r--  2.0 unx     1121 b- defN 23-Jun-28 13:03 patato/core/image_structures/single_parameter_data.py
+-rw-r--r--  2.0 unx     1331 b- defN 23-Jun-28 13:03 patato/core/image_structures/pa_time_data.py
+-rw-r--r--  2.0 unx      851 b- defN 23-Jun-28 13:03 patato/core/image_structures/reconstruction_image.py
+-rw-r--r--  2.0 unx       52 b- defN 23-Jun-28 13:03 patato/core/image_structures/__init__.py
+-rw-r--r--  2.0 unx     1430 b- defN 23-Jun-28 13:03 patato/core/image_structures/pa_raw_data.py
+-rw-r--r--  2.0 unx      856 b- defN 23-Jun-28 13:03 patato/core/image_structures/image_structure_types.py
+-rw-r--r--  2.0 unx      930 b- defN 23-Jun-28 13:03 patato/core/image_structures/unmixed_image.py
+-rw-r--r--  2.0 unx      982 b- defN 23-Jun-28 13:03 patato/core/image_structures/single_image.py
+-rw-r--r--  2.0 unx    12664 b- defN 23-Jun-28 13:03 patato/core/image_structures/image_sequence.py
+-rw-r--r--  2.0 unx     9837 b- defN 23-Jun-28 13:03 patato/useful_utilities/__init__.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/unmixing/spectra/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/unmixing/unmix_presets/
+-rw-r--r--  2.0 unx      554 b- defN 23-Jun-28 13:03 patato/unmixing/__init__.py
+-rw-r--r--  2.0 unx    16207 b- defN 23-Jun-28 13:03 patato/unmixing/unmixer.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/unmixing/spectra/spectra_files/
+-rw-r--r--  2.0 unx     4290 b- defN 23-Jun-28 13:03 patato/unmixing/spectra/__init__.py
+-rw-r--r--  2.0 unx     3710 b- defN 23-Jun-28 13:03 patato/unmixing/spectra/spectra_files/water.txt
+-rw-r--r--  2.0 unx     6861 b- defN 23-Jun-28 13:03 patato/unmixing/spectra/spectra_files/prahl.txt
+-rw-r--r--  2.0 unx    17760 b- defN 23-Jun-28 13:03 patato/unmixing/spectra/spectra_files/Melanin.csv
+-rw-r--r--  2.0 unx    12113 b- defN 23-Jun-28 13:03 patato/unmixing/spectra/spectra_files/ICG.csv
+-rw-r--r--  2.0 unx     7768 b- defN 23-Jun-28 13:03 patato/unmixing/spectra/spectra_files/lipids.txt
+-rw-r--r--  2.0 unx     8643 b- defN 23-Jun-28 13:03 patato/unmixing/spectra/spectra_files/water_long.txt
+-rw-r--r--  2.0 unx      205 b- defN 23-Jun-28 13:03 patato/unmixing/unmix_presets/hb_emma_water.json
+-rw-r--r--  2.0 unx      120 b- defN 23-Jun-28 13:03 patato/unmixing/unmix_presets/haemoglobin_flow_phantom.json
+-rw-r--r--  2.0 unx      121 b- defN 23-Jun-28 13:03 patato/unmixing/unmix_presets/haemoglobin_flow_phantom_all_wl.json
+-rw-r--r--  2.0 unx      132 b- defN 23-Jun-28 13:03 patato/unmixing/unmix_presets/hb_icg.json
+-rw-r--r--  2.0 unx      134 b- defN 23-Jun-28 13:03 patato/unmixing/unmix_presets/haemoglobin_melanin.json
+-rw-r--r--  2.0 unx      120 b- defN 23-Jun-28 13:03 patato/unmixing/unmix_presets/haemoglobin.json
+-rw-r--r--  2.0 unx      183 b- defN 23-Jun-28 13:03 patato/unmixing/unmix_presets/haemoglobin_mitox.json
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/io/ipasc/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/io/simpa/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/io/json/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/io/ithera/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-28 13:03 patato/io/hdf/
+-rw-r--r--  2.0 unx     3934 b- defN 23-Jun-28 13:03 patato/io/hdf5_converter.py
+-rw-r--r--  2.0 unx      194 b- defN 23-Jun-28 13:03 patato/io/__init__.py
+-rw-r--r--  2.0 unx     2877 b- defN 23-Jun-28 13:03 patato/io/attribute_tags.py
+-rw-r--r--  2.0 unx    23221 b- defN 23-Jun-28 13:03 patato/io/msot_data.py
+-rw-r--r--  2.0 unx      518 b- defN 23-Jun-28 13:03 patato/io/ipasc/__init__.py
+-rw-r--r--  2.0 unx     3011 b- defN 23-Jun-28 13:03 patato/io/ipasc/read_ipasc.py
+-rw-r--r--  2.0 unx     2472 b- defN 23-Jun-28 13:03 patato/io/ipasc/ipasc_export.py
+-rw-r--r--  2.0 unx       52 b- defN 23-Jun-28 13:03 patato/io/simpa/__init__.py
+-rw-r--r--  2.0 unx     5192 b- defN 23-Jun-28 13:03 patato/io/simpa/read_simpa.py
+-rw-r--r--  2.0 unx       52 b- defN 23-Jun-28 13:03 patato/io/json/__init__.py
+-rw-r--r--  2.0 unx     6714 b- defN 23-Jun-28 13:03 patato/io/json/json_reading.py
+-rw-r--r--  2.0 unx      245 b- defN 23-Jun-28 13:03 patato/io/ithera/__init__.py
+-rw-r--r--  2.0 unx    13847 b- defN 23-Jun-28 13:03 patato/io/ithera/read_ithera.py
+-rw-r--r--  2.0 unx    12304 b- defN 23-Jun-28 13:03 patato/io/hdf/fileimporter.py
+-rw-r--r--  2.0 unx       52 b- defN 23-Jun-28 13:03 patato/io/hdf/__init__.py
+-rw-r--r--  2.0 unx    17073 b- defN 23-Jun-28 13:03 patato/io/hdf/hdf5_interface.py
+-rw-r--r--  2.0 unx    12018 b- defN 23-Jun-28 13:03 patato/processing/jax_preprocessing_algorithm.py
+-rw-r--r--  2.0 unx      685 b- defN 23-Jun-28 13:03 patato/processing/preprocessing_types.py
+-rw-r--r--  2.0 unx     2259 b- defN 23-Jun-28 13:03 patato/processing/processing_algorithm.py
+-rw-r--r--  2.0 unx    11603 b- defN 23-Jun-28 13:03 patato/processing/gpu_preprocessing_algorithm.py
+-rw-r--r--  2.0 unx      330 b- defN 23-Jun-28 13:03 patato/processing/__init__.py
+-rw-r--r--  2.0 unx    10264 b- defN 23-Jun-28 13:03 patato/processing/preprocessing_algorithm.py
+-rw-r--r--  2.0 unx      680 b- defN 23-Jun-28 13:03 patato/data/__init__.py
+-rw-r--r--  2.0 unx     3572 b- defN 23-Jun-28 13:03 patato/data/get_example_datasets.py
+-rw-r--r--  2.0 unx     2049 b- defN 23-Jun-28 13:03 patato/data/simulated_datasets.py
+-rw-r--r--  2.0 unx      111 b- defN 23-Jun-28 13:03 patato-0.5.2.dist-info/WHEEL
+-rw-r--r--  2.0 unx     1067 b- defN 23-Jun-28 13:03 patato-0.5.2.dist-info/LICENSE.MD
+-rw-r--r--  2.0 unx        7 b- defN 23-Jun-28 13:03 patato-0.5.2.dist-info/top_level.txt
+-rw-r--r--  2.0 unx     4836 b- defN 23-Jun-28 13:03 patato-0.5.2.dist-info/METADATA
+-rw-r--r--  2.0 unx      590 b- defN 23-Jun-28 13:03 patato-0.5.2.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx    12636 b- defN 23-Jun-28 13:03 patato-0.5.2.dist-info/RECORD
+159 files, 9161815 bytes uncompressed, 2252632 bytes compressed:  75.4%
```

## zipnote {}

```diff
@@ -1,289 +1,478 @@
-Filename: patato/__init__.py
+Filename: patato.libs/
 Comment: 
 
-Filename: patato/convenience_scripts/__init__.py
+Filename: patato/
 Comment: 
 
-Filename: patato/convenience_scripts/convert_binary_to_hdf5.py
+Filename: patato-0.5.2.dist-info/
 Comment: 
 
-Filename: patato/convenience_scripts/convert_simpa.py
+Filename: patato.libs/libstdc++-a9383cce.so.6.0.28
 Comment: 
 
-Filename: patato/convenience_scripts/copy_rois.py
+Filename: patato.libs/libgcc_s-a04fdf82.so.1
 Comment: 
 
-Filename: patato/convenience_scripts/draw_roi.py
+Filename: patato/convenience_scripts/
 Comment: 
 
-Filename: patato/convenience_scripts/generate_core.py
+Filename: patato/experimental/
 Comment: 
 
-Filename: patato/convenience_scripts/import_clinical_data.py
+Filename: patato/utils/
 Comment: 
 
-Filename: patato/convenience_scripts/import_ithera_recons.py
+Filename: patato/recon/
 Comment: 
 
-Filename: patato/convenience_scripts/print_speeds.py
+Filename: patato/core/
+Comment: 
+
+Filename: patato/useful_utilities/
+Comment: 
+
+Filename: patato/unmixing/
+Comment: 
+
+Filename: patato/io/
+Comment: 
+
+Filename: patato/processing/
+Comment: 
+
+Filename: patato/data/
+Comment: 
+
+Filename: patato/__init__.py
+Comment: 
+
+Filename: patato/convenience_scripts/data_analysis/
 Comment: 
 
 Filename: patato/convenience_scripts/process_msot.py
 Comment: 
 
-Filename: patato/convenience_scripts/rename_scan.py
+Filename: patato/convenience_scripts/convert_binary_to_hdf5.py
 Comment: 
 
-Filename: patato/convenience_scripts/scan_status.py
+Filename: patato/convenience_scripts/import_ithera_recons.py
+Comment: 
+
+Filename: patato/convenience_scripts/print_speeds.py
+Comment: 
+
+Filename: patato/convenience_scripts/view.py
+Comment: 
+
+Filename: patato/convenience_scripts/__init__.py
 Comment: 
 
 Filename: patato/convenience_scripts/split_rois.py
 Comment: 
 
+Filename: patato/convenience_scripts/copy_rois.py
+Comment: 
+
+Filename: patato/convenience_scripts/import_clinical_data.py
+Comment: 
+
+Filename: patato/convenience_scripts/draw_roi.py
+Comment: 
+
 Filename: patato/convenience_scripts/tune_speed_of_sound.py
 Comment: 
 
+Filename: patato/convenience_scripts/convert_simpa.py
+Comment: 
+
 Filename: patato/convenience_scripts/unmix.py
 Comment: 
 
-Filename: patato/convenience_scripts/view.py
+Filename: patato/convenience_scripts/scan_status.py
 Comment: 
 
-Filename: patato/convenience_scripts/data_analysis/__init__.py
+Filename: patato/convenience_scripts/rename_scan.py
 Comment: 
 
-Filename: patato/convenience_scripts/data_analysis/analyse_dce.py
+Filename: patato/convenience_scripts/run_loads.txt
+Comment: 
+
+Filename: patato/convenience_scripts/generate_core.py
 Comment: 
 
 Filename: patato/convenience_scripts/data_analysis/analyse_gas_challenge.py
 Comment: 
 
-Filename: patato/core/__init__.py
+Filename: patato/convenience_scripts/data_analysis/__init__.py
 Comment: 
 
-Filename: patato/core/image_structures/__init__.py
+Filename: patato/convenience_scripts/data_analysis/analyse_dce.py
 Comment: 
 
-Filename: patato/core/image_structures/image_sequence.py
+Filename: patato/experimental/simulation/
 Comment: 
 
-Filename: patato/core/image_structures/image_structure_types.py
+Filename: patato/experimental/__init__.py
 Comment: 
 
-Filename: patato/core/image_structures/pa_raw_data.py
+Filename: patato/experimental/simulation/__init__.py
 Comment: 
 
-Filename: patato/core/image_structures/pa_time_data.py
+Filename: patato/utils/rois/
 Comment: 
 
-Filename: patato/core/image_structures/reconstruction_image.py
+Filename: patato/utils/tests/
 Comment: 
 
-Filename: patato/core/image_structures/single_image.py
+Filename: patato/utils/mask_operations.py
 Comment: 
 
-Filename: patato/core/image_structures/single_parameter_data.py
+Filename: patato/utils/__init__.py
 Comment: 
 
-Filename: patato/core/image_structures/unmixed_image.py
+Filename: patato/utils/process_study.py
 Comment: 
 
-Filename: patato/data/__init__.py
+Filename: patato/utils/plotting.py
 Comment: 
 
-Filename: patato/data/get_example_datasets.py
+Filename: patato/utils/roi_operations.py
 Comment: 
 
-Filename: patato/data/simulated_datasets.py
+Filename: patato/utils/time_series_analysis.py
 Comment: 
 
-Filename: patato/experimental/__init__.py
+Filename: patato/utils/pipeline.py
 Comment: 
 
-Filename: patato/experimental/simulation/__init__.py
+Filename: patato/utils/rois/__init__.py
 Comment: 
 
-Filename: patato/io/__init__.py
+Filename: patato/utils/rois/roi_type.py
 Comment: 
 
-Filename: patato/io/attribute_tags.py
+Filename: patato/utils/tests/__init__.py
 Comment: 
 
-Filename: patato/io/hdf5_converter.py
+Filename: patato/recon/opencl_code/
 Comment: 
 
-Filename: patato/io/msot_data.py
+Filename: patato/recon/numpy_backprojection/
 Comment: 
 
-Filename: patato/io/hdf/__init__.py
+Filename: patato/recon/model_based/
 Comment: 
 
-Filename: patato/io/hdf/fileimporter.py
+Filename: patato/recon/backprojection_implementation/
 Comment: 
 
-Filename: patato/io/hdf/hdf5_interface.py
+Filename: patato/recon/recon_presets/
 Comment: 
 
-Filename: patato/io/ipasc/__init__.py
+Filename: patato/recon/__init__.py
 Comment: 
 
-Filename: patato/io/ipasc/ipasc_export.py
+Filename: patato/recon/reconstruction_algorithm.py
 Comment: 
 
-Filename: patato/io/ipasc/read_ipasc.py
+Filename: patato/recon/backprojection_reference.py
 Comment: 
 
-Filename: patato/io/ithera/__init__.py
+Filename: patato/recon/backprojection_opencl.py
 Comment: 
 
-Filename: patato/io/ithera/read_ithera.py
+Filename: patato/recon/opencl_code/dmascl.cl
 Comment: 
 
-Filename: patato/io/json/__init__.py
+Filename: patato/recon/opencl_code/dascl.cl
 Comment: 
 
-Filename: patato/io/json/json_reading.py
+Filename: patato/recon/numpy_backprojection/recon.py
 Comment: 
 
-Filename: patato/io/simpa/__init__.py
+Filename: patato/recon/numpy_backprojection/__init__.py
 Comment: 
 
-Filename: patato/io/simpa/read_simpa.py
+Filename: patato/recon/model_based/model_based.py
 Comment: 
 
-Filename: patato/processing/__init__.py
+Filename: patato/recon/model_based/numpy_implementation.py
 Comment: 
 
-Filename: patato/processing/gpu_preprocessing_algorithm.py
+Filename: patato/recon/model_based/generate_model_refraction.cpython-38-x86_64-linux-gnu.so
 Comment: 
 
-Filename: patato/processing/jax_preprocessing_algorithm.py
+Filename: patato/recon/model_based/cuda_implementation.py
 Comment: 
 
-Filename: patato/processing/preprocessing_algorithm.py
+Filename: patato/recon/model_based/generate_model.cpp
 Comment: 
 
-Filename: patato/processing/preprocessing_types.py
+Filename: patato/recon/model_based/__init__.py
 Comment: 
 
-Filename: patato/processing/processing_algorithm.py
+Filename: patato/recon/model_based/generate_model_refraction.cu
 Comment: 
 
-Filename: patato/recon/__init__.py
+Filename: patato/recon/model_based/cuda_implementation_refraction.py
 Comment: 
 
-Filename: patato/recon/backprojection_opencl.py
+Filename: patato/recon/model_based/generate_model_refraction.cpp
 Comment: 
 
-Filename: patato/recon/backprojection_reference.py
+Filename: patato/recon/model_based/generate_model.cpython-38-x86_64-linux-gnu.so
 Comment: 
 
-Filename: patato/recon/reconstruction_algorithm.py
+Filename: patato/recon/model_based/generate_model.cu
 Comment: 
 
 Filename: patato/recon/backprojection_implementation/__init__.py
 Comment: 
 
 Filename: patato/recon/backprojection_implementation/jax_implementation.py
 Comment: 
 
-Filename: patato/recon/model_based/__init__.py
+Filename: patato/recon/recon_presets/backproject_clinical.json
 Comment: 
 
-Filename: patato/recon/model_based/cuda_implementation.py
+Filename: patato/recon/recon_presets/backproject_standard_yz.json
 Comment: 
 
-Filename: patato/recon/model_based/cuda_implementation_refraction.py
+Filename: patato/recon/recon_presets/backproject_standard_water_correction.json
 Comment: 
 
-Filename: patato/recon/model_based/generate_model.cpp
+Filename: patato/recon/recon_presets/backproject_standard.json
 Comment: 
 
-Filename: patato/recon/model_based/generate_model.cu
+Filename: patato/recon/recon_presets/backproject_clinical_xz.json
 Comment: 
 
-Filename: patato/recon/model_based/generate_model.pypy39-pp73-win_amd64.pyd
+Filename: patato/recon/recon_presets/backproject_standard_xy.json
 Comment: 
 
-Filename: patato/recon/model_based/generate_model_refraction.cpp
+Filename: patato/recon/recon_presets/backproject_clinical_xy.json
 Comment: 
 
-Filename: patato/recon/model_based/generate_model_refraction.cu
+Filename: patato/recon/recon_presets/backproject_clinical_yz.json
 Comment: 
 
-Filename: patato/recon/model_based/generate_model_refraction.pypy39-pp73-win_amd64.pyd
+Filename: patato/recon/recon_presets/backproject_standard_sos.json
 Comment: 
 
-Filename: patato/recon/model_based/model_based.py
+Filename: patato/recon/recon_presets/backproject_standard_xz.json
 Comment: 
 
-Filename: patato/recon/model_based/numpy_implementation.py
+Filename: patato/recon/recon_presets/backproject_janek_sos.json
 Comment: 
 
-Filename: patato/recon/numpy_backprojection/__init__.py
+Filename: patato/recon/recon_presets/backproject_janek.json
 Comment: 
 
-Filename: patato/recon/numpy_backprojection/recon.py
+Filename: patato/recon/recon_presets/backproject_noirf.json
+Comment: 
+
+Filename: patato/recon/recon_presets/backproject_standard_water_correction_new_ithera.json
+Comment: 
+
+Filename: patato/core/image_structures/
+Comment: 
+
+Filename: patato/core/__init__.py
+Comment: 
+
+Filename: patato/core/image_structures/single_parameter_data.py
+Comment: 
+
+Filename: patato/core/image_structures/pa_time_data.py
+Comment: 
+
+Filename: patato/core/image_structures/reconstruction_image.py
+Comment: 
+
+Filename: patato/core/image_structures/__init__.py
+Comment: 
+
+Filename: patato/core/image_structures/pa_raw_data.py
+Comment: 
+
+Filename: patato/core/image_structures/image_structure_types.py
+Comment: 
+
+Filename: patato/core/image_structures/unmixed_image.py
+Comment: 
+
+Filename: patato/core/image_structures/single_image.py
+Comment: 
+
+Filename: patato/core/image_structures/image_sequence.py
+Comment: 
+
+Filename: patato/useful_utilities/__init__.py
+Comment: 
+
+Filename: patato/unmixing/spectra/
+Comment: 
+
+Filename: patato/unmixing/unmix_presets/
 Comment: 
 
 Filename: patato/unmixing/__init__.py
 Comment: 
 
 Filename: patato/unmixing/unmixer.py
 Comment: 
 
+Filename: patato/unmixing/spectra/spectra_files/
+Comment: 
+
 Filename: patato/unmixing/spectra/__init__.py
 Comment: 
 
-Filename: patato/useful_utilities/__init__.py
+Filename: patato/unmixing/spectra/spectra_files/water.txt
 Comment: 
 
-Filename: patato/utils/__init__.py
+Filename: patato/unmixing/spectra/spectra_files/prahl.txt
 Comment: 
 
-Filename: patato/utils/mask_operations.py
+Filename: patato/unmixing/spectra/spectra_files/Melanin.csv
 Comment: 
 
-Filename: patato/utils/plotting.py
+Filename: patato/unmixing/spectra/spectra_files/ICG.csv
 Comment: 
 
-Filename: patato/utils/process_study.py
+Filename: patato/unmixing/spectra/spectra_files/lipids.txt
 Comment: 
 
-Filename: patato/utils/roi_operations.py
+Filename: patato/unmixing/spectra/spectra_files/water_long.txt
 Comment: 
 
-Filename: patato/utils/run_pipeline.py
+Filename: patato/unmixing/unmix_presets/hb_emma_water.json
 Comment: 
 
-Filename: patato/utils/time_series_analysis.py
+Filename: patato/unmixing/unmix_presets/haemoglobin_flow_phantom.json
 Comment: 
 
-Filename: patato/utils/rois/__init__.py
+Filename: patato/unmixing/unmix_presets/haemoglobin_flow_phantom_all_wl.json
 Comment: 
 
-Filename: patato/utils/rois/roi_type.py
+Filename: patato/unmixing/unmix_presets/hb_icg.json
 Comment: 
 
-Filename: patato/utils/tests/__init__.py
+Filename: patato/unmixing/unmix_presets/haemoglobin_melanin.json
+Comment: 
+
+Filename: patato/unmixing/unmix_presets/haemoglobin.json
+Comment: 
+
+Filename: patato/unmixing/unmix_presets/haemoglobin_mitox.json
+Comment: 
+
+Filename: patato/io/ipasc/
+Comment: 
+
+Filename: patato/io/simpa/
+Comment: 
+
+Filename: patato/io/json/
+Comment: 
+
+Filename: patato/io/ithera/
+Comment: 
+
+Filename: patato/io/hdf/
+Comment: 
+
+Filename: patato/io/hdf5_converter.py
+Comment: 
+
+Filename: patato/io/__init__.py
+Comment: 
+
+Filename: patato/io/attribute_tags.py
+Comment: 
+
+Filename: patato/io/msot_data.py
+Comment: 
+
+Filename: patato/io/ipasc/__init__.py
+Comment: 
+
+Filename: patato/io/ipasc/read_ipasc.py
+Comment: 
+
+Filename: patato/io/ipasc/ipasc_export.py
+Comment: 
+
+Filename: patato/io/simpa/__init__.py
+Comment: 
+
+Filename: patato/io/simpa/read_simpa.py
+Comment: 
+
+Filename: patato/io/json/__init__.py
+Comment: 
+
+Filename: patato/io/json/json_reading.py
+Comment: 
+
+Filename: patato/io/ithera/__init__.py
+Comment: 
+
+Filename: patato/io/ithera/read_ithera.py
+Comment: 
+
+Filename: patato/io/hdf/fileimporter.py
+Comment: 
+
+Filename: patato/io/hdf/__init__.py
+Comment: 
+
+Filename: patato/io/hdf/hdf5_interface.py
+Comment: 
+
+Filename: patato/processing/jax_preprocessing_algorithm.py
+Comment: 
+
+Filename: patato/processing/preprocessing_types.py
+Comment: 
+
+Filename: patato/processing/processing_algorithm.py
+Comment: 
+
+Filename: patato/processing/gpu_preprocessing_algorithm.py
+Comment: 
+
+Filename: patato/processing/__init__.py
+Comment: 
+
+Filename: patato/processing/preprocessing_algorithm.py
+Comment: 
+
+Filename: patato/data/__init__.py
+Comment: 
+
+Filename: patato/data/get_example_datasets.py
+Comment: 
+
+Filename: patato/data/simulated_datasets.py
 Comment: 
 
-Filename: patato-0.5.1.dist-info/LICENSE.MD
+Filename: patato-0.5.2.dist-info/WHEEL
 Comment: 
 
-Filename: patato-0.5.1.dist-info/METADATA
+Filename: patato-0.5.2.dist-info/LICENSE.MD
 Comment: 
 
-Filename: patato-0.5.1.dist-info/WHEEL
+Filename: patato-0.5.2.dist-info/top_level.txt
 Comment: 
 
-Filename: patato-0.5.1.dist-info/entry_points.txt
+Filename: patato-0.5.2.dist-info/METADATA
 Comment: 
 
-Filename: patato-0.5.1.dist-info/top_level.txt
+Filename: patato-0.5.2.dist-info/entry_points.txt
 Comment: 
 
-Filename: patato-0.5.1.dist-info/RECORD
+Filename: patato-0.5.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## patato/convenience_scripts/__init__.py

 * *Ordering differences only*

```diff
@@ -1,9 +1,9 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
-"""
-PATATO command line interfaces
-==============================
-
-A series of convenience scripts for running the patato package in the command line.
-"""
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
+"""
+PATATO command line interfaces
+==============================
+
+A series of convenience scripts for running the patato package in the command line.
+"""
```

## patato/convenience_scripts/process_msot.py

```diff
@@ -10,15 +10,16 @@
 import json
 import logging
 import os
 
 from .. import PAData
 from ..recon import get_default_recon_preset
 from .. import read_reconstruction_preset
-from ..utils import run_pipeline, sort_key
+from ..utils import sort_key
+from ..utils.pipeline import run_pipeline
 
 
 def main():
     parser = argparse.ArgumentParser(description="Process MSOT Data.")
     parser.add_argument('input', type=str, help="Data File")
     parser.add_argument('-c', '--speed', type=float, help="Speed of Sound", default=None)
     parser.add_argument('-o', '--output', type=str, help="Output File", default=None)
```

## patato/convenience_scripts/tune_speed_of_sound.py

```diff
@@ -141,15 +141,15 @@
             ax3 = axes[2]
 
         ax_slice = plt.axes([0.25, 0.2, 0.65, 0.03])
         ax_clims = plt.axes([0.25, 0.15, 0.65, 0.03])
         ax_slide = plt.axes([0.25, 0.1, 0.65, 0.03])
         ax_button = plt.axes([0.25, 0.025, 0.4, 0.05])
 
-        image = np.squeeze(recon)
+        image = np.asarray(np.squeeze(recon))
         if log:
             image = np.log(image)
 
         image_ranges = image[np.isfinite(image) & ~np.isnan(image)]
 
         ax2.hist(image_ranges)
         v_line_a = ax2.axvline(np.nanmin(image))
```

## patato/convenience_scripts/unmix.py

```diff
@@ -11,15 +11,16 @@
 import os.path
 from os.path import join
 
 import numpy as np
 from .. import PAData
 from ..unmixing import get_default_unmixing_preset
 from .. import read_unmixing_preset
-from ..utils import run_pipeline, sort_key
+from ..utils import sort_key
+from ..utils.pipeline import run_pipeline
 
 
 def init_argparse():
     parser = argparse.ArgumentParser(description="Process MSOT Data.")
     parser.add_argument('input', type=str, help="Data File")
     parser.add_argument('-w', '--wavelengths', nargs="*", type=float, default=[])
     parser.add_argument('-i', '--wavelengthindices', nargs="*", type=int, default=[])
```

## patato/convenience_scripts/data_analysis/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
```

## patato/convenience_scripts/data_analysis/analyse_dce.py

```diff
@@ -4,15 +4,15 @@
 import argparse
 import glob
 from os.path import join
 
 from ...io.msot_data import PAData
 from ...unmixing.unmixer import DCEAnalyser
 from ...utils import sort_key
-from ...utils.run_pipeline import run_pipeline
+from ...utils.pipeline import run_pipeline
 
 
 def init_argparse():
     parser = argparse.ArgumentParser(description="Analyse Gas Challenge Data.")
     parser.add_argument('input', type=str, help="Data Folder")
     parser.add_argument('-p', '--prefix', type=str, help="Gas Challenge name prefix")
     parser.add_argument('-w', '--window', type=int, help="Smoothing window size",
```

## patato/convenience_scripts/data_analysis/analyse_gas_challenge.py

```diff
@@ -4,15 +4,15 @@
 import argparse
 import glob
 from os.path import join
 
 from ...io.msot_data import PAData
 from ...unmixing.unmixer import GasChallengeAnalyser
 from ...utils import sort_key
-from ...utils.run_pipeline import run_pipeline
+from ...utils.pipeline import run_pipeline
 
 
 def init_argparse():
     parser = argparse.ArgumentParser(description="Analyse Gas Challenge Data.")
     parser.add_argument('input', type=str, help="Data Folder")
     parser.add_argument('-p', '--prefix', type=str, help="Gas Challenge name prefix")
     parser.add_argument('-w', '--window', type=int, help="Smoothing window size",
```

## patato/core/image_structures/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
```

## patato/data/__init__.py

 * *Ordering differences only*

```diff
@@ -1,21 +1,21 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
-"""
-Data examples
-====================
-
-PATATO data - an interface for exemplar data and basic simulations to illustrate the core features of PATATO.
-"""
-
-from .simulated_datasets import get_basic_p0, generate_basic_simulation
-from .get_example_datasets import get_msot_time_series_example, get_ithera_msot_time_series_example, \
-    get_msot_phantom_example
-
-__all_exports = [get_msot_time_series_example, get_ithera_msot_time_series_example,
-                 get_msot_phantom_example, get_basic_p0, generate_basic_simulation]
-
-for e in __all_exports:
-    e.__module__ = __name__
-
-__all__ = [e.__name__ for e in __all_exports]
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
+"""
+Data examples
+====================
+
+PATATO data - an interface for exemplar data and basic simulations to illustrate the core features of PATATO.
+"""
+
+from .simulated_datasets import get_basic_p0, generate_basic_simulation
+from .get_example_datasets import get_msot_time_series_example, get_ithera_msot_time_series_example, \
+    get_msot_phantom_example
+
+__all_exports = [get_msot_time_series_example, get_ithera_msot_time_series_example,
+                 get_msot_phantom_example, get_basic_p0, generate_basic_simulation]
+
+for e in __all_exports:
+    e.__module__ = __name__
+
+__all__ = [e.__name__ for e in __all_exports]
```

## patato/data/get_example_datasets.py

 * *Ordering differences only*

```diff
@@ -1,104 +1,104 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
-import os
-import shutil
-import zipfile
-from tempfile import mkdtemp
-from tqdm.auto import tqdm
-
-import requests
-from patato import iTheraMSOT
-
-from .. import PAData
-
-
-def get_patato_data_folder():
-    """Get the folder where PATATO example data is stored.
-
-    Returns
-    -------
-    folder : str
-        The folder where patato data is stored.
-    """
-    folder = os.environ.get("PAT_DATA_FOLDER") or "~/patato_example_data"
-
-    if folder == "TEMP":
-        os.environ["PAT_DATA_FOLDER"] = mkdtemp()
-        folder = os.environ["PAT_DATA_FOLDER"]
-    return os.path.expanduser(folder)
-
-
-def download_file(file_from, file_to):
-    raise NotImplementedError("No longer able to automatically download data."
-                              "Please download manually from: https://doi.org/10.17863/CAM.93181")
-
-
-def get_msot_time_series_example(image_type="so2"):
-    """Get a time series of MSOT images.
-
-    Returns
-    -------
-    dataset : PAData
-        The MSOT dataset.
-    """
-
-    data_sources = {"so2": "https://www.repository.cam.ac.uk/bitstream/handle/1810/345836/invivo_oe.hdf5",
-                    "icg": "https://www.repository.cam.ac.uk/bitstream/handle/1810/345836/invivo_dce.hdf5"}
-
-    data_path = os.path.join(get_patato_data_folder(), f'{image_type}-timeseries-data.hdf5')
-    folder = os.path.split(data_path)[0]
-    os.makedirs(folder, exist_ok=True)
-    if not os.path.exists(data_path):
-        # Download the data
-        download_file(data_sources[image_type], data_path)
-    return PAData.from_hdf5(data_path)
-
-
-def get_ithera_msot_time_series_example(image_type="so2"):
-    """Get a time series of MSOT images in the iThera format.
-
-    Returns
-    -------
-    dataset : PAData
-        The MSOT dataset.
-    """
-    import glob
-    print(glob.glob(get_patato_data_folder() + "/*"))
-    data_sources = {"so2": "https://www.repository.cam.ac.uk/bitstream/handle/1810/345836/ithera_invivo_oe.zip",
-                    "icg": "https://www.repository.cam.ac.uk/bitstream/handle/1810/345836/ithera_invivo_dce.zip"}
-
-    data_path = os.path.join(get_patato_data_folder(), f'{image_type}-ithera_data')
-    filenames = {"so2": "Scan_9", "icg": "Scan_10"}
-    folder = os.path.split(data_path)[0]
-    if folder and not os.path.exists(folder):
-        os.makedirs(folder, exist_ok=True)
-    if not os.path.exists(data_path):
-        # Download the data
-        zip_file = os.path.join(get_patato_data_folder(), "patato_temp.zip")
-        download_file(data_sources[image_type], zip_file)
-        with zipfile.ZipFile(zip_file, 'r') as zip_ref:
-            zip_ref.extractall(data_path)
-        print(f"Extracted data to {data_path}")
-    return PAData(iTheraMSOT(os.path.join(data_path, filenames[image_type])))
-
-
-def get_msot_phantom_example(image_type="clinical"):
-    """Get a time series of MSOT images.
-
-    Returns
-    -------
-    dataset : PAData
-        The MSOT dataset.
-    """
-    data_sources = {"clinical": "https://www.repository.cam.ac.uk/bitstream/handle/1810/345836/clinical_phantom.hdf5",
-                    "preclinical": "https://www.repository.cam.ac.uk/bitstream/handle/1810/345836/preclinical_phantom.hdf5"}
-
-    data_path = os.path.join(get_patato_data_folder(), f'{image_type}-msot-data.hdf5')
-    folder = os.path.split(data_path)[0]
-    if not os.path.exists(folder):
-        os.makedirs(folder, exist_ok=True)
-    if not os.path.exists(data_path):
-        # Download the data
-        download_file(data_sources[image_type], data_path)
-    return PAData.from_hdf5(data_path)
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
+import os
+import shutil
+import zipfile
+from tempfile import mkdtemp
+from tqdm.auto import tqdm
+
+import requests
+from patato import iTheraMSOT
+
+from .. import PAData
+
+
+def get_patato_data_folder():
+    """Get the folder where PATATO example data is stored.
+
+    Returns
+    -------
+    folder : str
+        The folder where patato data is stored.
+    """
+    folder = os.environ.get("PAT_DATA_FOLDER") or "~/patato_example_data"
+
+    if folder == "TEMP":
+        os.environ["PAT_DATA_FOLDER"] = mkdtemp()
+        folder = os.environ["PAT_DATA_FOLDER"]
+    return os.path.expanduser(folder)
+
+
+def download_file(file_from, file_to):
+    raise NotImplementedError("No longer able to automatically download data."
+                              "Please download manually from: https://doi.org/10.17863/CAM.93181")
+
+
+def get_msot_time_series_example(image_type="so2"):
+    """Get a time series of MSOT images.
+
+    Returns
+    -------
+    dataset : PAData
+        The MSOT dataset.
+    """
+
+    data_sources = {"so2": "https://www.repository.cam.ac.uk/bitstream/handle/1810/345836/invivo_oe.hdf5",
+                    "icg": "https://www.repository.cam.ac.uk/bitstream/handle/1810/345836/invivo_dce.hdf5"}
+
+    data_path = os.path.join(get_patato_data_folder(), f'{image_type}-timeseries-data.hdf5')
+    folder = os.path.split(data_path)[0]
+    os.makedirs(folder, exist_ok=True)
+    if not os.path.exists(data_path):
+        # Download the data
+        download_file(data_sources[image_type], data_path)
+    return PAData.from_hdf5(data_path)
+
+
+def get_ithera_msot_time_series_example(image_type="so2"):
+    """Get a time series of MSOT images in the iThera format.
+
+    Returns
+    -------
+    dataset : PAData
+        The MSOT dataset.
+    """
+    import glob
+    print(glob.glob(get_patato_data_folder() + "/*"))
+    data_sources = {"so2": "https://www.repository.cam.ac.uk/bitstream/handle/1810/345836/ithera_invivo_oe.zip",
+                    "icg": "https://www.repository.cam.ac.uk/bitstream/handle/1810/345836/ithera_invivo_dce.zip"}
+
+    data_path = os.path.join(get_patato_data_folder(), f'{image_type}-ithera_data')
+    filenames = {"so2": "Scan_9", "icg": "Scan_10"}
+    folder = os.path.split(data_path)[0]
+    if folder and not os.path.exists(folder):
+        os.makedirs(folder, exist_ok=True)
+    if not os.path.exists(data_path):
+        # Download the data
+        zip_file = os.path.join(get_patato_data_folder(), "patato_temp.zip")
+        download_file(data_sources[image_type], zip_file)
+        with zipfile.ZipFile(zip_file, 'r') as zip_ref:
+            zip_ref.extractall(data_path)
+        print(f"Extracted data to {data_path}")
+    return PAData(iTheraMSOT(os.path.join(data_path, filenames[image_type])))
+
+
+def get_msot_phantom_example(image_type="clinical"):
+    """Get a time series of MSOT images.
+
+    Returns
+    -------
+    dataset : PAData
+        The MSOT dataset.
+    """
+    data_sources = {"clinical": "https://www.repository.cam.ac.uk/bitstream/handle/1810/345836/clinical_phantom.hdf5",
+                    "preclinical": "https://www.repository.cam.ac.uk/bitstream/handle/1810/345836/preclinical_phantom.hdf5"}
+
+    data_path = os.path.join(get_patato_data_folder(), f'{image_type}-msot-data.hdf5')
+    folder = os.path.split(data_path)[0]
+    if not os.path.exists(folder):
+        os.makedirs(folder, exist_ok=True)
+    if not os.path.exists(data_path):
+        # Download the data
+        download_file(data_sources[image_type], data_path)
+    return PAData.from_hdf5(data_path)
```

## patato/data/simulated_datasets.py

 * *Ordering differences only*

```diff
@@ -1,83 +1,83 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
-
-import numpy as np
-
-
-def get_basic_p0(nx=333, dx=75e-6, r=0.005):
-    """
-
-    Get a basic p0 for the simulation.
-    Parameters
-    ----------
-    nx : int
-    dx : float
-
-    Returns
-    -------
-    p0 : ndarray
-
-    """
-
-    x, y = np.ogrid[:nx, :nx]
-    x = x.astype(np.float64) - (nx - 1) / 2
-    y = y.astype(np.float64) - (nx - 1) / 2
-    x = x * dx
-    y = y * dx
-    r2 = r ** 2
-    p0 = r2 - (x ** 2 + y ** 2)
-    p0[p0 < 0] = 0
-    return p0
-
-
-def generate_basic_model(ndet=256):
-    """
-    Generate a basic forward model for a photoacoustic system.
-
-    Parameters
-    ----------
-    ndet
-
-    Returns
-    -------
-    tuple of array_like, array_like
-    """
-    try:
-        import cupy as cp
-        from ..recon.model_based.cuda_implementation import get_model
-        CUDA_ENABLED = True
-    except ImportError:
-        from ..recon.model_based.numpy_implementation import get_model
-        CUDA_ENABLED = False
-
-    theta = np.linspace(0, 2 * np.pi, ndet, endpoint=False)
-    detectors = np.array([np.cos(theta), np.sin(theta), np.zeros_like(theta)]).T * 0.04
-
-    model = get_model(detectors[:, 0], detectors[:, 1], 1500 / 4e7, 75e-6, 333, -0.0125, 2030, cache=False)
-    if CUDA_ENABLED:
-        model = model.get()
-    model.eliminate_zeros()
-    model.sort_indices()
-    return model, detectors
-
-
-def generate_basic_simulation(ndet=256):
-    """
-    Generate a simulation of the photoacoustic time series for a given number of detectors in a circular geometry.
-    The initial pressure distribution used is a truncated paraboloid, which has an analytical solution for the
-    time series data. Here, we use the forward photacoustic model from the model-based reconstruction code.
-
-    Parameters
-    ----------
-    ndet: int - Number of detectors
-
-    Returns
-    -------
-    tuple of NDArray, NDArray, NDArray
-
-    """
-    model, detectors = generate_basic_model(ndet)
-    p0 = get_basic_p0()
-    ts = (model @ p0.flatten()).reshape(ndet, 2030)
-    return p0, ts, detectors
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
+
+import numpy as np
+
+
+def get_basic_p0(nx=333, dx=75e-6, r=0.005):
+    """
+
+    Get a basic p0 for the simulation.
+    Parameters
+    ----------
+    nx : int
+    dx : float
+
+    Returns
+    -------
+    p0 : ndarray
+
+    """
+
+    x, y = np.ogrid[:nx, :nx]
+    x = x.astype(np.float64) - (nx - 1) / 2
+    y = y.astype(np.float64) - (nx - 1) / 2
+    x = x * dx
+    y = y * dx
+    r2 = r ** 2
+    p0 = r2 - (x ** 2 + y ** 2)
+    p0[p0 < 0] = 0
+    return p0
+
+
+def generate_basic_model(ndet=256):
+    """
+    Generate a basic forward model for a photoacoustic system.
+
+    Parameters
+    ----------
+    ndet
+
+    Returns
+    -------
+    tuple of array_like, array_like
+    """
+    try:
+        import cupy as cp
+        from ..recon.model_based.cuda_implementation import get_model
+        CUDA_ENABLED = True
+    except ImportError:
+        from ..recon.model_based.numpy_implementation import get_model
+        CUDA_ENABLED = False
+
+    theta = np.linspace(0, 2 * np.pi, ndet, endpoint=False)
+    detectors = np.array([np.cos(theta), np.sin(theta), np.zeros_like(theta)]).T * 0.04
+
+    model = get_model(detectors[:, 0], detectors[:, 1], 1500 / 4e7, 75e-6, 333, -0.0125, 2030, cache=False)
+    if CUDA_ENABLED:
+        model = model.get()
+    model.eliminate_zeros()
+    model.sort_indices()
+    return model, detectors
+
+
+def generate_basic_simulation(ndet=256):
+    """
+    Generate a simulation of the photoacoustic time series for a given number of detectors in a circular geometry.
+    The initial pressure distribution used is a truncated paraboloid, which has an analytical solution for the
+    time series data. Here, we use the forward photacoustic model from the model-based reconstruction code.
+
+    Parameters
+    ----------
+    ndet: int - Number of detectors
+
+    Returns
+    -------
+    tuple of NDArray, NDArray, NDArray
+
+    """
+    model, detectors = generate_basic_model(ndet)
+    p0 = get_basic_p0()
+    ts = (model @ p0.flatten()).reshape(ndet, 2030)
+    return p0, ts, detectors
```

## patato/experimental/__init__.py

 * *Ordering differences only*

```diff
@@ -1,2 +1,2 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
```

## patato/experimental/simulation/__init__.py

 * *Ordering differences only*

```diff
@@ -1,4 +1,4 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
-
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
+
```

## patato/io/hdf/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
```

## patato/io/hdf/fileimporter.py

```diff
@@ -303,15 +303,15 @@
         self.set_correction_factor(reader.get_correction_factor())
         self.set_scanner_z_position(reader.get_scanner_z_position())
         self.set_run_numbers(reader.get_run_numbers())
         self.set_repetition_numbers(reader.get_repetition_numbers())
         self.set_scan_times(reader.get_scan_times())
         self.set_sensor_geometry(reader.get_sensor_geometry())
         if reader.get_us_data()[0] is not None:
-            print(reader.get_us_data())
+            # print(reader.get_us_data())
             self.set_us_data(*reader.get_us_data())  # TODO: implement us data as a image data type.
         self.set_impulse_response(reader.get_impulse_response())
         self.set_wavelengths(reader.get_wavelengths())
         self.set_us_offsets(reader.get_us_offsets())
         self.set_water_absorption(*reader.get_water_absorption())
         if reader.get_datasets() is not None:
             for _, image_group in reader.get_datasets().items():
```

## patato/io/ipasc/__init__.py

```diff
@@ -1,18 +1,18 @@
 #  Copyright (c) Thomas Else 2023.
 #  License: MIT
 
 import h5py
 import pacfish as pf
 
-from .ipasc_export import TomHDF5AdapterToIPASCFormat
+from .ipasc_export import PatHDF5AdapterToIPASCFormat
 
 
 def export_to_ipasc(path_to_hdf5, out_path=None):
     if out_path is None:
         out_path = path_to_hdf5.replace(".hdf5", "_ipasc.hdf5")
 
     hdf5_file = h5py.File(path_to_hdf5, "r")
-    converter = TomHDF5AdapterToIPASCFormat(hdf5_file=hdf5_file)
+    converter = PatHDF5AdapterToIPASCFormat(hdf5_file=hdf5_file)
     print(hdf5_file.keys())
     pa_data = converter.generate_pa_data()
     pf.write_data(out_path, pa_data)
```

## patato/io/ipasc/read_ipasc.py

```diff
@@ -1,94 +1,99 @@
-#  Copyright (c) Thomas Else 2023.
-#  Copyright (c) Janek Grohl 2023.
-#  License: MIT
-
-from os.path import split
-import pacfish as pf
-import numpy as np
-from ..hdf.fileimporter import ReaderInterface
-
-
-class IPASCInterface(ReaderInterface):
-    """
-    An interface for iThera MSOT datasets.
-    """
-    def _get_rois(self):
-        pass
-
-    def _get_segmentation(self):
-        return None
-
-    def _get_datasets(self):
-        return None
-
-    def get_speed_of_sound(self):
-        return None
-
-    def __init__(self, file_path):
-        super().__init__()
-        self.scan_name = split(file_path)[-1]
-        self.pa_data = pf.load_data(file_path)
-        self.nwavelengths = len(self.pa_data.get_acquisition_wavelengths())
-        self.nframes = np.shape(self.pa_data.binary_time_series_data)[3]
-        # Optional add here: extract the reconstructed images that are from ViewMSOT.
-        # Extract attributes
-        self.geometry = self.pa_data.get_detector_position()
-        self.nsamples = self.nwavelengths * self.nframes
-
-    def get_n_samples(self):
-        return self.nsamples
-
-    def _get_wavelengths(self):
-        return self.pa_data.get_acquisition_wavelengths()
-
-    def _get_correction_factor(self):
-        return self.pa_data.get_overall_gain()
-
-    def get_impulse_response(self):
-        return self.pa_data.get_frequency_response()
-
-    def _get_repetition_numbers(self):
-        return self.nsamples
-
-    def _get_run_numbers(self):
-        return np.arange(1, self.nframes+1)
-
-    def get_scan_datetime(self):
-        return None
-
-    def _get_scan_times(self):
-        return self.pa_data.get_measurement_time_stamps()
-
-    def _get_temperature(self):
-        return self.pa_data.get_temperature()
-
-    def get_us_offsets(self):
-        return None
-
-    def _get_pa_data(self):
-        raw_data = self.pa_data.binary_time_series_data # [detectors, samples, wavelengths, frames]
-        raw_data = np.swapaxes(raw_data, 1, 3)  # [detectors, frames, wavelengths, samples]
-        raw_data = np.swapaxes(raw_data, 0, 2)  # [wavelengths, frames, detectors, samples]
-        raw_data = np.swapaxes(raw_data, 0, 1)  # [frames, wavelengths, detectors, samples]
-        return raw_data, {"fs": self.pa_data.get_sampling_rate()}
-
-    def _get_sampling_frequency(self):
-        return self.pa_data.get_sampling_rate()
-
-    def _get_sensor_geometry(self):
-        return self.pa_data.get_detector_position()
-
-    def _get_water_absorption(self):
-        return None
-
-    def get_us_data(self):
-        return None
-
-    def get_scan_name(self):
-        return self.scan_name
-
-    def _get_scanner_z_position(self):
-        return self.pa_data.get_measurement_spatial_poses()
-
-    def get_scan_comment(self):
-        return ""
+#  Copyright (c) Thomas Else 2023.
+#  Copyright (c) Janek Grohl 2023.
+#  License: MIT
+
+from os.path import split
+import pacfish as pf
+import numpy as np
+from ..hdf.fileimporter import ReaderInterface
+
+
+class IPASCInterface(ReaderInterface):
+    """
+    An interface for iThera MSOT datasets.
+    """
+    def _get_rois(self):
+        pass
+
+    def _get_segmentation(self):
+        return None
+
+    def _get_datasets(self):
+        return None
+
+    def get_speed_of_sound(self):
+        return None
+
+    def __init__(self, file_path):
+        super().__init__()
+        self.scan_name = split(file_path)[-1]
+        self.pa_data = pf.load_data(file_path)
+        if len(self.pa_data.get_acquisition_wavelengths().shape) == 0:
+            self.nwavelengths = 1
+        else:
+            self.nwavelengths = len(self.pa_data.get_acquisition_wavelengths())
+        self.nframes = np.shape(self.pa_data.binary_time_series_data)[3]
+        # Optional add here: extract the reconstructed images that are from ViewMSOT.
+        # Extract attributes
+        self.geometry = self.pa_data.get_detector_position()
+        self.nsamples = self.nwavelengths * self.nframes
+
+    def get_n_samples(self):
+        return self.nsamples
+
+    def _get_wavelengths(self):
+        if len(self.pa_data.get_acquisition_wavelengths().shape) == 0:
+            return [self.pa_data.get_acquisition_wavelengths().item()]
+        return self.pa_data.get_acquisition_wavelengths()
+
+    def _get_correction_factor(self):
+        return self.pa_data.get_overall_gain()
+
+    def get_impulse_response(self):
+        return self.pa_data.get_frequency_response()
+
+    def _get_repetition_numbers(self):
+        return self.nsamples
+
+    def _get_run_numbers(self):
+        return np.arange(1, self.nframes+1)
+
+    def get_scan_datetime(self):
+        return None
+
+    def _get_scan_times(self):
+        return self.pa_data.get_measurement_time_stamps()
+
+    def _get_temperature(self):
+        return self.pa_data.get_temperature()
+
+    def get_us_offsets(self):
+        return None
+
+    def _get_pa_data(self):
+        raw_data = self.pa_data.binary_time_series_data # [detectors, samples, wavelengths, frames]
+        raw_data = np.swapaxes(raw_data, 1, 3)  # [detectors, frames, wavelengths, samples]
+        raw_data = np.swapaxes(raw_data, 0, 2)  # [wavelengths, frames, detectors, samples]
+        raw_data = np.swapaxes(raw_data, 0, 1)  # [frames, wavelengths, detectors, samples]
+        return raw_data, {"fs": self.pa_data.get_sampling_rate()}
+
+    def _get_sampling_frequency(self):
+        return self.pa_data.get_sampling_rate()
+
+    def _get_sensor_geometry(self):
+        return self.pa_data.get_detector_position()
+
+    def _get_water_absorption(self):
+        return None
+
+    def get_us_data(self):
+        return None
+
+    def get_scan_name(self):
+        return self.scan_name
+
+    def _get_scanner_z_position(self):
+        return self.pa_data.get_measurement_spatial_poses()
+
+    def get_scan_comment(self):
+        return ""
```

## patato/io/json/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
```

## patato/io/json/json_reading.py

 * *Ordering differences only*

```diff
@@ -1,154 +1,154 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
-import json
-from typing import Union, Optional
-
-from ..attribute_tags import PreprocessingAttributeTags, UnmixingAttributeTags, ReconAttributeTags
-from ..msot_data import PAData
-from ...processing.preprocessing_types import PREPROCESSING_NAMES
-from ...unmixing.unmixer import SpectralUnmixer, SO2Calculator, THbCalculator
-from ...recon import RECONSTRUCTION_NAMES
-
-
-def read_reconstruction_preset(json_path: Union[str, dict]):
-    """
-        Load and parse the reconstruction preset from the specified JSON file or dictionary.
-
-        Parameters
-        ----------
-        json_path : Union[str, dict]
-            The path to the JSON file or a dictionary containing the reconstruction preset.
-
-        Returns
-        -------
-        settings : SpatialProcessingAlgorithm
-            The parsed reconstruction preset as a pipeline element.
-
-        """
-    # Load json
-    if type(json_path) == str:
-        with open(json_path) as json_file:
-            settings = json.load(json_file)
-    else:
-        settings = json_path
-
-    # Preprocessing parameters
-    filter_highpass = settings.get(PreprocessingAttributeTags.HIGH_PASS_FILTER, None)
-    filter_lowpass = settings.get(PreprocessingAttributeTags.LOW_PASS_FILTER, None)
-
-    time_interpolation_factor = settings.get(PreprocessingAttributeTags.TIME_INTERPOLATION, 3)
-    detector_interpolation_factor = settings.get(PreprocessingAttributeTags.DETECTOR_INTERPOLATION, 2)
-
-    correct_for_impulse_response = settings.get(PreprocessingAttributeTags.IMPULSE_RESPONSE, True)
-    do_hilbert_transform = settings.get(PreprocessingAttributeTags.HILBERT_TRANSFORM, False)
-    do_envelope_detection = settings.get(PreprocessingAttributeTags.ENVELOPE_DETECTION, False)
-
-    window_size = settings.get(PreprocessingAttributeTags.WINDOW_SIZE, 512)
-
-    absolute_transformation = "imag"
-    if do_envelope_detection:
-        absolute_transformation = "abs"
-    elif not do_hilbert_transform:
-        absolute_transformation = "real"
-
-    preprocessing_algorithm = PREPROCESSING_NAMES[settings[PreprocessingAttributeTags.PROCESSING_ALGORITHM]]
-
-    # Reconstruction parameters.
-    recon_params = settings.get(ReconAttributeTags.ADDITIONAL_PARAMETERS, {})  # Custom parameters
-
-    # Field of view y and z:
-    field_of_view_x = settings.get(ReconAttributeTags.X_FIELD_OF_VIEW, 0.)
-    field_of_view_y = settings.get(ReconAttributeTags.Y_FIELD_OF_VIEW, 0.)
-    field_of_view_z = settings.get(ReconAttributeTags.Z_FIELD_OF_VIEW, 0.)
-
-    number_of_pixels_x = settings.get(ReconAttributeTags.X_NUMBER_OF_PIXELS, 1)
-    number_of_pixels_y = settings.get(ReconAttributeTags.Y_NUMBER_OF_PIXELS, 1)
-    number_of_pixels_z = settings.get(ReconAttributeTags.Z_NUMBER_OF_PIXELS, 1)
-
-    # Number of pixels x and y
-    reconstruction_algorithm = RECONSTRUCTION_NAMES[settings[ReconAttributeTags.RECONSTRUCTION_ALGORITHM]]
-
-    # Whether to do universal backprojection.
-    ubp = settings.get("UBP", False)
-    step_1 = preprocessing_algorithm(time_factor=time_interpolation_factor,
-                                     detector_factor=detector_interpolation_factor,
-                                     irf=correct_for_impulse_response,
-                                     hilbert=do_hilbert_transform,
-                                     lp_filter=filter_lowpass,
-                                     hp_filter=filter_highpass,
-                                     filter_window_size=window_size,
-                                     absolute=absolute_transformation,
-                                     universal_backprojection=ubp
-                                     )
-    step_2 = reconstruction_algorithm((number_of_pixels_x, number_of_pixels_y, number_of_pixels_z),
-                                      (field_of_view_x, field_of_view_y, field_of_view_z),
-                                      **recon_params)
-    step_1.add_child(step_2)
-    return step_1
-
-
-def read_unmixing_preset(json_path: Union[str, dict], example_data: Optional[PAData], **kwargs):
-    """
-    Load and parse the unmixing preset from the specified JSON file or dictionary.
-
-    Parameters
-    ----------
-    json_path : Union[str, dict]
-        The path to the JSON file or a dictionary containing the unmixing preset.
-
-    example_data : PAData or None
-        An example dataset used to obtain settings such as wavelengths.
-
-    Returns
-    -------
-    unmixing_preset : SpatialProcessingAlgorithm
-        The parsed unmixing preset as a pipeline element.
-
-    """
-    # Load json
-    if type(json_path) == str:
-        with open(json_path) as json_file:
-            settings = json.load(json_file)
-    else:
-        settings = json_path
-    settings.update(kwargs)
-
-    # Load wavelengths from the preset or use the wavelengths from the example data
-    wavelengths = settings.get(UnmixingAttributeTags.UNMIXING_WAVELENGTHS, None)
-    wavelength_indices = settings.get(UnmixingAttributeTags.WAVELENGTH_INDICES, None)
-    wavelength_range = settings.get(UnmixingAttributeTags.WAVELENGTH_RANGE, None)
-
-    if wavelengths is None and wavelength_indices is None and wavelength_range is None:
-        # Use all wavelengths from the example data
-        wavelengths = example_data.get_wavelengths()[:]
-    elif wavelengths is None and wavelength_indices is None:
-        # Use all wavelengths within the specified range
-        wavelengths = example_data.get_wavelengths()[:]
-        wavelengths = wavelengths[(wavelengths >= wavelength_range[0]) & (wavelengths <= wavelength_range[1])]
-    elif wavelengths is None:
-        # Use the specified indices from the example data
-        wavelengths = example_data.get_wavelengths()[:][wavelength_indices]
-
-    # Get other unmixing settings from the preset
-    resolution_reduction_factor = settings[UnmixingAttributeTags.RESOLUTION_REDUCE]
-    spectra_names = settings[UnmixingAttributeTags.SPECTRA]
-
-    # Initialize the spectral unmixer pipeline
-    from patato.unmixing.spectra import SPECTRA_NAMES
-    spectra = [SPECTRA_NAMES[x]() for x in spectra_names]
-
-    compute_so2 = settings[UnmixingAttributeTags.COMPUTE_SO2]
-
-    suffix = settings[UnmixingAttributeTags.SUFFIX]
-
-    pipeline = SpectralUnmixer(spectra, wavelengths, resolution_reduction_factor, algorithm_id=suffix)
-
-    # If haemoglobin and oxyhaemoglobin are present in the spectra, add THb and SO2 calculations to the pipeline
-    if UnmixingAttributeTags.HAEMOGLOBIN in spectra_names and UnmixingAttributeTags.OXYHAEMOGLOBIN in spectra_names:
-        thb = THbCalculator(suffix)
-        pipeline.add_child(thb)
-        if compute_so2:
-            so2 = SO2Calculator(suffix)
-            pipeline.add_child(so2)
-    return pipeline
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
+import json
+from typing import Union, Optional
+
+from ..attribute_tags import PreprocessingAttributeTags, UnmixingAttributeTags, ReconAttributeTags
+from ..msot_data import PAData
+from ...processing.preprocessing_types import PREPROCESSING_NAMES
+from ...unmixing.unmixer import SpectralUnmixer, SO2Calculator, THbCalculator
+from ...recon import RECONSTRUCTION_NAMES
+
+
+def read_reconstruction_preset(json_path: Union[str, dict]):
+    """
+        Load and parse the reconstruction preset from the specified JSON file or dictionary.
+
+        Parameters
+        ----------
+        json_path : Union[str, dict]
+            The path to the JSON file or a dictionary containing the reconstruction preset.
+
+        Returns
+        -------
+        settings : SpatialProcessingAlgorithm
+            The parsed reconstruction preset as a pipeline element.
+
+        """
+    # Load json
+    if type(json_path) == str:
+        with open(json_path) as json_file:
+            settings = json.load(json_file)
+    else:
+        settings = json_path
+
+    # Preprocessing parameters
+    filter_highpass = settings.get(PreprocessingAttributeTags.HIGH_PASS_FILTER, None)
+    filter_lowpass = settings.get(PreprocessingAttributeTags.LOW_PASS_FILTER, None)
+
+    time_interpolation_factor = settings.get(PreprocessingAttributeTags.TIME_INTERPOLATION, 3)
+    detector_interpolation_factor = settings.get(PreprocessingAttributeTags.DETECTOR_INTERPOLATION, 2)
+
+    correct_for_impulse_response = settings.get(PreprocessingAttributeTags.IMPULSE_RESPONSE, True)
+    do_hilbert_transform = settings.get(PreprocessingAttributeTags.HILBERT_TRANSFORM, False)
+    do_envelope_detection = settings.get(PreprocessingAttributeTags.ENVELOPE_DETECTION, False)
+
+    window_size = settings.get(PreprocessingAttributeTags.WINDOW_SIZE, 512)
+
+    absolute_transformation = "imag"
+    if do_envelope_detection:
+        absolute_transformation = "abs"
+    elif not do_hilbert_transform:
+        absolute_transformation = "real"
+
+    preprocessing_algorithm = PREPROCESSING_NAMES[settings[PreprocessingAttributeTags.PROCESSING_ALGORITHM]]
+
+    # Reconstruction parameters.
+    recon_params = settings.get(ReconAttributeTags.ADDITIONAL_PARAMETERS, {})  # Custom parameters
+
+    # Field of view y and z:
+    field_of_view_x = settings.get(ReconAttributeTags.X_FIELD_OF_VIEW, 0.)
+    field_of_view_y = settings.get(ReconAttributeTags.Y_FIELD_OF_VIEW, 0.)
+    field_of_view_z = settings.get(ReconAttributeTags.Z_FIELD_OF_VIEW, 0.)
+
+    number_of_pixels_x = settings.get(ReconAttributeTags.X_NUMBER_OF_PIXELS, 1)
+    number_of_pixels_y = settings.get(ReconAttributeTags.Y_NUMBER_OF_PIXELS, 1)
+    number_of_pixels_z = settings.get(ReconAttributeTags.Z_NUMBER_OF_PIXELS, 1)
+
+    # Number of pixels x and y
+    reconstruction_algorithm = RECONSTRUCTION_NAMES[settings[ReconAttributeTags.RECONSTRUCTION_ALGORITHM]]
+
+    # Whether to do universal backprojection.
+    ubp = settings.get("UBP", False)
+    step_1 = preprocessing_algorithm(time_factor=time_interpolation_factor,
+                                     detector_factor=detector_interpolation_factor,
+                                     irf=correct_for_impulse_response,
+                                     hilbert=do_hilbert_transform,
+                                     lp_filter=filter_lowpass,
+                                     hp_filter=filter_highpass,
+                                     filter_window_size=window_size,
+                                     absolute=absolute_transformation,
+                                     universal_backprojection=ubp
+                                     )
+    step_2 = reconstruction_algorithm((number_of_pixels_x, number_of_pixels_y, number_of_pixels_z),
+                                      (field_of_view_x, field_of_view_y, field_of_view_z),
+                                      **recon_params)
+    step_1.add_child(step_2)
+    return step_1
+
+
+def read_unmixing_preset(json_path: Union[str, dict], example_data: Optional[PAData], **kwargs):
+    """
+    Load and parse the unmixing preset from the specified JSON file or dictionary.
+
+    Parameters
+    ----------
+    json_path : Union[str, dict]
+        The path to the JSON file or a dictionary containing the unmixing preset.
+
+    example_data : PAData or None
+        An example dataset used to obtain settings such as wavelengths.
+
+    Returns
+    -------
+    unmixing_preset : SpatialProcessingAlgorithm
+        The parsed unmixing preset as a pipeline element.
+
+    """
+    # Load json
+    if type(json_path) == str:
+        with open(json_path) as json_file:
+            settings = json.load(json_file)
+    else:
+        settings = json_path
+    settings.update(kwargs)
+
+    # Load wavelengths from the preset or use the wavelengths from the example data
+    wavelengths = settings.get(UnmixingAttributeTags.UNMIXING_WAVELENGTHS, None)
+    wavelength_indices = settings.get(UnmixingAttributeTags.WAVELENGTH_INDICES, None)
+    wavelength_range = settings.get(UnmixingAttributeTags.WAVELENGTH_RANGE, None)
+
+    if wavelengths is None and wavelength_indices is None and wavelength_range is None:
+        # Use all wavelengths from the example data
+        wavelengths = example_data.get_wavelengths()[:]
+    elif wavelengths is None and wavelength_indices is None:
+        # Use all wavelengths within the specified range
+        wavelengths = example_data.get_wavelengths()[:]
+        wavelengths = wavelengths[(wavelengths >= wavelength_range[0]) & (wavelengths <= wavelength_range[1])]
+    elif wavelengths is None:
+        # Use the specified indices from the example data
+        wavelengths = example_data.get_wavelengths()[:][wavelength_indices]
+
+    # Get other unmixing settings from the preset
+    resolution_reduction_factor = settings[UnmixingAttributeTags.RESOLUTION_REDUCE]
+    spectra_names = settings[UnmixingAttributeTags.SPECTRA]
+
+    # Initialize the spectral unmixer pipeline
+    from patato.unmixing.spectra import SPECTRA_NAMES
+    spectra = [SPECTRA_NAMES[x]() for x in spectra_names]
+
+    compute_so2 = settings[UnmixingAttributeTags.COMPUTE_SO2]
+
+    suffix = settings[UnmixingAttributeTags.SUFFIX]
+
+    pipeline = SpectralUnmixer(spectra, wavelengths, resolution_reduction_factor, algorithm_id=suffix)
+
+    # If haemoglobin and oxyhaemoglobin are present in the spectra, add THb and SO2 calculations to the pipeline
+    if UnmixingAttributeTags.HAEMOGLOBIN in spectra_names and UnmixingAttributeTags.OXYHAEMOGLOBIN in spectra_names:
+        thb = THbCalculator(suffix)
+        pipeline.add_child(thb)
+        if compute_so2:
+            so2 = SO2Calculator(suffix)
+            pipeline.add_child(so2)
+    return pipeline
```

## patato/io/simpa/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
```

## patato/processing/__init__.py

 * *Ordering differences only*

```diff
@@ -1,10 +1,10 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
-"""
-Time-series data processing module
-=========================================
-
-This module provides functions for commonly-used pre-processing procedures used in photoacoustic imaging.
-This includes, for example, band-pass filtering, Hilbert transforms and interpolation.
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
+"""
+Time-series data processing module
+=========================================
+
+This module provides functions for commonly-used pre-processing procedures used in photoacoustic imaging.
+This includes, for example, band-pass filtering, Hilbert transforms and interpolation.
 """
```

## patato/processing/jax_preprocessing_algorithm.py

 * *Ordering differences only*

```diff
@@ -1,314 +1,314 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
-from functools import partial
-from typing import Union, Tuple, Optional, Dict
-
-import numpy as np
-from patato.io.attribute_tags import PreprocessingAttributeTags
-from scipy.signal.windows import hann
-
-from .processing_algorithm import TimeSeriesProcessingAlgorithm
-
-try:
-    import jax.numpy as jnp
-    import jax
-except ImportError:
-    jnp = None
-    jax = None
-
-import warnings
-
-from ..core.image_structures.pa_time_data import PATimeSeries
-
-# Specify Array type
-Array = np.typing.NDArray
-
-@jax.jit
-def subtract_mean(time_series):
-    # A function to subtract the mean from a time series
-    return time_series - jnp.mean(time_series, axis=-1).reshape(time_series.shape[:-1] + (1,))
-
-
-@partial(jax.jit, static_argnums=(1,))
-def interpolate_detectors(detectors, ndet):
-    # Interpolate the detectors to the correct number of detectors
-    new_detector_i = jnp.linspace(0, detectors.shape[0] - 1, ndet * detectors.shape[0])
-    old_detector_i = jnp.arange(detectors.shape[0])
-    interp_detectors = jax.vmap(jnp.interp, in_axes=(None, None, -1), out_axes=-1)
-    new_detectors = interp_detectors(new_detector_i, old_detector_i, detectors)
-    return new_detectors
-
-
-@partial(jax.jit, static_argnums=(1, 2))
-def partial_interpolate(time_series: Array, nt: int, ndet: int) -> Array:
-    # Interpolate the time series to the correct number of time points
-    new_detector_i = jnp.linspace(0, time_series.shape[-2] - 1, ndet * time_series.shape[-2])
-    old_detector_i = jnp.arange(time_series.shape[-2])
-    new_times = jnp.linspace(0, time_series.shape[-1] - 1, nt * time_series.shape[-1] + 1)[:-1]
-    old_times = jnp.arange(time_series.shape[-1])
-
-    interp_detectors = jax.vmap(jnp.interp, in_axes=(None, None, -1), out_axes=-1)
-    new_time_series = interp_detectors(new_detector_i, old_detector_i, time_series)
-
-    interp_time = jax.vmap(jnp.interp, in_axes=(None, None, 0), out_axes=0)
-    new_time_series = interp_time(new_times, old_times, new_time_series)
-    return new_time_series
-
-
-def make_filter(n_samples: int, fs: float, irf: Array, hilbert: bool, lp_filter: Optional[float],
-                hp_filter: Optional[float], rise: float = 0.2, n_filter: int = 1024, window: Optional[str] = None):
-    """
-    Make the filter for the time series
-
-    Parameters
-    ----------
-    n_samples : int
-    fs : float
-    irf : Array
-    hilbert : bool
-    lp_filter: float or None
-    hp_filter: float or None
-    rise: float
-    n_filter : int
-    window
-
-    Returns
-    -------
-
-    """
-    output = np.ones((n_samples,), dtype=np.cdouble)
-
-    # Impulse response correction
-    if irf is not None:
-        irf_shifted = np.fft.fftshift(irf)
-        # Divide by the impulse response to deconvolve
-        output *= np.conj(np.fft.fft(irf_shifted)) / np.abs(np.fft.fft(irf_shifted)) ** 2
-        # Suppress high frequencies to avoid amplifying noise - apply a window.
-        output *= np.fft.fftshift(hann(n_samples))
-
-    # Hilbert Transform
-    frequencies = np.fft.fftfreq(n_samples)
-    if hilbert:
-        # TODO: check this
-        # Multiply positive frequencies by
-        output *= (1 + np.sign(frequencies)) / 2
-
-    frequencies = np.abs(np.fft.fftfreq(n_filter, 1 / fs))
-    filter_output = np.ones_like(frequencies, dtype=np.cdouble)
-
-    if hp_filter is not None:
-        filter_output[frequencies < hp_filter * (1 - rise)] = 0
-        in_rise = np.logical_and(frequencies > hp_filter * (1 - rise), frequencies < hp_filter)
-        filter_output[in_rise] = (frequencies[in_rise] - hp_filter * (1 - rise)) / (hp_filter * rise)
-
-    if lp_filter is not None:
-        filter_output[frequencies > lp_filter * (1 + rise)] = 0
-        in_rise = np.logical_and(frequencies < lp_filter * (1 + rise), frequencies > lp_filter)
-        filter_output[in_rise] = 1 - (frequencies[in_rise] - lp_filter) / (lp_filter * rise)
-
-    time_series = np.fft.ifft(filter_output)
-
-    if window == "hann":
-        time_series *= np.fft.fftshift(hann(n_filter))
-
-    filter_time = np.zeros_like(output)
-    filter_time[:n_filter // 2] = time_series[:n_filter // 2]
-    filter_time[-n_filter // 2:] = time_series[-n_filter // 2:]
-
-    filter_output = np.fft.fft(filter_time)
-    output *= filter_output
-    return output
-
-
-class PreProcessor(TimeSeriesProcessingAlgorithm):
-    """ Preprocesses MSOT time series data. Uses JAX in the background.
-    """
-
-    @staticmethod
-    def get_algorithm_name() -> Union[str, None]:
-        """
-        Get the name of the algorithm.
-
-        Returns
-        -------
-        str or None
-        """
-        return "Standard Preprocessor"
-
-    @staticmethod
-    def get_hdf5_group_name() -> Union[str, None]:
-        """
-        Return the name of the group in the HDF5 file
-
-        Returns
-        -------
-        str or None
-
-        """
-        # Return the name of the group in the HDF5 file
-        return None
-
-    def __init__(self, time_factor: int = 3, detector_factor: int = 2,
-                 irf: bool = True, hilbert: bool = True, lp_filter: Optional[float] = None,
-                 hp_filter: Optional[float] = None, filter_window_size: int = 512,
-                 window: str = "hann", absolute: Optional[str] = None, universal_backprojection=False):
-        # Initialise the preprocessor
-        super().__init__()
-        self.time_factor = time_factor
-        self.detector_factor = detector_factor
-        self.hilbert = hilbert
-        absolute = "imag" if absolute is None and hilbert else absolute
-        self.ubp = universal_backprojection
-        self.irf_correct = irf
-        self.lp_filter = lp_filter
-        self.hp_filter = hp_filter
-        self.n_filter = filter_window_size
-        self.window = window
-        self.absolute = absolute
-        self.filter = None
-
-    def pre_compute_filter(self, n_samples: int, fs: float, irf: Array = None):
-        """
-        Precompute the filter to be applied.
-
-        Parameters
-        ----------
-        n_samples : int
-        fs : float
-        irf : Array
-        """
-        self.filter = jnp.array(make_filter(n_samples, fs, irf, self.hilbert, self.lp_filter, self.hp_filter))
-
-    def _run(self, time_series: Array, detectors: Array, overall_correction_factor, **kwargs):
-        """
-        Run the preprocessing step on a given time series and detectors. This allows batch processing,
-         e.g. if the data doesn't fit into memory.
-
-        Parameters
-        ----------
-        time_series : Array
-        detectors   : Array
-        overall_correction_factor: Array
-        kwargs    : dict
-
-        Returns
-        -------
-        tuple of Array, Array
-        """
-        shape = time_series.shape
-        time_series = jnp.array(time_series.reshape((-1,) + shape[-2:]))
-        detectors = jnp.array(detectors)
-
-        # Subtract mean
-        time_series = subtract_mean(time_series)
-
-        # Apply filters
-        time_series_ft = jnp.fft.fft(time_series)
-
-        time_series_ft = time_series_ft * self.filter.reshape((1,) * (time_series.ndim - 1) + (-1,))
-        if self.absolute == "imag":
-            op = jnp.imag
-        else:
-            op = jnp.real
-        time_series = op(jnp.fft.ifft(time_series_ft))
-
-        # Allow for universal backprojection here.
-        if self.ubp:
-            time_series -= jnp.gradient(time_series, axis=-1)*jnp.arange(time_series.shape[-1])
-
-        # Interpolate in time domain and detector domain
-        if not (self.detector_factor == 1 and self.time_factor == 1):
-            full_interpolate = jax.vmap(partial_interpolate, in_axes=(0, None, None), out_axes=0)
-            time_series = full_interpolate(time_series,
-                                           self.time_factor,
-                                           self.detector_factor)
-            detectors = interpolate_detectors(detectors, self.detector_factor)
-        time_series = time_series.reshape(shape[:-2] + time_series.shape[1:])
-
-        # Apply energy correction factor:
-        if overall_correction_factor is not None:
-            extend = (slice(None, None),) * overall_correction_factor.ndim + (None, None)
-            time_series /= overall_correction_factor[extend]
-        else:
-            warnings.warn("No energy correction factor applied.")
-
-        return time_series, detectors
-
-    def run(self, time_series, pa_data=None, irf=None, detectors=None, **kwargs) -> Tuple[
-        PATimeSeries, Dict, Optional[list]]:
-        """
-        Run the preprocessing step on a given time series and detectors. This allows batch processing,
-        e.g. if the data doesn't fit into memory.
-
-        Parameters
-        ----------
-        time_series
-        pa_data
-        irf
-        detectors
-        kwargs
-
-        Returns
-        -------
-        tuple of PATimeSeries, dict, list
-        """
-        from .. import PAT_MAXIMUM_BATCH_SIZE
-        # Impulse response
-        if irf is None and pa_data is not None:
-            irf = pa_data.get_impulse_response()
-
-        # Photoacoustic transducers
-        if detectors is None and pa_data is not None:
-            detectors = pa_data.get_scan_geometry()
-
-        if pa_data is not None:
-            overall_correction_factor = pa_data.get_overall_correction_factor()
-        else:
-            overall_correction_factor = None
-
-        # Sampling frequency
-        fs = time_series.attributes["fs"]
-
-        if self.filter is None:
-            self.pre_compute_filter(time_series.shape[-1], fs=fs, irf=irf)
-
-        new_detectors = detectors
-        if time_series.shape[0] * time_series.shape[1] > PAT_MAXIMUM_BATCH_SIZE != -1:
-            new_timeseries = []
-            ts_raw = time_series.raw_data
-            shape = ts_raw.shape
-            ts_raw = ts_raw.reshape((-1,) + shape[-2:])
-            overall_correction_factor = overall_correction_factor.flatten()
-            for i in range(0, ts_raw.shape[0], PAT_MAXIMUM_BATCH_SIZE):
-                new_ts, new_detectors = self._run(ts_raw[i:i + PAT_MAXIMUM_BATCH_SIZE], detectors,
-                                                  overall_correction_factor[i:i + PAT_MAXIMUM_BATCH_SIZE])
-                new_timeseries.append(np.asarray(new_ts))
-            new_ts = np.concatenate(new_timeseries, axis=0).reshape(shape[:2] + new_timeseries[0].shape[-2:])
-        else:
-            new_ts, new_detectors = self._run(time_series.raw_data, detectors,
-                                              overall_correction_factor)
-
-        # Convert timeseries into an xarray
-        attributes = dict(time_series.attributes)
-        attributes["fs"] *= self.time_factor
-        attributes[PreprocessingAttributeTags.IMPULSE_RESPONSE] = self.irf_correct
-        attributes[PreprocessingAttributeTags.PROCESSING_ALGORITHM] = self.get_algorithm_name()
-        attributes[PreprocessingAttributeTags.WINDOW_SIZE] = self.window
-        attributes[PreprocessingAttributeTags.ENVELOPE_DETECTION] = self.absolute == "abs"
-        attributes[PreprocessingAttributeTags.HILBERT_TRANSFORM] = self.hilbert
-        attributes[PreprocessingAttributeTags.DETECTOR_INTERPOLATION] = self.detector_factor
-        attributes[PreprocessingAttributeTags.TIME_INTERPOLATION] = self.time_factor
-        attributes[PreprocessingAttributeTags.LOW_PASS_FILTER] = self.lp_filter
-        attributes[PreprocessingAttributeTags.HIGH_PASS_FILTER] = self.hp_filter
-        attributes["UniversalBackProjection"] = self.ubp
-        attributes["CorrectionFactorApplied"] = overall_correction_factor is not None
-
-        coords = dict(time_series.da.coords)
-        coords["detectors"] = np.linspace(0, time_series.shape[-2] - 1,
-                                          self.detector_factor * time_series.shape[-2])
-        coords["timeseries"] = np.linspace(0, time_series.shape[-1] - 1,
-                                           self.time_factor * time_series.shape[-1] + 1)[:-1]
-
-        new_data = PATimeSeries(new_ts, time_series.da.dims, coords, attributes=attributes)
-        return new_data, {"geometry": new_detectors}, None
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
+from functools import partial
+from typing import Union, Tuple, Optional, Dict
+
+import numpy as np
+from patato.io.attribute_tags import PreprocessingAttributeTags
+from scipy.signal.windows import hann
+
+from .processing_algorithm import TimeSeriesProcessingAlgorithm
+
+try:
+    import jax.numpy as jnp
+    import jax
+except ImportError:
+    jnp = None
+    jax = None
+
+import warnings
+
+from ..core.image_structures.pa_time_data import PATimeSeries
+
+# Specify Array type
+Array = np.typing.NDArray
+
+@jax.jit
+def subtract_mean(time_series):
+    # A function to subtract the mean from a time series
+    return time_series - jnp.mean(time_series, axis=-1).reshape(time_series.shape[:-1] + (1,))
+
+
+@partial(jax.jit, static_argnums=(1,))
+def interpolate_detectors(detectors, ndet):
+    # Interpolate the detectors to the correct number of detectors
+    new_detector_i = jnp.linspace(0, detectors.shape[0] - 1, ndet * detectors.shape[0])
+    old_detector_i = jnp.arange(detectors.shape[0])
+    interp_detectors = jax.vmap(jnp.interp, in_axes=(None, None, -1), out_axes=-1)
+    new_detectors = interp_detectors(new_detector_i, old_detector_i, detectors)
+    return new_detectors
+
+
+@partial(jax.jit, static_argnums=(1, 2))
+def partial_interpolate(time_series: Array, nt: int, ndet: int) -> Array:
+    # Interpolate the time series to the correct number of time points
+    new_detector_i = jnp.linspace(0, time_series.shape[-2] - 1, ndet * time_series.shape[-2])
+    old_detector_i = jnp.arange(time_series.shape[-2])
+    new_times = jnp.linspace(0, time_series.shape[-1] - 1, nt * time_series.shape[-1] + 1)[:-1]
+    old_times = jnp.arange(time_series.shape[-1])
+
+    interp_detectors = jax.vmap(jnp.interp, in_axes=(None, None, -1), out_axes=-1)
+    new_time_series = interp_detectors(new_detector_i, old_detector_i, time_series)
+
+    interp_time = jax.vmap(jnp.interp, in_axes=(None, None, 0), out_axes=0)
+    new_time_series = interp_time(new_times, old_times, new_time_series)
+    return new_time_series
+
+
+def make_filter(n_samples: int, fs: float, irf: Array, hilbert: bool, lp_filter: Optional[float],
+                hp_filter: Optional[float], rise: float = 0.2, n_filter: int = 1024, window: Optional[str] = None):
+    """
+    Make the filter for the time series
+
+    Parameters
+    ----------
+    n_samples : int
+    fs : float
+    irf : Array
+    hilbert : bool
+    lp_filter: float or None
+    hp_filter: float or None
+    rise: float
+    n_filter : int
+    window
+
+    Returns
+    -------
+
+    """
+    output = np.ones((n_samples,), dtype=np.cdouble)
+
+    # Impulse response correction
+    if irf is not None:
+        irf_shifted = np.fft.fftshift(irf)
+        # Divide by the impulse response to deconvolve
+        output *= np.conj(np.fft.fft(irf_shifted)) / np.abs(np.fft.fft(irf_shifted)) ** 2
+        # Suppress high frequencies to avoid amplifying noise - apply a window.
+        output *= np.fft.fftshift(hann(n_samples))
+
+    # Hilbert Transform
+    frequencies = np.fft.fftfreq(n_samples)
+    if hilbert:
+        # TODO: check this
+        # Multiply positive frequencies by
+        output *= (1 + np.sign(frequencies)) / 2
+
+    frequencies = np.abs(np.fft.fftfreq(n_filter, 1 / fs))
+    filter_output = np.ones_like(frequencies, dtype=np.cdouble)
+
+    if hp_filter is not None:
+        filter_output[frequencies < hp_filter * (1 - rise)] = 0
+        in_rise = np.logical_and(frequencies > hp_filter * (1 - rise), frequencies < hp_filter)
+        filter_output[in_rise] = (frequencies[in_rise] - hp_filter * (1 - rise)) / (hp_filter * rise)
+
+    if lp_filter is not None:
+        filter_output[frequencies > lp_filter * (1 + rise)] = 0
+        in_rise = np.logical_and(frequencies < lp_filter * (1 + rise), frequencies > lp_filter)
+        filter_output[in_rise] = 1 - (frequencies[in_rise] - lp_filter) / (lp_filter * rise)
+
+    time_series = np.fft.ifft(filter_output)
+
+    if window == "hann":
+        time_series *= np.fft.fftshift(hann(n_filter))
+
+    filter_time = np.zeros_like(output)
+    filter_time[:n_filter // 2] = time_series[:n_filter // 2]
+    filter_time[-n_filter // 2:] = time_series[-n_filter // 2:]
+
+    filter_output = np.fft.fft(filter_time)
+    output *= filter_output
+    return output
+
+
+class PreProcessor(TimeSeriesProcessingAlgorithm):
+    """ Preprocesses MSOT time series data. Uses JAX in the background.
+    """
+
+    @staticmethod
+    def get_algorithm_name() -> Union[str, None]:
+        """
+        Get the name of the algorithm.
+
+        Returns
+        -------
+        str or None
+        """
+        return "Standard Preprocessor"
+
+    @staticmethod
+    def get_hdf5_group_name() -> Union[str, None]:
+        """
+        Return the name of the group in the HDF5 file
+
+        Returns
+        -------
+        str or None
+
+        """
+        # Return the name of the group in the HDF5 file
+        return None
+
+    def __init__(self, time_factor: int = 3, detector_factor: int = 2,
+                 irf: bool = True, hilbert: bool = True, lp_filter: Optional[float] = None,
+                 hp_filter: Optional[float] = None, filter_window_size: int = 512,
+                 window: str = "hann", absolute: Optional[str] = None, universal_backprojection=False):
+        # Initialise the preprocessor
+        super().__init__()
+        self.time_factor = time_factor
+        self.detector_factor = detector_factor
+        self.hilbert = hilbert
+        absolute = "imag" if absolute is None and hilbert else absolute
+        self.ubp = universal_backprojection
+        self.irf_correct = irf
+        self.lp_filter = lp_filter
+        self.hp_filter = hp_filter
+        self.n_filter = filter_window_size
+        self.window = window
+        self.absolute = absolute
+        self.filter = None
+
+    def pre_compute_filter(self, n_samples: int, fs: float, irf: Array = None):
+        """
+        Precompute the filter to be applied.
+
+        Parameters
+        ----------
+        n_samples : int
+        fs : float
+        irf : Array
+        """
+        self.filter = jnp.array(make_filter(n_samples, fs, irf, self.hilbert, self.lp_filter, self.hp_filter))
+
+    def _run(self, time_series: Array, detectors: Array, overall_correction_factor, **kwargs):
+        """
+        Run the preprocessing step on a given time series and detectors. This allows batch processing,
+         e.g. if the data doesn't fit into memory.
+
+        Parameters
+        ----------
+        time_series : Array
+        detectors   : Array
+        overall_correction_factor: Array
+        kwargs    : dict
+
+        Returns
+        -------
+        tuple of Array, Array
+        """
+        shape = time_series.shape
+        time_series = jnp.array(time_series.reshape((-1,) + shape[-2:]))
+        detectors = jnp.array(detectors)
+
+        # Subtract mean
+        time_series = subtract_mean(time_series)
+
+        # Apply filters
+        time_series_ft = jnp.fft.fft(time_series)
+
+        time_series_ft = time_series_ft * self.filter.reshape((1,) * (time_series.ndim - 1) + (-1,))
+        if self.absolute == "imag":
+            op = jnp.imag
+        else:
+            op = jnp.real
+        time_series = op(jnp.fft.ifft(time_series_ft))
+
+        # Allow for universal backprojection here.
+        if self.ubp:
+            time_series -= jnp.gradient(time_series, axis=-1)*jnp.arange(time_series.shape[-1])
+
+        # Interpolate in time domain and detector domain
+        if not (self.detector_factor == 1 and self.time_factor == 1):
+            full_interpolate = jax.vmap(partial_interpolate, in_axes=(0, None, None), out_axes=0)
+            time_series = full_interpolate(time_series,
+                                           self.time_factor,
+                                           self.detector_factor)
+            detectors = interpolate_detectors(detectors, self.detector_factor)
+        time_series = time_series.reshape(shape[:-2] + time_series.shape[1:])
+
+        # Apply energy correction factor:
+        if overall_correction_factor is not None:
+            extend = (slice(None, None),) * overall_correction_factor.ndim + (None, None)
+            time_series /= overall_correction_factor[extend]
+        else:
+            warnings.warn("No energy correction factor applied.")
+
+        return time_series, detectors
+
+    def run(self, time_series, pa_data=None, irf=None, detectors=None, **kwargs) -> Tuple[
+        PATimeSeries, Dict, Optional[list]]:
+        """
+        Run the preprocessing step on a given time series and detectors. This allows batch processing,
+        e.g. if the data doesn't fit into memory.
+
+        Parameters
+        ----------
+        time_series
+        pa_data
+        irf
+        detectors
+        kwargs
+
+        Returns
+        -------
+        tuple of PATimeSeries, dict, list
+        """
+        from .. import PAT_MAXIMUM_BATCH_SIZE
+        # Impulse response
+        if irf is None and pa_data is not None:
+            irf = pa_data.get_impulse_response()
+
+        # Photoacoustic transducers
+        if detectors is None and pa_data is not None:
+            detectors = pa_data.get_scan_geometry()
+
+        if pa_data is not None:
+            overall_correction_factor = pa_data.get_overall_correction_factor()
+        else:
+            overall_correction_factor = None
+
+        # Sampling frequency
+        fs = time_series.attributes["fs"]
+
+        if self.filter is None:
+            self.pre_compute_filter(time_series.shape[-1], fs=fs, irf=irf)
+
+        new_detectors = detectors
+        if time_series.shape[0] * time_series.shape[1] > PAT_MAXIMUM_BATCH_SIZE != -1:
+            new_timeseries = []
+            ts_raw = time_series.raw_data
+            shape = ts_raw.shape
+            ts_raw = ts_raw.reshape((-1,) + shape[-2:])
+            overall_correction_factor = overall_correction_factor.flatten()
+            for i in range(0, ts_raw.shape[0], PAT_MAXIMUM_BATCH_SIZE):
+                new_ts, new_detectors = self._run(ts_raw[i:i + PAT_MAXIMUM_BATCH_SIZE], detectors,
+                                                  overall_correction_factor[i:i + PAT_MAXIMUM_BATCH_SIZE])
+                new_timeseries.append(np.asarray(new_ts))
+            new_ts = np.concatenate(new_timeseries, axis=0).reshape(shape[:2] + new_timeseries[0].shape[-2:])
+        else:
+            new_ts, new_detectors = self._run(time_series.raw_data, detectors,
+                                              overall_correction_factor)
+
+        # Convert timeseries into an xarray
+        attributes = dict(time_series.attributes)
+        attributes["fs"] *= self.time_factor
+        attributes[PreprocessingAttributeTags.IMPULSE_RESPONSE] = self.irf_correct
+        attributes[PreprocessingAttributeTags.PROCESSING_ALGORITHM] = self.get_algorithm_name()
+        attributes[PreprocessingAttributeTags.WINDOW_SIZE] = self.window
+        attributes[PreprocessingAttributeTags.ENVELOPE_DETECTION] = self.absolute == "abs"
+        attributes[PreprocessingAttributeTags.HILBERT_TRANSFORM] = self.hilbert
+        attributes[PreprocessingAttributeTags.DETECTOR_INTERPOLATION] = self.detector_factor
+        attributes[PreprocessingAttributeTags.TIME_INTERPOLATION] = self.time_factor
+        attributes[PreprocessingAttributeTags.LOW_PASS_FILTER] = self.lp_filter
+        attributes[PreprocessingAttributeTags.HIGH_PASS_FILTER] = self.hp_filter
+        attributes["UniversalBackProjection"] = self.ubp
+        attributes["CorrectionFactorApplied"] = overall_correction_factor is not None
+
+        coords = dict(time_series.da.coords)
+        coords["detectors"] = np.linspace(0, time_series.shape[-2] - 1,
+                                          self.detector_factor * time_series.shape[-2])
+        coords["timeseries"] = np.linspace(0, time_series.shape[-1] - 1,
+                                           self.time_factor * time_series.shape[-1] + 1)[:-1]
+
+        new_data = PATimeSeries(new_ts, time_series.da.dims, coords, attributes=attributes)
+        return new_data, {"geometry": new_detectors}, None
```

## patato/recon/backprojection_implementation/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
```

## patato/recon/backprojection_implementation/jax_implementation.py

 * *Ordering differences only*

```diff
@@ -1,34 +1,34 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
-try:
-    import jax
-    import jax.numpy as jnp
-except ImportError:
-    jax = None
-    jnp = None
-from functools import partial
-
-
-@partial(jax.jit, static_argnums=(2, 3, 4, 5, 6, 7, 8))
-def recon_partial(t, geometry, dl, nx, ny, nz, dx, dy, dz):
-    """
-    Do delay and sum for a single detector.
-    """
-    z, y, x = jnp.ogrid[0:nz, 0:ny, 0:nx]
-    x = (x - (nx - 1) / 2) * dx
-    y = (y - (ny - 1) / 2) * dy
-    z = (z - (nz - 1) / 2) * dz
-    offsets = (jnp.sqrt((geometry[0] - x) ** 2 +
-                        (geometry[1] - y) ** 2 +
-                        (geometry[2] - z) ** 2) / dl).astype(jnp.int32)
-    return t[offsets]
-
-
-@partial(jax.jit, static_argnums=(2, 3, 4, 5, 6, 7, 8))
-def full_recon(t, geometry, dl, nx, ny, nz, dx, dy, dz):
-    """
-    Do delay and sum for all detectors.
-    """
-    all_times = jax.vmap(recon_partial, in_axes=(0, 0,) + (None, ) * 7, out_axes=0)
-    return jnp.sum(all_times(t, geometry, dl, nx, ny, nz, dx, dy, dz), axis=0)
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
+try:
+    import jax
+    import jax.numpy as jnp
+except ImportError:
+    jax = None
+    jnp = None
+from functools import partial
+
+
+@partial(jax.jit, static_argnums=(2, 3, 4, 5, 6, 7, 8))
+def recon_partial(t, geometry, dl, nx, ny, nz, dx, dy, dz):
+    """
+    Do delay and sum for a single detector.
+    """
+    z, y, x = jnp.ogrid[0:nz, 0:ny, 0:nx]
+    x = (x - (nx - 1) / 2) * dx
+    y = (y - (ny - 1) / 2) * dy
+    z = (z - (nz - 1) / 2) * dz
+    offsets = (jnp.sqrt((geometry[0] - x) ** 2 +
+                        (geometry[1] - y) ** 2 +
+                        (geometry[2] - z) ** 2) / dl).astype(jnp.int32)
+    return t[offsets]
+
+
+@partial(jax.jit, static_argnums=(2, 3, 4, 5, 6, 7, 8))
+def full_recon(t, geometry, dl, nx, ny, nz, dx, dy, dz):
+    """
+    Do delay and sum for all detectors.
+    """
+    all_times = jax.vmap(recon_partial, in_axes=(0, 0,) + (None, ) * 7, out_axes=0)
+    return jnp.sum(all_times(t, geometry, dl, nx, ny, nz, dx, dy, dz), axis=0)
```

## patato/recon/model_based/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
```

## patato/recon/numpy_backprojection/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
```

## patato/recon/numpy_backprojection/recon.py

 * *Ordering differences only*

```diff
@@ -1,84 +1,84 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
-from typing import Sequence
-
-import numpy as np
-from .. import ReconstructionAlgorithm
-
-# Add a loading bar
-from tqdm.auto import tqdm
-
-
-class SlowBackprojection(ReconstructionAlgorithm):
-    """
-    Slow example backprojection.
-    """
-
-    def reconstruct(self, time_series: np.ndarray,
-                    fs: float,
-                    geometry: np.ndarray, n_pixels: Sequence[int],
-                    field_of_view: Sequence[float],
-                    speed_of_sound: float,
-                    **kwargs) -> np.ndarray:
-        """
-
-        Parameters
-        ----------
-        time_series: array_like
-            Photoacoustic time series data in a numpy array. Shape: (..., n_detectors, n_time_samples)
-        fs: float
-            Time series sampling frequency (Hz).
-        geometry: array_like
-            The detector geometry. Shape: (n_detectors, 3)
-        n_pixels: tuple of int
-            Tuple of length 3, (nx, ny, nz)
-        field_of_view: tuple of float
-            Tuple of length 3, (lx, ly, lz) - the size of the reconstruction volume.
-        speed_of_sound: float
-            Speed of sound (m/s).
-        kwargs
-            Extra parameters (optional), useful for advanced algorithms (e.g. multi speed of sound etc.).
-
-        Returns
-        -------
-        array_like
-            The reconstructed image.
-
-        """
-        print("Running batch of delay and sum reconstruction code.")
-
-        # Get useful parameters:
-        dl = speed_of_sound / fs
-
-        # Reshape frames so that we can loop through to reconstruct
-        original_shape = time_series.shape[:-2]
-        frames = int(np.product(original_shape))
-        signal = time_series.reshape((frames,) + time_series.shape[-2:])
-
-        xs, ys, zs = [
-            np.linspace(-field_of_view[i] / 2, field_of_view[i] / 2, n_pixels[i]) if n_pixels[i] != 1 else np.array(
-                [0.]) for i in range(3)]
-        Z, Y, X = np.meshgrid(zs, ys, xs, indexing='ij')
-
-        # Note that the reconstructions are stored in memory in the order z, y, x (i.e. the x axis is the fastest
-        # changing in memory)
-        output = np.zeros((frames,) + tuple(n_pixels)[::-1])
-
-        for n_frame in tqdm(range(frames), desc="Looping through frames", position=0):
-            for n_detector in tqdm(range(signal.shape[-2]), desc="Looping through detectors", position=1, leave=False):
-                detx, dety, detz = geometry[n_detector]
-                d = (np.sqrt((detx - X) ** 2 + (dety - Y) ** 2 + (detz - Z) ** 2) / dl).astype(np.int32)
-                output[n_frame] += signal[n_frame, n_detector, d]
-        return output.reshape(original_shape + tuple(n_pixels)[::-1])
-
-    @staticmethod
-    def get_algorithm_name() -> str:
-        """
-
-        Returns
-        -------
-        str
-            Algorithm name.
-        """
-        return "Slow Backprojection"
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
+from typing import Sequence
+
+import numpy as np
+from .. import ReconstructionAlgorithm
+
+# Add a loading bar
+from tqdm.auto import tqdm
+
+
+class SlowBackprojection(ReconstructionAlgorithm):
+    """
+    Slow example backprojection.
+    """
+
+    def reconstruct(self, time_series: np.ndarray,
+                    fs: float,
+                    geometry: np.ndarray, n_pixels: Sequence[int],
+                    field_of_view: Sequence[float],
+                    speed_of_sound: float,
+                    **kwargs) -> np.ndarray:
+        """
+
+        Parameters
+        ----------
+        time_series: array_like
+            Photoacoustic time series data in a numpy array. Shape: (..., n_detectors, n_time_samples)
+        fs: float
+            Time series sampling frequency (Hz).
+        geometry: array_like
+            The detector geometry. Shape: (n_detectors, 3)
+        n_pixels: tuple of int
+            Tuple of length 3, (nx, ny, nz)
+        field_of_view: tuple of float
+            Tuple of length 3, (lx, ly, lz) - the size of the reconstruction volume.
+        speed_of_sound: float
+            Speed of sound (m/s).
+        kwargs
+            Extra parameters (optional), useful for advanced algorithms (e.g. multi speed of sound etc.).
+
+        Returns
+        -------
+        array_like
+            The reconstructed image.
+
+        """
+        print("Running batch of delay and sum reconstruction code.")
+
+        # Get useful parameters:
+        dl = speed_of_sound / fs
+
+        # Reshape frames so that we can loop through to reconstruct
+        original_shape = time_series.shape[:-2]
+        frames = int(np.product(original_shape))
+        signal = time_series.reshape((frames,) + time_series.shape[-2:])
+
+        xs, ys, zs = [
+            np.linspace(-field_of_view[i] / 2, field_of_view[i] / 2, n_pixels[i]) if n_pixels[i] != 1 else np.array(
+                [0.]) for i in range(3)]
+        Z, Y, X = np.meshgrid(zs, ys, xs, indexing='ij')
+
+        # Note that the reconstructions are stored in memory in the order z, y, x (i.e. the x axis is the fastest
+        # changing in memory)
+        output = np.zeros((frames,) + tuple(n_pixels)[::-1])
+
+        for n_frame in tqdm(range(frames), desc="Looping through frames", position=0):
+            for n_detector in tqdm(range(signal.shape[-2]), desc="Looping through detectors", position=1, leave=False):
+                detx, dety, detz = geometry[n_detector]
+                d = (np.sqrt((detx - X) ** 2 + (dety - Y) ** 2 + (detz - Z) ** 2) / dl).astype(np.int32)
+                output[n_frame] += signal[n_frame, n_detector, d]
+        return output.reshape(original_shape + tuple(n_pixels)[::-1])
+
+    @staticmethod
+    def get_algorithm_name() -> str:
+        """
+
+        Returns
+        -------
+        str
+            Algorithm name.
+        """
+        return "Slow Backprojection"
```

## patato/unmixing/__init__.py

 * *Ordering differences only*

```diff
@@ -1,22 +1,22 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
-"""
-Unmixing module
-======================
-
-This module provides functions for commonly-used spectral analysis procedures in photoacoustic imaging.
-Additionally, the module provides commonly-used spectra for chromophores in biological tissue.
-"""
-
-
-def get_default_unmixing_preset():
-    """
-
-    Returns
-    -------
-
-    """
-    import os
-    root_folder = os.path.join(os.path.dirname(os.path.realpath(__file__)), "../unmixing/unmix_presets")
-    return os.path.join(root_folder, "haemoglobin.json")
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
+"""
+Unmixing module
+======================
+
+This module provides functions for commonly-used spectral analysis procedures in photoacoustic imaging.
+Additionally, the module provides commonly-used spectra for chromophores in biological tissue.
+"""
+
+
+def get_default_unmixing_preset():
+    """
+
+    Returns
+    -------
+
+    """
+    import os
+    root_folder = os.path.join(os.path.dirname(os.path.realpath(__file__)), "../unmixing/unmix_presets")
+    return os.path.join(root_folder, "haemoglobin.json")
```

## patato/utils/rois/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
```

## patato/utils/tests/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-#  Copyright (c) Thomas Else 2023.
-#  License: MIT
-
+#  Copyright (c) Thomas Else 2023.
+#  License: MIT
+
```

## Comparing `patato/utils/run_pipeline.py` & `patato/utils/pipeline.py`

 * *Files identical despite different names*

## Comparing `patato-0.5.1.dist-info/METADATA` & `patato-0.5.2.dist-info/METADATA`

 * *Files 10% similar despite different names*

```diff
@@ -1,93 +1,92 @@
-Metadata-Version: 2.1
-Name: patato
-Version: 0.5.1
-Summary: A Python Toolkit for the analysis of photoacoustic tomography data.
-Author: Janek Grohl
-Author-email: Thomas Else <thomas.else@cruk.cam.ac.uk>
-License: MIT License
-        
-        Copyright (c) 2023 Thomas Else
-        
-        Permission is hereby granted, free of charge, to any person obtaining a copy
-        of this software and associated documentation files (the "Software"), to deal
-        in the Software without restriction, including without limitation the rights
-        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-        copies of the Software, and to permit persons to whom the Software is
-        furnished to do so, subject to the following conditions:
-        
-        The above copyright notice and this permission notice shall be included in all
-        copies or substantial portions of the Software.
-        
-        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-        SOFTWARE.
-Project-URL: Homepage, https://github.com/bohndieklab/patato
-Project-URL: Bug Tracker, https://github.com/bohndieklab/patato/issues
-Project-URL: Documentation, https://patato.readthedocs.io
-Keywords: photoacoustics,jax,tomography,reconstruction,spectral unmixing,dynamic contrast enhanced,backprojection,model based
-Classifier: Intended Audience :: Education
-Classifier: Intended Audience :: Science/Research
-Classifier: Programming Language :: Python :: 3
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Operating System :: OS Independent
-Requires-Python: <3.11,>=3.8
-Description-Content-Type: text/markdown
-License-File: LICENSE.MD
-Requires-Dist: requests
-Requires-Dist: cython
-Requires-Dist: shapely
-Requires-Dist: pylops
-Requires-Dist: h5py
-Requires-Dist: typing-extensions
-Requires-Dist: seaborn
-Requires-Dist: pandas
-Requires-Dist: scikit-learn
-Requires-Dist: xarray
-Requires-Dist: numpy
-Requires-Dist: scipy
-Requires-Dist: tabulate
-Requires-Dist: matplotlib
-Requires-Dist: matplotlib-scalebar
-Requires-Dist: dask
-Requires-Dist: pybind11
-Requires-Dist: wget
-Requires-Dist: gdown
-Requires-Dist: jax[cpu] ; platform_system != "Windows"
-
-[![Documentation Status](https://readthedocs.org/projects/patato/badge/?version=latest)](https://patato.readthedocs.io/en/latest/?badge=latest)
-[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://github.com/tomelse/patato/blob/main/LICENSE.MD)
-[![PyPI version](https://badge.fury.io/py/patato.svg)](https://badge.fury.io/py/patato)
-[![Build](https://github.com/tomelse/patato/actions/workflows/build_wheels.yml/badge.svg)](https://github.com/tomelse/patato/actions/workflows/build_wheels.yml)
-
-![Logo](docs/logos/PATATO%20Logo_1_Combination.png "Logo")
-
-# PATATO: PhotoAcoustic Tomography Analysis TOolkit
-
-[Documentation](https://patato.readthedocs.io/en/develop/)
-
-PATATO is an Open-Source project to enable the analysis of photoacoustic (PA) imaging data in a transparent, reproducible and extendable way. We provide efficient, GPU-optimised implementations of common PA algorithms written around standard Python libraries, including filtered backprojection, model-based reconstruction and spectral unmixing.
-
-The tool supports many file formats, such as the International Photoacoustic Standardisation Consortium (IPASC) data format, and it can be extended to support custom data formats. We hope that this toolkit can enable faster and wider dissemination of analysis techniques for PA imaging and provide a useful tool to the community.
-
-* Please report any bugs or issues you find to our GitHub repository
-* Please do get involved! Contact Thomas Else (thomas.else@cruk.cam.ac.uk).
-
-## Getting Started
-In order to use PATATO, you must have a Python environment set up on your computer. We recommend using Anaconda (http://anaconda.com) to run Python, particularly if you are using Windows. You may wish to setup a separate Anaconda environment to install PATATO to minimise conflicts between dependency versions.
-
-```shell
-pip install --upgrade pip setuptools
-pip install patato
-```
-
-To setup support for image reconstruction on Windows, or for GPU support, please follow the installation guide in the documentation.
-
-## Documentation, examples and contributing
-Documentation for PATATO can be found at https://patato.readthedocs.io/en/latest/?badge=latest.
-
-Copyright (c) Thomas Else 2022-23.
-Distributed under a MIT License.
+Metadata-Version: 2.1
+Name: patato
+Version: 0.5.2
+Summary: A Python Toolkit for the analysis of photoacoustic tomography data.
+Author-email: Thomas Else <thomas.else@cruk.cam.ac.uk>
+License: MIT License
+        
+        Copyright (c) 2023 Thomas Else
+        
+        Permission is hereby granted, free of charge, to any person obtaining a copy
+        of this software and associated documentation files (the "Software"), to deal
+        in the Software without restriction, including without limitation the rights
+        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+        copies of the Software, and to permit persons to whom the Software is
+        furnished to do so, subject to the following conditions:
+        
+        The above copyright notice and this permission notice shall be included in all
+        copies or substantial portions of the Software.
+        
+        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+        SOFTWARE.
+Project-URL: Homepage, https://github.com/bohndieklab/patato
+Project-URL: Bug Tracker, https://github.com/bohndieklab/patato/issues
+Project-URL: Documentation, https://patato.readthedocs.io
+Keywords: photoacoustics,jax,tomography,reconstruction,spectral unmixing,dynamic contrast enhanced,backprojection,model based
+Classifier: Intended Audience :: Education
+Classifier: Intended Audience :: Science/Research
+Classifier: Programming Language :: Python :: 3
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Operating System :: OS Independent
+Requires-Python: <3.11,>=3.8
+Description-Content-Type: text/markdown
+License-File: LICENSE.MD
+Requires-Dist: requests
+Requires-Dist: cython
+Requires-Dist: shapely
+Requires-Dist: pylops
+Requires-Dist: h5py
+Requires-Dist: typing-extensions
+Requires-Dist: seaborn
+Requires-Dist: pandas
+Requires-Dist: scikit-learn
+Requires-Dist: xarray
+Requires-Dist: numpy
+Requires-Dist: scipy
+Requires-Dist: tabulate
+Requires-Dist: matplotlib
+Requires-Dist: matplotlib-scalebar
+Requires-Dist: dask
+Requires-Dist: pybind11
+Requires-Dist: wget
+Requires-Dist: gdown
+Requires-Dist: jax[cpu] ; platform_system != "Windows"
+
+[![Documentation Status](https://readthedocs.org/projects/patato/badge/?version=latest)](https://patato.readthedocs.io/en/latest/?badge=latest)
+[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://github.com/tomelse/patato/blob/main/LICENSE.MD)
+[![PyPI version](https://badge.fury.io/py/patato.svg)](https://badge.fury.io/py/patato)
+[![Build](https://github.com/tomelse/patato/actions/workflows/build_wheels.yml/badge.svg)](https://github.com/tomelse/patato/actions/workflows/build_wheels.yml)
+
+![Logo](docs/logos/PATATO%20Logo_1_Combination.png "Logo")
+
+# PATATO: PhotoAcoustic Tomography Analysis TOolkit
+
+[Documentation](https://patato.readthedocs.io/en/develop/)
+
+PATATO is an Open-Source project to enable the analysis of photoacoustic (PA) imaging data in a transparent, reproducible and extendable way. We provide efficient, GPU-optimised implementations of common PA algorithms written around standard Python libraries, including filtered backprojection, model-based reconstruction and spectral unmixing.
+
+The tool supports many file formats, such as the International Photoacoustic Standardisation Consortium (IPASC) data format, and it can be extended to support custom data formats. We hope that this toolkit can enable faster and wider dissemination of analysis techniques for PA imaging and provide a useful tool to the community.
+
+* Please report any bugs or issues you find to our GitHub repository
+* Please do get involved! Contact Thomas Else (thomas.else@cruk.cam.ac.uk).
+
+## Getting Started
+In order to use PATATO, you must have a Python environment set up on your computer. We recommend using Anaconda (http://anaconda.com) to run Python, particularly if you are using Windows. You may wish to setup a separate Anaconda environment to install PATATO to minimise conflicts between dependency versions.
+
+```shell
+pip install --upgrade pip setuptools
+pip install patato
+```
+
+To setup support for image reconstruction on Windows, or for GPU support, please follow the installation guide in the documentation.
+
+## Documentation, examples and contributing
+Documentation for PATATO can be found at https://patato.readthedocs.io/en/latest/?badge=latest.
+
+Copyright (c) Thomas Else 2022-23.
+Distributed under a MIT License.
```

## Comparing `patato-0.5.1.dist-info/entry_points.txt` & `patato-0.5.2.dist-info/entry_points.txt`

 * *Files identical despite different names*

## Comparing `patato-0.5.1.dist-info/RECORD` & `patato-0.5.2.dist-info/RECORD`

 * *Files 26% similar despite different names*

```diff
@@ -1,96 +1,128 @@
-patato/__init__.py,sha256=8paF8-iMpw-wH0bpgbHTozpCF_FtVkEnrxTwsPji2XQ,2183
-patato/convenience_scripts/__init__.py,sha256=28SLfpuZgBAWcyvacXx7LaExIATXvkjqt1sFNLE-uW8,216
-patato/convenience_scripts/convert_binary_to_hdf5.py,sha256=TDvi8mGlYEmpXN8d5VhxiOZ0ih36A7DuBOGpvilNLIE,1247
-patato/convenience_scripts/convert_simpa.py,sha256=x3TdI19zOASqDfc4JHp1xdj4bHrrtDp9VZ1QDGluXpY,1053
-patato/convenience_scripts/copy_rois.py,sha256=8MtfqK2oHPA_o6eI0BmfXUcY-FX8jpho0KO8A_tONDI,6648
-patato/convenience_scripts/draw_roi.py,sha256=o2cQQnplYhqaxWXnmzWy1PtD9m-AVCs0J3ZirBrpZ84,20250
-patato/convenience_scripts/generate_core.py,sha256=mvLqkKPAwPiGmgwjEmVn-O7h5212dFe1nw7iXuVswpE,2153
-patato/convenience_scripts/import_clinical_data.py,sha256=zBGk3j7MNXC6NigQmLVDC1H7cH1vKzscGRvOrIpiPvg,1294
-patato/convenience_scripts/import_ithera_recons.py,sha256=ccA4e9Bs6nEYjRCfRAWZsBwC38--ElQvXCTaXRYgt_0,1666
-patato/convenience_scripts/print_speeds.py,sha256=pRpWGRYpCZFxBPdZIYpJ65nsHpymVgTw-TtvENq_tZw,1541
-patato/convenience_scripts/process_msot.py,sha256=w1nyri-WV-tq4rqGu40WdrqF75IJsBD2tlJP-v0Mvrs,4611
-patato/convenience_scripts/rename_scan.py,sha256=-a5Xo9h5j2HahnlwYYZTQO-YUIyZaczrjnRpBvyy9i8,962
-patato/convenience_scripts/scan_status.py,sha256=M6UXlLUwI88tawkZJusactDN_dkp_kWpAn6Sbsti1yw,1895
-patato/convenience_scripts/split_rois.py,sha256=jWhd7hp_V7o4174PEl2qPE8lX-unZQBD0Ztn6WnbgDI,1793
-patato/convenience_scripts/tune_speed_of_sound.py,sha256=3FQQelbVxH1LX8f5H-jz1DN2ztbR19PqtgDEvb4Njng,8438
-patato/convenience_scripts/unmix.py,sha256=rtpkoWTYS4fEpsdrxc1EfduA8fbHF7c24VZGxp__A5Q,2663
-patato/convenience_scripts/view.py,sha256=ziE4iYdzN0FDJH0jLQcsyqDm1hFvK_1sgIaNy_JvWlw,4255
-patato/convenience_scripts/data_analysis/__init__.py,sha256=4nvs_RQQj5CLcNJyJNTg9MbQaMIc9hIA21CS92pdC3w,55
-patato/convenience_scripts/data_analysis/analyse_dce.py,sha256=yHHABzoXY6eDPeehP4R2LCinnt21ijip5IlWPDuGXMY,2617
-patato/convenience_scripts/data_analysis/analyse_gas_challenge.py,sha256=GSazs0ncV7ZZGFRKWlyYD2GlsAUdDMe4Fp2xWDh9Iek,2745
-patato/core/__init__.py,sha256=OjPfgYBM0wSaYbXZWfZfTG8_P4K4vcPyh0vzEge3D5o,251
-patato/core/image_structures/__init__.py,sha256=4nvs_RQQj5CLcNJyJNTg9MbQaMIc9hIA21CS92pdC3w,55
-patato/core/image_structures/image_sequence.py,sha256=HM0YhmtfJc9DaJ0yRgjr0KLTsD6-ykhsthMWAktsGtg,12664
-patato/core/image_structures/image_structure_types.py,sha256=0uNv4YbP_cSNE-h38o-Y51EGllhbl2TmysE_QU0eaT8,856
-patato/core/image_structures/pa_raw_data.py,sha256=sbaYLZAWdEncYjdPQyojglJVEiM2Sai4Kxb7gTvXIUk,1430
-patato/core/image_structures/pa_time_data.py,sha256=eyY5Asx5W7B-F7AcWJIkpw4EIetJhXk5HQCvDqqmGSQ,1331
-patato/core/image_structures/reconstruction_image.py,sha256=aaKnaFadxZD-2oJxwWfDRYO_V0PNSRHbUZp6frcOulY,851
-patato/core/image_structures/single_image.py,sha256=aPf3ca7-nX-_pInyNCamFyA0elmw0TZZ77He40cD8CQ,982
-patato/core/image_structures/single_parameter_data.py,sha256=P417UBbYBD18RRJPF8TpMIChyfG6ZlCLQ_YWZdd8UAI,1121
-patato/core/image_structures/unmixed_image.py,sha256=5MQ6TRWM7G7hUaamo6IAlETIFXpC39UoeEOLxhv1zcw,930
-patato/data/__init__.py,sha256=2OJ6666fl6b25nIOy2kBWPNZmc_NBny8ZkMc6mx4a2c,701
-patato/data/get_example_datasets.py,sha256=Rys0Qt5sSyCHnFkEYDlImXH48fXS73ogY4Ls_foz1Fg,3676
-patato/data/simulated_datasets.py,sha256=evdordT0wTkeka8iRWN9YIH9Hs2MZJ45ub6qWM7AC1Y,2132
-patato/experimental/__init__.py,sha256=YOgAMTD0NMeFy3EMmlNMHSUljbls27_Opx1OGeDYt4g,53
-patato/experimental/simulation/__init__.py,sha256=UX_aj31lmD-S4RYpqitHkZBgdttftFVhaBmGsOCKMjg,57
-patato/io/__init__.py,sha256=fJcLCcifgHYhuiPEqmhB3FS86HC1Y4B8vLalXS_L6t4,194
-patato/io/attribute_tags.py,sha256=pIIavrBBhx3Choj6sESj98j5DCnyWNPUANRjyV2DIeA,2877
-patato/io/hdf5_converter.py,sha256=EjLK-nqhCoITNjLm3BL4_PmYMn14oL6uIIyhhP0p-_8,3934
-patato/io/msot_data.py,sha256=yqPnLA3SKSIVwwHMtR_gZWKZaU-VM_Yt6PVrKRcFyA8,23221
-patato/io/hdf/__init__.py,sha256=4nvs_RQQj5CLcNJyJNTg9MbQaMIc9hIA21CS92pdC3w,55
-patato/io/hdf/fileimporter.py,sha256=gHGWJQXgt2maSVcpC_cY4pBgOvSJDNJrVEx_7QxpKlE,12302
-patato/io/hdf/hdf5_interface.py,sha256=galHh-TA8lYhUTMMDFUlQnt0murWEVRnrEFeHJAVtzc,17073
-patato/io/ipasc/__init__.py,sha256=zJ6OdBZCqbvZpX8JUdirwTG2XGJ3iN4BW6JmqdSBetk,518
-patato/io/ipasc/ipasc_export.py,sha256=GV86nWFTB1oeiBuLTAqpZoIgrrvmGOBXMp50vFawabs,2472
-patato/io/ipasc/read_ipasc.py,sha256=7srPE2r24hsFNbbfLlTKpoxB69IhUETIuOzk1y1VhH8,2840
-patato/io/ithera/__init__.py,sha256=VlJY4mKMJCbwVoySVT-0knMVSHfifFxMFkMPhEifmY0,245
-patato/io/ithera/read_ithera.py,sha256=gbp2XZPWBeRkB2M35r_JDJmCRI48Qf-jQcRlhQR6Pq8,13847
-patato/io/json/__init__.py,sha256=4nvs_RQQj5CLcNJyJNTg9MbQaMIc9hIA21CS92pdC3w,55
-patato/io/json/json_reading.py,sha256=21MrtFciotGmXOdjEoSNc0BTG05IUTFKUsNiqS7py4c,6868
-patato/io/simpa/__init__.py,sha256=4nvs_RQQj5CLcNJyJNTg9MbQaMIc9hIA21CS92pdC3w,55
-patato/io/simpa/read_simpa.py,sha256=xebVaC4u36rwDVEkNwstGEUFeXn1Q5qMDcN2XT0i9A8,5192
-patato/processing/__init__.py,sha256=bMJa3vD7qHHQUiPVHojIes7PuJF5gdXHiOxA3hWNvps,339
-patato/processing/gpu_preprocessing_algorithm.py,sha256=H32U1ia7L5Ul9DA2efunsT-K2NhUpRwlA4G4mxzT2UI,11603
-patato/processing/jax_preprocessing_algorithm.py,sha256=gl80RkLcuQRPSIksI0FbUk3lY68bb4O4oVs3pGCIz58,12332
-patato/processing/preprocessing_algorithm.py,sha256=nvgjnuJN_UaMBEcISh6-x5e59ktvYwOvenDLJDHZScA,10264
-patato/processing/preprocessing_types.py,sha256=bSmShY5fncrQpZf_XVTJBpxS81U9qUapIEeXnxqo2Lw,685
-patato/processing/processing_algorithm.py,sha256=Z8Xq9rjhuOfK6CuLoA4OFxi6FU6_Q2vcxHWG-4TdDTk,2259
-patato/recon/__init__.py,sha256=0PJGUjLl14aHkABOXI7dGYEiPRTRPoSJOasfRPBnZlE,1897
-patato/recon/backprojection_opencl.py,sha256=i7rLxfCM_DyI0oVGrnlxsFVpssD_m1Abd-VhdcqzO_E,7337
-patato/recon/backprojection_reference.py,sha256=4muSfD6vRDHQXnPF_ut9mluDrg5gyUz6MzN9mo9XPhU,2137
-patato/recon/reconstruction_algorithm.py,sha256=d1esso_QJUSbJ57t9H7Shcq8qqwo77BFV7v84ACuXJU,5070
-patato/recon/backprojection_implementation/__init__.py,sha256=4nvs_RQQj5CLcNJyJNTg9MbQaMIc9hIA21CS92pdC3w,55
-patato/recon/backprojection_implementation/jax_implementation.py,sha256=EpWS4b7EOmS784xKAo_VeAfuLP2GomJ_wq2ZIwEuYWw,1056
-patato/recon/model_based/__init__.py,sha256=4nvs_RQQj5CLcNJyJNTg9MbQaMIc9hIA21CS92pdC3w,55
-patato/recon/model_based/cuda_implementation.py,sha256=JKFVh4zHttgaanrHbBIRj45aGIVC-k1uOmBJJZZ8l24,3874
-patato/recon/model_based/cuda_implementation_refraction.py,sha256=iNqsujWa3iniIIy7gfFLWfmVrheSqvVP4l85TBI_KgQ,2806
-patato/recon/model_based/generate_model.cpp,sha256=L1WlOynj3t6HcsMxlVr4Zs7eOjNPPD_4UR4_WXpLKqo,6985
-patato/recon/model_based/generate_model.cu,sha256=vuE5DHDcc_5WAdmbqJBTsctOAKBCa9ykBhULkJCbGio,5999
-patato/recon/model_based/generate_model.pypy39-pp73-win_amd64.pyd,sha256=CG_Y7sALKSfklAqpqIMzmr9L9bcGyMTzK74ag0x8G4w,113152
-patato/recon/model_based/generate_model_refraction.cpp,sha256=Zb7q8PjlfcdAQvk8I3gll1SObeNAYUuCBUtxY0VVwnw,8080
-patato/recon/model_based/generate_model_refraction.cu,sha256=oK1YSGwJXqbOKpUtlLmyB7LVQoPKL_SaGHHyLQnANHc,7990
-patato/recon/model_based/generate_model_refraction.pypy39-pp73-win_amd64.pyd,sha256=vzuVDc_oP38EowBYsb2CoHog9OOiUXFEpTWLmGuwnBM,114176
-patato/recon/model_based/model_based.py,sha256=inaEDxRRU_XBdlxqshjALI5yI1q_8ArskWRKPUAyUy4,11229
-patato/recon/model_based/numpy_implementation.py,sha256=cz0y0eWx8VHutcicMYc7MMvD4w73XFYoLpn_VBbrSw4,2524
-patato/recon/numpy_backprojection/__init__.py,sha256=4nvs_RQQj5CLcNJyJNTg9MbQaMIc9hIA21CS92pdC3w,55
-patato/recon/numpy_backprojection/recon.py,sha256=p6HI7wPeKBMUM8ceQNQiN_Whzwmg950A_Eeyh3C2NjQ,3004
-patato/unmixing/__init__.py,sha256=okS9h1ZUJOBGV5nDvwxQ-wU-mHX9fdAakSWZA_UTrGw,576
-patato/unmixing/unmixer.py,sha256=IEryk9ytHOw4GCqD4iiYdi6PjMF8C-XLGPl1QbmO_-I,16207
-patato/unmixing/spectra/__init__.py,sha256=VRN9p1ZUI-oSzKjvyGVVwfmySZeVd6Udei5mpdE_vgA,4290
-patato/useful_utilities/__init__.py,sha256=shTgrA0Anbuh0oCoFrfvSHbsTzd3yo6Lb0QQdGnz53c,9837
-patato/utils/__init__.py,sha256=mMMPLCa79uMDAciVt-M6j8LIuZv4rGAxvIg5uunH8lM,523
-patato/utils/mask_operations.py,sha256=lQMbcclz4_AeS_r-94moi9IlbL-XuHjTFW5K1k0VnwM,4320
-patato/utils/plotting.py,sha256=Xu_DffkU_vryOwarX-lJ_l4I6LCn6I3mAoWJLGXXM-Q,1316
-patato/utils/process_study.py,sha256=xjmt_UeAHL-NhSP8fBD8eEGNlr7B--YcGiMMlnZwqQY,585
-patato/utils/roi_operations.py,sha256=Yo6sYoDLX4e4zlFDNZO65NqdLjMRUL32PwYN7icjGOs,3570
-patato/utils/run_pipeline.py,sha256=wZQe9XNmmV2Q1O9IieW4Lcplp_Q6h0XM2CTlzc4NuYg,4262
-patato/utils/time_series_analysis.py,sha256=KIE7vKGVZ4s0dIk0UjK6xMbEMD6bE6haa6p4hjLFa8c,3025
-patato/utils/rois/__init__.py,sha256=4nvs_RQQj5CLcNJyJNTg9MbQaMIc9hIA21CS92pdC3w,55
-patato/utils/rois/roi_type.py,sha256=qYPiHd_ergfvQVnFet79oTgQJR17PGHKUgtcwZ_fQ5Y,3338
-patato/utils/tests/__init__.py,sha256=4nvs_RQQj5CLcNJyJNTg9MbQaMIc9hIA21CS92pdC3w,55
-patato-0.5.1.dist-info/LICENSE.MD,sha256=j44Ev7kbJ84JPxJCY57oPkpIN349hJKJZ3l37VEVqDQ,1087
-patato-0.5.1.dist-info/METADATA,sha256=hDJ-cZZQwDG4dPOcURY9I6veMwHP1mVogHaV1qwH2Sk,4949
-patato-0.5.1.dist-info/WHEEL,sha256=QQY0XPJVcbNrDwRnZBTwtxGbMWJnHaWRpMJLfPEPCFM,107
-patato-0.5.1.dist-info/entry_points.txt,sha256=9kOo5kvzcgIhYy_AmIzDHBBl9FbY6TETSz7QNUrdWkE,590
-patato-0.5.1.dist-info/top_level.txt,sha256=5iGcyEUDu0xnFLYxVoto2fQydzOOVAnl498BCog-3CQ,7
-patato-0.5.1.dist-info/RECORD,,
+patato.libs/libstdc++-a9383cce.so.6.0.28,sha256=Wy9UCdwS1rwI9GU5e7qE61S0AkRqqwti1q_adWSs-Rk,2447393
+patato.libs/libgcc_s-a04fdf82.so.1,sha256=YxqJNaesQMhDswHEQpXsiLnVvMBBbYO6KYMDZFPWKSM,81257
+patato/__init__.py,sha256=8paF8-iMpw-wH0bpgbHTozpCF_FtVkEnrxTwsPji2XQ,2183
+patato/convenience_scripts/process_msot.py,sha256=pDTfLwglaYy7U3GpNHkCecs2O_Mnb4WEV8RSW0ZGIEw,4640
+patato/convenience_scripts/convert_binary_to_hdf5.py,sha256=TDvi8mGlYEmpXN8d5VhxiOZ0ih36A7DuBOGpvilNLIE,1247
+patato/convenience_scripts/import_ithera_recons.py,sha256=ccA4e9Bs6nEYjRCfRAWZsBwC38--ElQvXCTaXRYgt_0,1666
+patato/convenience_scripts/print_speeds.py,sha256=pRpWGRYpCZFxBPdZIYpJ65nsHpymVgTw-TtvENq_tZw,1541
+patato/convenience_scripts/view.py,sha256=ziE4iYdzN0FDJH0jLQcsyqDm1hFvK_1sgIaNy_JvWlw,4255
+patato/convenience_scripts/__init__.py,sha256=s5tH_b-03aAriJM2sHWMzzPxTSVVZ_IZBYYnt26kXhg,207
+patato/convenience_scripts/split_rois.py,sha256=jWhd7hp_V7o4174PEl2qPE8lX-unZQBD0Ztn6WnbgDI,1793
+patato/convenience_scripts/copy_rois.py,sha256=8MtfqK2oHPA_o6eI0BmfXUcY-FX8jpho0KO8A_tONDI,6648
+patato/convenience_scripts/import_clinical_data.py,sha256=zBGk3j7MNXC6NigQmLVDC1H7cH1vKzscGRvOrIpiPvg,1294
+patato/convenience_scripts/draw_roi.py,sha256=o2cQQnplYhqaxWXnmzWy1PtD9m-AVCs0J3ZirBrpZ84,20250
+patato/convenience_scripts/tune_speed_of_sound.py,sha256=I5hfHzT2GIOSy-sv1xm7-Um53Z3ewaSdkWcbDF5dOw0,8450
+patato/convenience_scripts/convert_simpa.py,sha256=x3TdI19zOASqDfc4JHp1xdj4bHrrtDp9VZ1QDGluXpY,1053
+patato/convenience_scripts/unmix.py,sha256=7YHsdIuqHCy_7rqBAN__ibrL60CRhjHWCWjnHe1GX48,2692
+patato/convenience_scripts/scan_status.py,sha256=M6UXlLUwI88tawkZJusactDN_dkp_kWpAn6Sbsti1yw,1895
+patato/convenience_scripts/rename_scan.py,sha256=-a5Xo9h5j2HahnlwYYZTQO-YUIyZaczrjnRpBvyy9i8,962
+patato/convenience_scripts/run_loads.txt,sha256=xqf-R6Puk2Yk-SUmvLeU_JS6Arm63HhXKwQwpedP9k0,90
+patato/convenience_scripts/generate_core.py,sha256=mvLqkKPAwPiGmgwjEmVn-O7h5212dFe1nw7iXuVswpE,2153
+patato/convenience_scripts/data_analysis/analyse_gas_challenge.py,sha256=rV0MjrQvvpSkfNYJXQSNLpNnQzb9kF4Ogw7G4zl6ogw,2741
+patato/convenience_scripts/data_analysis/__init__.py,sha256=Cl6lxRmUJqJ1d1iN4aQM91k-flw8A8ivO4s4QpWisuY,52
+patato/convenience_scripts/data_analysis/analyse_dce.py,sha256=UYXBfMWEZwzSllnYtp3dinva38V-YF8VMejukBCAa5o,2613
+patato/experimental/__init__.py,sha256=udvpC5Lii_AqJgnkncF3gmHspKLIg8jI3btwteRdyqA,51
+patato/experimental/simulation/__init__.py,sha256=tv2dDSJyLmufd3RXq5YT5z4Nffb1ZmmPiixDRqH-kig,53
+patato/utils/mask_operations.py,sha256=lQMbcclz4_AeS_r-94moi9IlbL-XuHjTFW5K1k0VnwM,4320
+patato/utils/__init__.py,sha256=mMMPLCa79uMDAciVt-M6j8LIuZv4rGAxvIg5uunH8lM,523
+patato/utils/process_study.py,sha256=xjmt_UeAHL-NhSP8fBD8eEGNlr7B--YcGiMMlnZwqQY,585
+patato/utils/plotting.py,sha256=Xu_DffkU_vryOwarX-lJ_l4I6LCn6I3mAoWJLGXXM-Q,1316
+patato/utils/roi_operations.py,sha256=Yo6sYoDLX4e4zlFDNZO65NqdLjMRUL32PwYN7icjGOs,3570
+patato/utils/time_series_analysis.py,sha256=KIE7vKGVZ4s0dIk0UjK6xMbEMD6bE6haa6p4hjLFa8c,3025
+patato/utils/pipeline.py,sha256=wZQe9XNmmV2Q1O9IieW4Lcplp_Q6h0XM2CTlzc4NuYg,4262
+patato/utils/rois/__init__.py,sha256=Cl6lxRmUJqJ1d1iN4aQM91k-flw8A8ivO4s4QpWisuY,52
+patato/utils/rois/roi_type.py,sha256=qYPiHd_ergfvQVnFet79oTgQJR17PGHKUgtcwZ_fQ5Y,3338
+patato/utils/tests/__init__.py,sha256=Cl6lxRmUJqJ1d1iN4aQM91k-flw8A8ivO4s4QpWisuY,52
+patato/recon/__init__.py,sha256=0PJGUjLl14aHkABOXI7dGYEiPRTRPoSJOasfRPBnZlE,1897
+patato/recon/reconstruction_algorithm.py,sha256=d1esso_QJUSbJ57t9H7Shcq8qqwo77BFV7v84ACuXJU,5070
+patato/recon/backprojection_reference.py,sha256=4muSfD6vRDHQXnPF_ut9mluDrg5gyUz6MzN9mo9XPhU,2137
+patato/recon/backprojection_opencl.py,sha256=i7rLxfCM_DyI0oVGrnlxsFVpssD_m1Abd-VhdcqzO_E,7337
+patato/recon/opencl_code/dmascl.cl,sha256=ZoxMAQvG9-Ipo1a4A2Eq9qmwfF_fQjY7T6-GXyByS0o,1729
+patato/recon/opencl_code/dascl.cl,sha256=lRy2f_zCoMdZN3OncnUIG7XRuhb0yH69TuB9y3p6hsQ,1633
+patato/recon/numpy_backprojection/recon.py,sha256=hhEd2mjAgEm3Sb2VIYJ-bsRqk121Y8Kj2JEAOFttZ0I,2920
+patato/recon/numpy_backprojection/__init__.py,sha256=Cl6lxRmUJqJ1d1iN4aQM91k-flw8A8ivO4s4QpWisuY,52
+patato/recon/model_based/model_based.py,sha256=inaEDxRRU_XBdlxqshjALI5yI1q_8ArskWRKPUAyUy4,11229
+patato/recon/model_based/numpy_implementation.py,sha256=cz0y0eWx8VHutcicMYc7MMvD4w73XFYoLpn_VBbrSw4,2524
+patato/recon/model_based/generate_model_refraction.cpython-38-x86_64-linux-gnu.so,sha256=Vbsyqwfi5_6n86MFQBQ500FqhMXt1hsvS-PWsFQisi0,3116185
+patato/recon/model_based/cuda_implementation.py,sha256=JKFVh4zHttgaanrHbBIRj45aGIVC-k1uOmBJJZZ8l24,3874
+patato/recon/model_based/generate_model.cpp,sha256=L1WlOynj3t6HcsMxlVr4Zs7eOjNPPD_4UR4_WXpLKqo,6985
+patato/recon/model_based/__init__.py,sha256=Cl6lxRmUJqJ1d1iN4aQM91k-flw8A8ivO4s4QpWisuY,52
+patato/recon/model_based/generate_model_refraction.cu,sha256=oK1YSGwJXqbOKpUtlLmyB7LVQoPKL_SaGHHyLQnANHc,7990
+patato/recon/model_based/cuda_implementation_refraction.py,sha256=iNqsujWa3iniIIy7gfFLWfmVrheSqvVP4l85TBI_KgQ,2806
+patato/recon/model_based/generate_model_refraction.cpp,sha256=Zb7q8PjlfcdAQvk8I3gll1SObeNAYUuCBUtxY0VVwnw,8080
+patato/recon/model_based/generate_model.cpython-38-x86_64-linux-gnu.so,sha256=IaFxz_eDVkSESVKsVW6dPc8TtcO5lJmwZKwmd7VN4DY,3083345
+patato/recon/model_based/generate_model.cu,sha256=vuE5DHDcc_5WAdmbqJBTsctOAKBCa9ykBhULkJCbGio,5999
+patato/recon/backprojection_implementation/__init__.py,sha256=Cl6lxRmUJqJ1d1iN4aQM91k-flw8A8ivO4s4QpWisuY,52
+patato/recon/backprojection_implementation/jax_implementation.py,sha256=jyNUCWsVAx9g2zG0rd6IbRw93gtaRL1tBdbCd-wS4hI,1022
+patato/recon/recon_presets/backproject_clinical.json,sha256=B7aISD4M0tEPD2YvgRrwL0xu-aDs2O6yW82Y_4El8Hs,488
+patato/recon/recon_presets/backproject_standard_yz.json,sha256=DrczBnNw4UEVeOkeByywWKBv50L84qODh3IHb6Glz7M,491
+patato/recon/recon_presets/backproject_standard_water_correction.json,sha256=3-A50alaDnxI_XjuavcxoWh2MeK5_7oY03HLIg-ce-o,557
+patato/recon/recon_presets/backproject_standard.json,sha256=2DohyJ-in4FGjUZfbWVJJThBCrqCTcYR6BZRMy7kdMI,491
+patato/recon/recon_presets/backproject_clinical_xz.json,sha256=B7aISD4M0tEPD2YvgRrwL0xu-aDs2O6yW82Y_4El8Hs,488
+patato/recon/recon_presets/backproject_standard_xy.json,sha256=2DohyJ-in4FGjUZfbWVJJThBCrqCTcYR6BZRMy7kdMI,491
+patato/recon/recon_presets/backproject_clinical_xy.json,sha256=HhH8dzs5428_CG3g5Oz8tmudeV5a6kBxRcYxZZs77rg,488
+patato/recon/recon_presets/backproject_clinical_yz.json,sha256=eJ8RTgEx6cB9gakK47yEMkBK8kBOYVE9i081gOO5Bbo,488
+patato/recon/recon_presets/backproject_standard_sos.json,sha256=CrJKU5ZAWpsjvE3zpMcrxqqakCEK8XCbQzTP-4C3sK8,493
+patato/recon/recon_presets/backproject_standard_xz.json,sha256=j25lEm2XrP0q2E5087DwDA9yp1PjOWF-0Zlg359goIc,491
+patato/recon/recon_presets/backproject_janek_sos.json,sha256=2cyXwWOe6MHk-DtwInm81aLVGbs4QdjBsqzU1YmWWCw,486
+patato/recon/recon_presets/backproject_janek.json,sha256=a5s-UqtVpjW4JhBPxKcphxAL3z_dqmctj8rsr9QfVfE,486
+patato/recon/recon_presets/backproject_noirf.json,sha256=eANdy8hCy4NSmbUKTP4Aaj8GZBEXRraSLHzd9J4zoO4,485
+patato/recon/recon_presets/backproject_standard_water_correction_new_ithera.json,sha256=moF23mXe37xMbwxugmWfRc0Y4X9MIiFtFgbXtmwZ1fU,561
+patato/core/__init__.py,sha256=OjPfgYBM0wSaYbXZWfZfTG8_P4K4vcPyh0vzEge3D5o,251
+patato/core/image_structures/single_parameter_data.py,sha256=P417UBbYBD18RRJPF8TpMIChyfG6ZlCLQ_YWZdd8UAI,1121
+patato/core/image_structures/pa_time_data.py,sha256=eyY5Asx5W7B-F7AcWJIkpw4EIetJhXk5HQCvDqqmGSQ,1331
+patato/core/image_structures/reconstruction_image.py,sha256=aaKnaFadxZD-2oJxwWfDRYO_V0PNSRHbUZp6frcOulY,851
+patato/core/image_structures/__init__.py,sha256=Cl6lxRmUJqJ1d1iN4aQM91k-flw8A8ivO4s4QpWisuY,52
+patato/core/image_structures/pa_raw_data.py,sha256=sbaYLZAWdEncYjdPQyojglJVEiM2Sai4Kxb7gTvXIUk,1430
+patato/core/image_structures/image_structure_types.py,sha256=0uNv4YbP_cSNE-h38o-Y51EGllhbl2TmysE_QU0eaT8,856
+patato/core/image_structures/unmixed_image.py,sha256=5MQ6TRWM7G7hUaamo6IAlETIFXpC39UoeEOLxhv1zcw,930
+patato/core/image_structures/single_image.py,sha256=aPf3ca7-nX-_pInyNCamFyA0elmw0TZZ77He40cD8CQ,982
+patato/core/image_structures/image_sequence.py,sha256=HM0YhmtfJc9DaJ0yRgjr0KLTsD6-ykhsthMWAktsGtg,12664
+patato/useful_utilities/__init__.py,sha256=shTgrA0Anbuh0oCoFrfvSHbsTzd3yo6Lb0QQdGnz53c,9837
+patato/unmixing/__init__.py,sha256=yLX1Y2TBDyOB4iJtCCtD-r3pN3nP-nX6Ns8yqsFxYEk,554
+patato/unmixing/unmixer.py,sha256=IEryk9ytHOw4GCqD4iiYdi6PjMF8C-XLGPl1QbmO_-I,16207
+patato/unmixing/spectra/__init__.py,sha256=VRN9p1ZUI-oSzKjvyGVVwfmySZeVd6Udei5mpdE_vgA,4290
+patato/unmixing/spectra/spectra_files/water.txt,sha256=aGEStd5vEA4iWVn4VKcL8qJlCyJ9D8UEToN42kxmGrA,3710
+patato/unmixing/spectra/spectra_files/prahl.txt,sha256=ETRMGQsMYqFOvFcKNa7njDx5EA8BQfes1oQF8cApsKE,6861
+patato/unmixing/spectra/spectra_files/Melanin.csv,sha256=DA53s-aX4r7z56HNN9Y3T1h8tNrRL6fAja2kQkquf30,17760
+patato/unmixing/spectra/spectra_files/ICG.csv,sha256=1NXytr15CvdUZNWqNnDv8FO_awoWvj36LfzdQnF6ISA,12113
+patato/unmixing/spectra/spectra_files/lipids.txt,sha256=Bp1wYboXlfzO1UV4vtMRA_urY71VPfS-kSXezw0Y2gk,7768
+patato/unmixing/spectra/spectra_files/water_long.txt,sha256=Q5W7Nky4Si2kSO1SLuvyhYWpDaVnQuOj2DpUpDjrY9Y,8643
+patato/unmixing/unmix_presets/hb_emma_water.json,sha256=1i5MhqIxYXx4MBbqT2JdTdtOTFR8dJTF-PNHIhqXx24,205
+patato/unmixing/unmix_presets/haemoglobin_flow_phantom.json,sha256=SQF6r3J_MZrqZwS5OkulFMAjD6OOaOG5Evo-QI_WACQ,120
+patato/unmixing/unmix_presets/haemoglobin_flow_phantom_all_wl.json,sha256=W5ZaCxwtoYRrZTOc8sd2V36zHsyfufGRdRu2YIShY_o,121
+patato/unmixing/unmix_presets/hb_icg.json,sha256=JIAtAVXwSvi6LMD5ntfXVCUaeJvBgehnj3xMy5rp4AI,132
+patato/unmixing/unmix_presets/haemoglobin_melanin.json,sha256=4m8wYijDfYxFKOO7EjnJMhLhGd_4qsaRXQG0-cKrueY,134
+patato/unmixing/unmix_presets/haemoglobin.json,sha256=5m2KPYRdvppl6EHUqFeYzsKJRH4ej8rpYsByeGBcefc,120
+patato/unmixing/unmix_presets/haemoglobin_mitox.json,sha256=lFfePFEDUupPfaYO8T7y-sIe4kJrxaXf5VdSPMpVt7s,183
+patato/io/hdf5_converter.py,sha256=EjLK-nqhCoITNjLm3BL4_PmYMn14oL6uIIyhhP0p-_8,3934
+patato/io/__init__.py,sha256=fJcLCcifgHYhuiPEqmhB3FS86HC1Y4B8vLalXS_L6t4,194
+patato/io/attribute_tags.py,sha256=pIIavrBBhx3Choj6sESj98j5DCnyWNPUANRjyV2DIeA,2877
+patato/io/msot_data.py,sha256=yqPnLA3SKSIVwwHMtR_gZWKZaU-VM_Yt6PVrKRcFyA8,23221
+patato/io/ipasc/__init__.py,sha256=iyFv3ZCT0X_iggsB9QUmc3lj31mi6daKOp-tUdM5TJw,518
+patato/io/ipasc/read_ipasc.py,sha256=Rs6PDCZdkzzziLoTOdFA5fAjbOVzBnKUBih-OwRfzYs,3011
+patato/io/ipasc/ipasc_export.py,sha256=GV86nWFTB1oeiBuLTAqpZoIgrrvmGOBXMp50vFawabs,2472
+patato/io/simpa/__init__.py,sha256=Cl6lxRmUJqJ1d1iN4aQM91k-flw8A8ivO4s4QpWisuY,52
+patato/io/simpa/read_simpa.py,sha256=xebVaC4u36rwDVEkNwstGEUFeXn1Q5qMDcN2XT0i9A8,5192
+patato/io/json/__init__.py,sha256=Cl6lxRmUJqJ1d1iN4aQM91k-flw8A8ivO4s4QpWisuY,52
+patato/io/json/json_reading.py,sha256=kWnJIZmjtnHKoRr-0pz9qeyJjlKAheG-eKjpAunCPqs,6714
+patato/io/ithera/__init__.py,sha256=VlJY4mKMJCbwVoySVT-0knMVSHfifFxMFkMPhEifmY0,245
+patato/io/ithera/read_ithera.py,sha256=gbp2XZPWBeRkB2M35r_JDJmCRI48Qf-jQcRlhQR6Pq8,13847
+patato/io/hdf/fileimporter.py,sha256=r4wBCSmqI-pCVOplF4Iqt-nnlS1ftvrzGaj8OH3fILg,12304
+patato/io/hdf/__init__.py,sha256=Cl6lxRmUJqJ1d1iN4aQM91k-flw8A8ivO4s4QpWisuY,52
+patato/io/hdf/hdf5_interface.py,sha256=galHh-TA8lYhUTMMDFUlQnt0murWEVRnrEFeHJAVtzc,17073
+patato/processing/jax_preprocessing_algorithm.py,sha256=hL-ovwikfRv0wWkmqTF8sVa4hI2N8fuAKrfsX73L35k,12018
+patato/processing/preprocessing_types.py,sha256=bSmShY5fncrQpZf_XVTJBpxS81U9qUapIEeXnxqo2Lw,685
+patato/processing/processing_algorithm.py,sha256=Z8Xq9rjhuOfK6CuLoA4OFxi6FU6_Q2vcxHWG-4TdDTk,2259
+patato/processing/gpu_preprocessing_algorithm.py,sha256=H32U1ia7L5Ul9DA2efunsT-K2NhUpRwlA4G4mxzT2UI,11603
+patato/processing/__init__.py,sha256=TvgFkvUVP0FbC4YlS_rMW39R8bR4GepLKLX5zwqpL_0,330
+patato/processing/preprocessing_algorithm.py,sha256=nvgjnuJN_UaMBEcISh6-x5e59ktvYwOvenDLJDHZScA,10264
+patato/data/__init__.py,sha256=Ido8oDRuWM7SReBHYeUkSgz8rTpJlakjMSeJ_5G1Okc,680
+patato/data/get_example_datasets.py,sha256=QPewCF38Y1jr2wEKQ1TwtubAUXIS4xrsNePP3es4dQ8,3572
+patato/data/simulated_datasets.py,sha256=RiBwverDj0g_4VEKSpymn7Bv9pbLkgkYaDFIbe9Z9v8,2049
+patato-0.5.2.dist-info/WHEEL,sha256=NOAhgw20kYU5I9Nb1TPKWuNrdVfBibm59YwSQWPYWAU,111
+patato-0.5.2.dist-info/LICENSE.MD,sha256=wW9QCQSPzpt-TmvHgFpebOSCfBrKYw2tfHExePIwXH0,1067
+patato-0.5.2.dist-info/top_level.txt,sha256=5iGcyEUDu0xnFLYxVoto2fQydzOOVAnl498BCog-3CQ,7
+patato-0.5.2.dist-info/METADATA,sha256=i5w5k9nIqb--q9q-g9d2siAUFdrvIFABuru5huOcM8A,4836
+patato-0.5.2.dist-info/entry_points.txt,sha256=9kOo5kvzcgIhYy_AmIzDHBBl9FbY6TETSz7QNUrdWkE,590
+patato-0.5.2.dist-info/RECORD,,
```

