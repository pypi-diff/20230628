# Comparing `tmp/aas-core3.0-1.0.0rc1.tar.gz` & `tmp/aas-core3.0-1.0.0rc2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist\aas-core3.0-1.0.0rc1.tar", last modified: Sat Mar 18 13:54:17 2023, max compression
+gzip compressed data, was "aas-core3.0-1.0.0rc2.tar", last modified: Wed Jun 28 08:11:31 2023, max compression
```

## Comparing `aas-core3.0-1.0.0rc1.tar` & `aas-core3.0-1.0.0rc2.tar`

### file list

```diff
@@ -1,21 +1,39 @@
-drwxrwxrwx   0        0        0        0 2023-03-18 13:54:17.656331 aas-core3.0-1.0.0rc1/
--rw-rw-rw-   0        0        0     1092 2023-03-18 13:54:09.000000 aas-core3.0-1.0.0rc1/LICENSE
--rw-rw-rw-   0        0        0     2307 2023-03-18 13:54:17.655334 aas-core3.0-1.0.0rc1/PKG-INFO
--rw-rw-rw-   0        0        0     1502 2023-03-18 13:54:09.000000 aas-core3.0-1.0.0rc1/README.rst
-drwxrwxrwx   0        0        0        0 2023-03-18 13:54:17.631397 aas-core3.0-1.0.0rc1/aas_core3/
--rw-rw-rw-   0        0        0      329 2023-03-18 13:54:09.000000 aas-core3.0-1.0.0rc1/aas_core3/__init__.py
--rw-rw-rw-   0        0        0      597 2023-03-18 13:54:09.000000 aas-core3.0-1.0.0rc1/aas_core3/common.py
--rw-rw-rw-   0        0        0     6666 2023-03-18 13:54:09.000000 aas-core3.0-1.0.0rc1/aas_core3/constants.py
--rw-rw-rw-   0        0        0   351069 2023-03-18 13:54:09.000000 aas-core3.0-1.0.0rc1/aas_core3/jsonization.py
--rw-rw-rw-   0        0        0       64 2023-03-18 13:54:09.000000 aas-core3.0-1.0.0rc1/aas_core3/py.typed
--rw-rw-rw-   0        0        0    13561 2023-03-18 13:54:09.000000 aas-core3.0-1.0.0rc1/aas_core3/stringification.py
--rw-rw-rw-   0        0        0   281185 2023-03-18 13:54:09.000000 aas-core3.0-1.0.0rc1/aas_core3/types.py
--rw-rw-rw-   0        0        0   237333 2023-03-18 13:54:09.000000 aas-core3.0-1.0.0rc1/aas_core3/verification.py
--rw-rw-rw-   0        0        0   977008 2023-03-18 13:54:09.000000 aas-core3.0-1.0.0rc1/aas_core3/xmlization.py
-drwxrwxrwx   0        0        0        0 2023-03-18 13:54:17.654337 aas-core3.0-1.0.0rc1/aas_core3.0.egg-info/
--rw-rw-rw-   0        0        0     2307 2023-03-18 13:54:17.000000 aas-core3.0-1.0.0rc1/aas_core3.0.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0      374 2023-03-18 13:54:17.000000 aas-core3.0-1.0.0rc1/aas_core3.0.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-03-18 13:54:17.000000 aas-core3.0-1.0.0rc1/aas_core3.0.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       10 2023-03-18 13:54:17.000000 aas-core3.0-1.0.0rc1/aas_core3.0.egg-info/top_level.txt
--rw-rw-rw-   0        0        0       42 2023-03-18 13:54:17.656331 aas-core3.0-1.0.0rc1/setup.cfg
--rw-rw-rw-   0        0        0     1575 2023-03-18 13:54:09.000000 aas-core3.0-1.0.0rc1/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-28 08:11:31.992573 aas-core3.0-1.0.0rc2/
+-rw-r--r--   0 runner    (1001) docker     (123)     1071 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     2232 2023-06-28 08:11:31.992573 aas-core3.0-1.0.0rc2/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     1468 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/README.rst
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-28 08:11:31.988572 aas-core3.0-1.0.0rc2/aas_core3/
+-rw-r--r--   0 runner    (1001) docker     (123)      321 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/aas_core3/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      575 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/aas_core3/common.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6674 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/aas_core3/constants.py
+-rw-r--r--   0 runner    (1001) docker     (123)   341761 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/aas_core3/jsonization.py
+-rw-r--r--   0 runner    (1001) docker     (123)       63 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/aas_core3/py.typed
+-rw-r--r--   0 runner    (1001) docker     (123)    13216 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/aas_core3/stringification.py
+-rw-r--r--   0 runner    (1001) docker     (123)   276578 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/aas_core3/types.py
+-rw-r--r--   0 runner    (1001) docker     (123)   229816 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/aas_core3/verification.py
+-rw-r--r--   0 runner    (1001) docker     (123)   950512 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/aas_core3/xmlization.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-28 08:11:31.992573 aas-core3.0-1.0.0rc2/aas_core3.0.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     2232 2023-06-28 08:11:31.000000 aas-core3.0-1.0.0rc2/aas_core3.0.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     1427 2023-06-28 08:11:31.000000 aas-core3.0-1.0.0rc2/aas_core3.0.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-28 08:11:31.000000 aas-core3.0-1.0.0rc2/aas_core3.0.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       22 2023-06-28 08:11:31.000000 aas-core3.0-1.0.0rc2/aas_core3.0.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-28 08:11:31.984572 aas-core3.0-1.0.0rc2/dev_scripts/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-28 08:11:31.992573 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/
+-rw-r--r--   0 runner    (1001) docker     (123)       39 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3417 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/common.py
+-rw-r--r--   0 runner    (1001) docker     (123)      849 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_all.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10953 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_common_jsonization.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5049 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_test_for_descend_and_pass_through_visitor.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3075 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_test_for_descend_once.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4675 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_test_for_jsonization_of_classes_with_descendants.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13346 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_test_for_jsonization_of_concrete_classes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3991 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_test_for_jsonization_of_concrete_classes_outside_container.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2791 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_test_for_jsonization_of_enums.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7073 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_test_for_over_X_or_empty.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5632 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_test_for_x_or_default.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6109 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_test_for_xmlization_of_classes_with_descendants.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10711 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_test_for_xmlization_of_concrete_classes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4674 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/generate_test_for_xmlization_of_concrete_classes_outside_container.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5423 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/dev_scripts/test_codegen/test_data_io.py
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-06-28 08:11:31.992573 aas-core3.0-1.0.0rc2/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     1532 2023-06-28 08:11:16.000000 aas-core3.0-1.0.0rc2/setup.py
```

### Comparing `aas-core3.0-1.0.0rc1/LICENSE` & `aas-core3.0-1.0.0rc2/LICENSE`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-MIT License
-
-Copyright (c) 2022 aas-core-works
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
+MIT License
+
+Copyright (c) 2022 aas-core-works
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
```

### Comparing `aas-core3.0-1.0.0rc1/PKG-INFO` & `aas-core3.0-1.0.0rc2/PKG-INFO`

 * *Files 11% similar despite different names*

```diff
@@ -1,55 +1,52 @@
-Metadata-Version: 2.1
-Name: aas-core3.0
-Version: 1.0.0rc1
-Summary: Manipulate, verify and de/serialize Asset Administration Shells.
-Home-page: https://github.com/aas-core-works/aas-core3.0-python
-Author: Marko Ristin
-Author-email: marko@ristin.ch
-License: License :: OSI Approved :: MIT License
-Keywords: asset administration shell sdk industry 4.0 industrie i4.0 industry iot iiot
-Platform: UNKNOWN
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-License-File: LICENSE
-
-**********************
-aas-core3.0-python
-**********************
-
-.. image:: https://github.com/aas-core-works/aas-core3.0-python/actions/workflows/ci.yml/badge.svg
-    :target: https://github.com/aas-core-works/aas-core3.0-python/actions/workflows/ci.yml
-    :alt: Continuous integration
-
-.. image:: https://coveralls.io/repos/github/aas-core-works/aas-core3.0-python/badge.svg?branch=main
-    :target: https://coveralls.io/github/aas-core-works/aas-core3.0-python?branch=main
-    :alt: Test coverage
-
-.. image:: https://badge.fury.io/py/aas-core3.0.svg
-    :target: https://badge.fury.io/py/aas-core3.0
-    :alt: PyPI - version
-
-.. image:: https://img.shields.io/pypi/pyversions/aas-core3.0.svg
-    :alt: PyPI - Python Version
-
-.. image:: https://readthedocs.org/projects/aas-core30-python/badge/?version=latest
-    :target: https://aas-core30-python.readthedocs.io/en/latest/?badge=latest
-    :alt: Documentation
-
-This is a software development kit (SDK) to manipulate, verify and de/serialize Asset Administration Shells based on the version 3.0 of the meta-model.
-
-The documentation is available on: https://aas-core30-python.readthedocs.io/en/latest/.
-
-The majority of the code has been automatically generated by `aas-core-codegen`_.
-
-If you want to contribute, see our `contributing guide`_.
-
-.. _aas-core-codegen: https://github.com/aas-core-works/aas-core-codegen
-
-.. _contributing guide: https://aas-core30-python.readthedocs.io/en/latest/contributing.html
-
-
+Metadata-Version: 2.1
+Name: aas-core3.0
+Version: 1.0.0rc2
+Summary: Manipulate, verify and de/serialize Asset Administration Shells.
+Home-page: https://github.com/aas-core-works/aas-core3.0-python
+Author: Marko Ristin
+Author-email: marko@ristin.ch
+License: License :: OSI Approved :: MIT License
+Keywords: asset administration shell sdk industry 4.0 industrie i4.0 industry iot iiot
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+License-File: LICENSE
+
+**********************
+aas-core3.0-python
+**********************
+
+.. image:: https://github.com/aas-core-works/aas-core3.0-python/actions/workflows/ci.yml/badge.svg
+    :target: https://github.com/aas-core-works/aas-core3.0-python/actions/workflows/ci.yml
+    :alt: Continuous integration
+
+.. image:: https://coveralls.io/repos/github/aas-core-works/aas-core3.0-python/badge.svg?branch=main
+    :target: https://coveralls.io/github/aas-core-works/aas-core3.0-python?branch=main
+    :alt: Test coverage
+
+.. image:: https://badge.fury.io/py/aas-core3.0.svg
+    :target: https://badge.fury.io/py/aas-core3.0
+    :alt: PyPI - version
+
+.. image:: https://img.shields.io/pypi/pyversions/aas-core3.0.svg
+    :alt: PyPI - Python Version
+
+.. image:: https://readthedocs.org/projects/aas-core30-python/badge/?version=latest
+    :target: https://aas-core30-python.readthedocs.io/en/latest/?badge=latest
+    :alt: Documentation
+
+This is a software development kit (SDK) to manipulate, verify and de/serialize Asset Administration Shells based on the version 3.0 of the meta-model.
+
+The documentation is available on: https://aas-core30-python.readthedocs.io/en/latest/.
+
+The majority of the code has been automatically generated by `aas-core-codegen`_.
+
+If you want to contribute, see our `contributing guide`_.
+
+.. _aas-core-codegen: https://github.com/aas-core-works/aas-core-codegen
+
+.. _contributing guide: https://aas-core30-python.readthedocs.io/en/latest/contributing.html
```

### Comparing `aas-core3.0-1.0.0rc1/README.rst` & `aas-core3.0-1.0.0rc2/README.rst`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,34 +1,34 @@
-**********************
-aas-core3.0-python
-**********************
-
-.. image:: https://github.com/aas-core-works/aas-core3.0-python/actions/workflows/ci.yml/badge.svg
-    :target: https://github.com/aas-core-works/aas-core3.0-python/actions/workflows/ci.yml
-    :alt: Continuous integration
-
-.. image:: https://coveralls.io/repos/github/aas-core-works/aas-core3.0-python/badge.svg?branch=main
-    :target: https://coveralls.io/github/aas-core-works/aas-core3.0-python?branch=main
-    :alt: Test coverage
-
-.. image:: https://badge.fury.io/py/aas-core3.0.svg
-    :target: https://badge.fury.io/py/aas-core3.0
-    :alt: PyPI - version
-
-.. image:: https://img.shields.io/pypi/pyversions/aas-core3.0.svg
-    :alt: PyPI - Python Version
-
-.. image:: https://readthedocs.org/projects/aas-core30-python/badge/?version=latest
-    :target: https://aas-core30-python.readthedocs.io/en/latest/?badge=latest
-    :alt: Documentation
-
-This is a software development kit (SDK) to manipulate, verify and de/serialize Asset Administration Shells based on the version 3.0 of the meta-model.
-
-The documentation is available on: https://aas-core30-python.readthedocs.io/en/latest/.
-
-The majority of the code has been automatically generated by `aas-core-codegen`_.
-
-If you want to contribute, see our `contributing guide`_.
-
-.. _aas-core-codegen: https://github.com/aas-core-works/aas-core-codegen
-
-.. _contributing guide: https://aas-core30-python.readthedocs.io/en/latest/contributing.html
+**********************
+aas-core3.0-python
+**********************
+
+.. image:: https://github.com/aas-core-works/aas-core3.0-python/actions/workflows/ci.yml/badge.svg
+    :target: https://github.com/aas-core-works/aas-core3.0-python/actions/workflows/ci.yml
+    :alt: Continuous integration
+
+.. image:: https://coveralls.io/repos/github/aas-core-works/aas-core3.0-python/badge.svg?branch=main
+    :target: https://coveralls.io/github/aas-core-works/aas-core3.0-python?branch=main
+    :alt: Test coverage
+
+.. image:: https://badge.fury.io/py/aas-core3.0.svg
+    :target: https://badge.fury.io/py/aas-core3.0
+    :alt: PyPI - version
+
+.. image:: https://img.shields.io/pypi/pyversions/aas-core3.0.svg
+    :alt: PyPI - Python Version
+
+.. image:: https://readthedocs.org/projects/aas-core30-python/badge/?version=latest
+    :target: https://aas-core30-python.readthedocs.io/en/latest/?badge=latest
+    :alt: Documentation
+
+This is a software development kit (SDK) to manipulate, verify and de/serialize Asset Administration Shells based on the version 3.0 of the meta-model.
+
+The documentation is available on: https://aas-core30-python.readthedocs.io/en/latest/.
+
+The majority of the code has been automatically generated by `aas-core-codegen`_.
+
+If you want to contribute, see our `contributing guide`_.
+
+.. _aas-core-codegen: https://github.com/aas-core-works/aas-core-codegen
+
+.. _contributing guide: https://aas-core30-python.readthedocs.io/en/latest/contributing.html
```

### Comparing `aas-core3.0-1.0.0rc1/aas_core3/common.py` & `aas-core3.0-1.0.0rc2/aas_core3/common.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-"""Provide common functions shared among the modules."""
-
-
-# This code has been automatically generated by aas-core-codegen.
-# Do NOT edit or append.
-
-
-from typing import NoReturn
-
-
-def assert_never(value: NoReturn) -> NoReturn:
-    """
-    Signal to mypy to perform an exhaustive matching.
-
-    Please see the following page for more details:
-    https://hakibenita.com/python-mypy-exhaustive-checking
-    """
-    assert False, f"Unhandled value: {value} ({type(value).__name__})"
-
-
-# This code has been automatically generated by aas-core-codegen.
-# Do NOT edit or append.
+"""Provide common functions shared among the modules."""
+
+
+# This code has been automatically generated by aas-core-codegen.
+# Do NOT edit or append.
+
+
+from typing import NoReturn
+
+
+def assert_never(value: NoReturn) -> NoReturn:
+    """
+    Signal to mypy to perform an exhaustive matching.
+
+    Please see the following page for more details:
+    https://hakibenita.com/python-mypy-exhaustive-checking
+    """
+    assert False, f"Unhandled value: {value} ({type(value).__name__})"
+
+
+# This code has been automatically generated by aas-core-codegen.
+# Do NOT edit or append.
```

### Comparing `aas-core3.0-1.0.0rc1/aas_core3/constants.py` & `aas-core3.0-1.0.0rc2/aas_core3/constants.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,170 +1,170 @@
-"""Provide constant values of the meta-model."""
-
-# This code has been automatically generated by aas-core-codegen.
-# Do NOT edit or append.
-
-from typing import Set
-
-import aas_core3.types as aas_types
-
-#: Categories for :py:class:`.types.DataElement` as defined in :ref:`Constraint AASd-090 <constraint_AASd-090>`
-VALID_CATEGORIES_FOR_DATA_ELEMENT: Set[str] = {"CONSTANT", "PARAMETER", "VARIABLE"}
-
-#: Enumeration of all identifiable elements within an asset administration shell.
-GENERIC_FRAGMENT_KEYS: Set[aas_types.KeyTypes] = {aas_types.KeyTypes.FRAGMENT_REFERENCE}
-
-#: Enumeration of different key value types within a key.
-GENERIC_GLOBALLY_IDENTIFIABLES: Set[aas_types.KeyTypes] = {
-    aas_types.KeyTypes.GLOBAL_REFERENCE
-}
-
-#: Enumeration of different key value types within a key.
-AAS_IDENTIFIABLES: Set[aas_types.KeyTypes] = {
-    aas_types.KeyTypes.ASSET_ADMINISTRATION_SHELL,
-    aas_types.KeyTypes.CONCEPT_DESCRIPTION,
-    aas_types.KeyTypes.IDENTIFIABLE,
-    aas_types.KeyTypes.SUBMODEL,
-}
-
-#: Enumeration of all submodel elements within an asset administration shell.
-AAS_SUBMODEL_ELEMENTS_AS_KEYS: Set[aas_types.KeyTypes] = {
-    aas_types.KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT,
-    aas_types.KeyTypes.BASIC_EVENT_ELEMENT,
-    aas_types.KeyTypes.BLOB,
-    aas_types.KeyTypes.CAPABILITY,
-    aas_types.KeyTypes.DATA_ELEMENT,
-    aas_types.KeyTypes.ENTITY,
-    aas_types.KeyTypes.EVENT_ELEMENT,
-    aas_types.KeyTypes.FILE,
-    aas_types.KeyTypes.MULTI_LANGUAGE_PROPERTY,
-    aas_types.KeyTypes.OPERATION,
-    aas_types.KeyTypes.PROPERTY,
-    aas_types.KeyTypes.RANGE,
-    aas_types.KeyTypes.REFERENCE_ELEMENT,
-    aas_types.KeyTypes.RELATIONSHIP_ELEMENT,
-    aas_types.KeyTypes.SUBMODEL_ELEMENT,
-    aas_types.KeyTypes.SUBMODEL_ELEMENT_COLLECTION,
-    aas_types.KeyTypes.SUBMODEL_ELEMENT_LIST,
-}
-
-#: Enumeration of different fragment key value types within a key.
-AAS_REFERABLE_NON_IDENTIFIABLES: Set[aas_types.KeyTypes] = {
-    aas_types.KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT,
-    aas_types.KeyTypes.BASIC_EVENT_ELEMENT,
-    aas_types.KeyTypes.BLOB,
-    aas_types.KeyTypes.CAPABILITY,
-    aas_types.KeyTypes.DATA_ELEMENT,
-    aas_types.KeyTypes.ENTITY,
-    aas_types.KeyTypes.EVENT_ELEMENT,
-    aas_types.KeyTypes.FILE,
-    aas_types.KeyTypes.MULTI_LANGUAGE_PROPERTY,
-    aas_types.KeyTypes.OPERATION,
-    aas_types.KeyTypes.PROPERTY,
-    aas_types.KeyTypes.RANGE,
-    aas_types.KeyTypes.REFERENCE_ELEMENT,
-    aas_types.KeyTypes.RELATIONSHIP_ELEMENT,
-    aas_types.KeyTypes.SUBMODEL_ELEMENT,
-    aas_types.KeyTypes.SUBMODEL_ELEMENT_COLLECTION,
-    aas_types.KeyTypes.SUBMODEL_ELEMENT_LIST,
-}
-
-#: Enumeration of referables.
-AAS_REFERABLES: Set[aas_types.KeyTypes] = {
-    aas_types.KeyTypes.ASSET_ADMINISTRATION_SHELL,
-    aas_types.KeyTypes.CONCEPT_DESCRIPTION,
-    aas_types.KeyTypes.IDENTIFIABLE,
-    aas_types.KeyTypes.SUBMODEL,
-    aas_types.KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT,
-    aas_types.KeyTypes.BASIC_EVENT_ELEMENT,
-    aas_types.KeyTypes.BLOB,
-    aas_types.KeyTypes.CAPABILITY,
-    aas_types.KeyTypes.DATA_ELEMENT,
-    aas_types.KeyTypes.ENTITY,
-    aas_types.KeyTypes.EVENT_ELEMENT,
-    aas_types.KeyTypes.FILE,
-    aas_types.KeyTypes.MULTI_LANGUAGE_PROPERTY,
-    aas_types.KeyTypes.OPERATION,
-    aas_types.KeyTypes.PROPERTY,
-    aas_types.KeyTypes.RANGE,
-    aas_types.KeyTypes.REFERENCE_ELEMENT,
-    aas_types.KeyTypes.REFERABLE,
-    aas_types.KeyTypes.RELATIONSHIP_ELEMENT,
-    aas_types.KeyTypes.SUBMODEL_ELEMENT,
-    aas_types.KeyTypes.SUBMODEL_ELEMENT_COLLECTION,
-    aas_types.KeyTypes.SUBMODEL_ELEMENT_LIST,
-}
-
-#: Enumeration of all referable elements within an asset administration shell
-GLOBALLY_IDENTIFIABLES: Set[aas_types.KeyTypes] = {
-    aas_types.KeyTypes.GLOBAL_REFERENCE,
-    aas_types.KeyTypes.ASSET_ADMINISTRATION_SHELL,
-    aas_types.KeyTypes.CONCEPT_DESCRIPTION,
-    aas_types.KeyTypes.IDENTIFIABLE,
-    aas_types.KeyTypes.SUBMODEL,
-}
-
-#: Enumeration of different key value types within a key.
-FRAGMENT_KEYS: Set[aas_types.KeyTypes] = {
-    aas_types.KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT,
-    aas_types.KeyTypes.BASIC_EVENT_ELEMENT,
-    aas_types.KeyTypes.BLOB,
-    aas_types.KeyTypes.CAPABILITY,
-    aas_types.KeyTypes.DATA_ELEMENT,
-    aas_types.KeyTypes.ENTITY,
-    aas_types.KeyTypes.EVENT_ELEMENT,
-    aas_types.KeyTypes.FILE,
-    aas_types.KeyTypes.FRAGMENT_REFERENCE,
-    aas_types.KeyTypes.MULTI_LANGUAGE_PROPERTY,
-    aas_types.KeyTypes.OPERATION,
-    aas_types.KeyTypes.PROPERTY,
-    aas_types.KeyTypes.RANGE,
-    aas_types.KeyTypes.REFERENCE_ELEMENT,
-    aas_types.KeyTypes.RELATIONSHIP_ELEMENT,
-    aas_types.KeyTypes.SUBMODEL_ELEMENT,
-    aas_types.KeyTypes.SUBMODEL_ELEMENT_COLLECTION,
-    aas_types.KeyTypes.SUBMODEL_ELEMENT_LIST,
-}
-
-#: IEC 61360 data types for concept descriptions categorized with PROPERTY or VALUE.
-DATA_TYPE_IEC_61360_FOR_PROPERTY_OR_VALUE: Set[aas_types.DataTypeIEC61360] = {
-    aas_types.DataTypeIEC61360.DATE,
-    aas_types.DataTypeIEC61360.STRING,
-    aas_types.DataTypeIEC61360.STRING_TRANSLATABLE,
-    aas_types.DataTypeIEC61360.INTEGER_MEASURE,
-    aas_types.DataTypeIEC61360.INTEGER_COUNT,
-    aas_types.DataTypeIEC61360.INTEGER_CURRENCY,
-    aas_types.DataTypeIEC61360.REAL_MEASURE,
-    aas_types.DataTypeIEC61360.REAL_COUNT,
-    aas_types.DataTypeIEC61360.REAL_CURRENCY,
-    aas_types.DataTypeIEC61360.BOOLEAN,
-    aas_types.DataTypeIEC61360.RATIONAL,
-    aas_types.DataTypeIEC61360.RATIONAL_MEASURE,
-    aas_types.DataTypeIEC61360.TIME,
-    aas_types.DataTypeIEC61360.TIMESTAMP,
-}
-
-#: IEC 61360 data types for concept descriptions categorized with REFERENCE.
-DATA_TYPE_IEC_61360_FOR_REFERENCE: Set[aas_types.DataTypeIEC61360] = {
-    aas_types.DataTypeIEC61360.STRING,
-    aas_types.DataTypeIEC61360.IRI,
-    aas_types.DataTypeIEC61360.IRDI,
-}
-
-#: IEC 61360 data types for concept descriptions categorized with DOCUMENT.
-DATA_TYPE_IEC_61360_FOR_DOCUMENT: Set[aas_types.DataTypeIEC61360] = {
-    aas_types.DataTypeIEC61360.FILE,
-    aas_types.DataTypeIEC61360.BLOB,
-    aas_types.DataTypeIEC61360.HTML,
-}
-
-#: These data types imply that the unit is defined in the data specification.
-IEC_61360_DATA_TYPES_WITH_UNIT: Set[aas_types.DataTypeIEC61360] = {
-    aas_types.DataTypeIEC61360.INTEGER_MEASURE,
-    aas_types.DataTypeIEC61360.REAL_MEASURE,
-    aas_types.DataTypeIEC61360.RATIONAL_MEASURE,
-    aas_types.DataTypeIEC61360.INTEGER_CURRENCY,
-    aas_types.DataTypeIEC61360.REAL_CURRENCY,
-}
-
-# This code has been automatically generated by aas-core-codegen.
-# Do NOT edit or append.
+"""Provide constant values of the meta-model."""
+
+# This code has been automatically generated by aas-core-codegen.
+# Do NOT edit or append.
+
+from typing import Set
+
+import aas_core3.types as aas_types
+
+#: Categories for :py:class:`.types.DataElement` as defined in :ref:`Constraint AASd-090 <constraint_AASd-090>`
+VALID_CATEGORIES_FOR_DATA_ELEMENT: Set[str] = {"CONSTANT", "PARAMETER", "VARIABLE"}
+
+#: Enumeration of all identifiable elements within an asset administration shell.
+GENERIC_FRAGMENT_KEYS: Set[aas_types.KeyTypes] = {aas_types.KeyTypes.FRAGMENT_REFERENCE}
+
+#: Enumeration of different key value types within a key.
+GENERIC_GLOBALLY_IDENTIFIABLES: Set[aas_types.KeyTypes] = {
+    aas_types.KeyTypes.GLOBAL_REFERENCE
+}
+
+#: Enumeration of different key value types within a key.
+AAS_IDENTIFIABLES: Set[aas_types.KeyTypes] = {
+    aas_types.KeyTypes.ASSET_ADMINISTRATION_SHELL,
+    aas_types.KeyTypes.CONCEPT_DESCRIPTION,
+    aas_types.KeyTypes.IDENTIFIABLE,
+    aas_types.KeyTypes.SUBMODEL,
+}
+
+#: Enumeration of all submodel elements within an asset administration shell.
+AAS_SUBMODEL_ELEMENTS_AS_KEYS: Set[aas_types.KeyTypes] = {
+    aas_types.KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT,
+    aas_types.KeyTypes.BASIC_EVENT_ELEMENT,
+    aas_types.KeyTypes.BLOB,
+    aas_types.KeyTypes.CAPABILITY,
+    aas_types.KeyTypes.DATA_ELEMENT,
+    aas_types.KeyTypes.ENTITY,
+    aas_types.KeyTypes.EVENT_ELEMENT,
+    aas_types.KeyTypes.FILE,
+    aas_types.KeyTypes.MULTI_LANGUAGE_PROPERTY,
+    aas_types.KeyTypes.OPERATION,
+    aas_types.KeyTypes.PROPERTY,
+    aas_types.KeyTypes.RANGE,
+    aas_types.KeyTypes.REFERENCE_ELEMENT,
+    aas_types.KeyTypes.RELATIONSHIP_ELEMENT,
+    aas_types.KeyTypes.SUBMODEL_ELEMENT,
+    aas_types.KeyTypes.SUBMODEL_ELEMENT_COLLECTION,
+    aas_types.KeyTypes.SUBMODEL_ELEMENT_LIST,
+}
+
+#: Enumeration of different fragment key value types within a key.
+AAS_REFERABLE_NON_IDENTIFIABLES: Set[aas_types.KeyTypes] = {
+    aas_types.KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT,
+    aas_types.KeyTypes.BASIC_EVENT_ELEMENT,
+    aas_types.KeyTypes.BLOB,
+    aas_types.KeyTypes.CAPABILITY,
+    aas_types.KeyTypes.DATA_ELEMENT,
+    aas_types.KeyTypes.ENTITY,
+    aas_types.KeyTypes.EVENT_ELEMENT,
+    aas_types.KeyTypes.FILE,
+    aas_types.KeyTypes.MULTI_LANGUAGE_PROPERTY,
+    aas_types.KeyTypes.OPERATION,
+    aas_types.KeyTypes.PROPERTY,
+    aas_types.KeyTypes.RANGE,
+    aas_types.KeyTypes.REFERENCE_ELEMENT,
+    aas_types.KeyTypes.RELATIONSHIP_ELEMENT,
+    aas_types.KeyTypes.SUBMODEL_ELEMENT,
+    aas_types.KeyTypes.SUBMODEL_ELEMENT_COLLECTION,
+    aas_types.KeyTypes.SUBMODEL_ELEMENT_LIST,
+}
+
+#: Enumeration of referables. We need this to check that model references refer to a Referable. For example, the observed attribute of the Basic Event Element object must be a model reference to a Referable.
+AAS_REFERABLES: Set[aas_types.KeyTypes] = {
+    aas_types.KeyTypes.ASSET_ADMINISTRATION_SHELL,
+    aas_types.KeyTypes.CONCEPT_DESCRIPTION,
+    aas_types.KeyTypes.IDENTIFIABLE,
+    aas_types.KeyTypes.SUBMODEL,
+    aas_types.KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT,
+    aas_types.KeyTypes.BASIC_EVENT_ELEMENT,
+    aas_types.KeyTypes.BLOB,
+    aas_types.KeyTypes.CAPABILITY,
+    aas_types.KeyTypes.DATA_ELEMENT,
+    aas_types.KeyTypes.ENTITY,
+    aas_types.KeyTypes.EVENT_ELEMENT,
+    aas_types.KeyTypes.FILE,
+    aas_types.KeyTypes.MULTI_LANGUAGE_PROPERTY,
+    aas_types.KeyTypes.OPERATION,
+    aas_types.KeyTypes.PROPERTY,
+    aas_types.KeyTypes.RANGE,
+    aas_types.KeyTypes.REFERENCE_ELEMENT,
+    aas_types.KeyTypes.REFERABLE,
+    aas_types.KeyTypes.RELATIONSHIP_ELEMENT,
+    aas_types.KeyTypes.SUBMODEL_ELEMENT,
+    aas_types.KeyTypes.SUBMODEL_ELEMENT_COLLECTION,
+    aas_types.KeyTypes.SUBMODEL_ELEMENT_LIST,
+}
+
+#: Enumeration of all referable elements within an asset administration shell
+GLOBALLY_IDENTIFIABLES: Set[aas_types.KeyTypes] = {
+    aas_types.KeyTypes.GLOBAL_REFERENCE,
+    aas_types.KeyTypes.ASSET_ADMINISTRATION_SHELL,
+    aas_types.KeyTypes.CONCEPT_DESCRIPTION,
+    aas_types.KeyTypes.IDENTIFIABLE,
+    aas_types.KeyTypes.SUBMODEL,
+}
+
+#: Enumeration of different key value types within a key.
+FRAGMENT_KEYS: Set[aas_types.KeyTypes] = {
+    aas_types.KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT,
+    aas_types.KeyTypes.BASIC_EVENT_ELEMENT,
+    aas_types.KeyTypes.BLOB,
+    aas_types.KeyTypes.CAPABILITY,
+    aas_types.KeyTypes.DATA_ELEMENT,
+    aas_types.KeyTypes.ENTITY,
+    aas_types.KeyTypes.EVENT_ELEMENT,
+    aas_types.KeyTypes.FILE,
+    aas_types.KeyTypes.FRAGMENT_REFERENCE,
+    aas_types.KeyTypes.MULTI_LANGUAGE_PROPERTY,
+    aas_types.KeyTypes.OPERATION,
+    aas_types.KeyTypes.PROPERTY,
+    aas_types.KeyTypes.RANGE,
+    aas_types.KeyTypes.REFERENCE_ELEMENT,
+    aas_types.KeyTypes.RELATIONSHIP_ELEMENT,
+    aas_types.KeyTypes.SUBMODEL_ELEMENT,
+    aas_types.KeyTypes.SUBMODEL_ELEMENT_COLLECTION,
+    aas_types.KeyTypes.SUBMODEL_ELEMENT_LIST,
+}
+
+#: IEC 61360 data types for concept descriptions categorized with PROPERTY or VALUE.
+DATA_TYPE_IEC_61360_FOR_PROPERTY_OR_VALUE: Set[aas_types.DataTypeIEC61360] = {
+    aas_types.DataTypeIEC61360.DATE,
+    aas_types.DataTypeIEC61360.STRING,
+    aas_types.DataTypeIEC61360.STRING_TRANSLATABLE,
+    aas_types.DataTypeIEC61360.INTEGER_MEASURE,
+    aas_types.DataTypeIEC61360.INTEGER_COUNT,
+    aas_types.DataTypeIEC61360.INTEGER_CURRENCY,
+    aas_types.DataTypeIEC61360.REAL_MEASURE,
+    aas_types.DataTypeIEC61360.REAL_COUNT,
+    aas_types.DataTypeIEC61360.REAL_CURRENCY,
+    aas_types.DataTypeIEC61360.BOOLEAN,
+    aas_types.DataTypeIEC61360.RATIONAL,
+    aas_types.DataTypeIEC61360.RATIONAL_MEASURE,
+    aas_types.DataTypeIEC61360.TIME,
+    aas_types.DataTypeIEC61360.TIMESTAMP,
+}
+
+#: IEC 61360 data types for concept descriptions categorized with REFERENCE.
+DATA_TYPE_IEC_61360_FOR_REFERENCE: Set[aas_types.DataTypeIEC61360] = {
+    aas_types.DataTypeIEC61360.STRING,
+    aas_types.DataTypeIEC61360.IRI,
+    aas_types.DataTypeIEC61360.IRDI,
+}
+
+#: IEC 61360 data types for concept descriptions categorized with DOCUMENT.
+DATA_TYPE_IEC_61360_FOR_DOCUMENT: Set[aas_types.DataTypeIEC61360] = {
+    aas_types.DataTypeIEC61360.FILE,
+    aas_types.DataTypeIEC61360.BLOB,
+    aas_types.DataTypeIEC61360.HTML,
+}
+
+#: These data types imply that the unit is defined in the data specification.
+IEC_61360_DATA_TYPES_WITH_UNIT: Set[aas_types.DataTypeIEC61360] = {
+    aas_types.DataTypeIEC61360.INTEGER_MEASURE,
+    aas_types.DataTypeIEC61360.REAL_MEASURE,
+    aas_types.DataTypeIEC61360.RATIONAL_MEASURE,
+    aas_types.DataTypeIEC61360.INTEGER_CURRENCY,
+    aas_types.DataTypeIEC61360.REAL_CURRENCY,
+}
+
+# This code has been automatically generated by aas-core-codegen.
+# Do NOT edit or append.
```

### Comparing `aas-core3.0-1.0.0rc1/aas_core3/stringification.py` & `aas-core3.0-1.0.0rc2/aas_core3/stringification.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,345 +1,345 @@
-"""De-serialize enumerations from string representations."""
-
-
-# This code has been automatically generated by aas-core-codegen.
-# Do NOT edit or append.
-
-
-from typing import (
-    Mapping,
-    Optional,
-)
-
-import aas_core3.types as aas_types
-
-
-_MODELLING_KIND_FROM_STR: Mapping[str, aas_types.ModellingKind] = {
-    "Template": aas_types.ModellingKind.TEMPLATE,
-    "Instance": aas_types.ModellingKind.INSTANCE,
-}
-
-
-def modelling_kind_from_str(text: str) -> Optional[aas_types.ModellingKind]:
-    """
-    Parse :paramref:`text` as string representation
-    of :py:class:`aas_core3.ModellingKind`.
-
-    If :paramref:`text` is not a valid string representation of a literal
-    of :py:class:`aas_core3.ModellingKind`, return ``None``.
-
-    :param text: to be parsed
-    :return:
-        the corresponding literal of :py:class:`aas_core3.ModellingKind`
-        or ``None``, if :paramref:`text` invalid.
-    """
-    return _MODELLING_KIND_FROM_STR.get(text, None)
-
-
-_QUALIFIER_KIND_FROM_STR: Mapping[str, aas_types.QualifierKind] = {
-    "ValueQualifier": aas_types.QualifierKind.VALUE_QUALIFIER,
-    "ConceptQualifier": aas_types.QualifierKind.CONCEPT_QUALIFIER,
-    "TemplateQualifier": aas_types.QualifierKind.TEMPLATE_QUALIFIER,
-}
-
-
-def qualifier_kind_from_str(text: str) -> Optional[aas_types.QualifierKind]:
-    """
-    Parse :paramref:`text` as string representation
-    of :py:class:`aas_core3.QualifierKind`.
-
-    If :paramref:`text` is not a valid string representation of a literal
-    of :py:class:`aas_core3.QualifierKind`, return ``None``.
-
-    :param text: to be parsed
-    :return:
-        the corresponding literal of :py:class:`aas_core3.QualifierKind`
-        or ``None``, if :paramref:`text` invalid.
-    """
-    return _QUALIFIER_KIND_FROM_STR.get(text, None)
-
-
-_ASSET_KIND_FROM_STR: Mapping[str, aas_types.AssetKind] = {
-    "Type": aas_types.AssetKind.TYPE,
-    "Instance": aas_types.AssetKind.INSTANCE,
-    "NotApplicable": aas_types.AssetKind.NOT_APPLICABLE,
-}
-
-
-def asset_kind_from_str(text: str) -> Optional[aas_types.AssetKind]:
-    """
-    Parse :paramref:`text` as string representation
-    of :py:class:`aas_core3.AssetKind`.
-
-    If :paramref:`text` is not a valid string representation of a literal
-    of :py:class:`aas_core3.AssetKind`, return ``None``.
-
-    :param text: to be parsed
-    :return:
-        the corresponding literal of :py:class:`aas_core3.AssetKind`
-        or ``None``, if :paramref:`text` invalid.
-    """
-    return _ASSET_KIND_FROM_STR.get(text, None)
-
-
-_AAS_SUBMODEL_ELEMENTS_FROM_STR: Mapping[str, aas_types.AASSubmodelElements] = {
-    "AnnotatedRelationshipElement": aas_types.AASSubmodelElements.ANNOTATED_RELATIONSHIP_ELEMENT,
-    "BasicEventElement": aas_types.AASSubmodelElements.BASIC_EVENT_ELEMENT,
-    "Blob": aas_types.AASSubmodelElements.BLOB,
-    "Capability": aas_types.AASSubmodelElements.CAPABILITY,
-    "DataElement": aas_types.AASSubmodelElements.DATA_ELEMENT,
-    "Entity": aas_types.AASSubmodelElements.ENTITY,
-    "EventElement": aas_types.AASSubmodelElements.EVENT_ELEMENT,
-    "File": aas_types.AASSubmodelElements.FILE,
-    "MultiLanguageProperty": aas_types.AASSubmodelElements.MULTI_LANGUAGE_PROPERTY,
-    "Operation": aas_types.AASSubmodelElements.OPERATION,
-    "Property": aas_types.AASSubmodelElements.PROPERTY,
-    "Range": aas_types.AASSubmodelElements.RANGE,
-    "ReferenceElement": aas_types.AASSubmodelElements.REFERENCE_ELEMENT,
-    "RelationshipElement": aas_types.AASSubmodelElements.RELATIONSHIP_ELEMENT,
-    "SubmodelElement": aas_types.AASSubmodelElements.SUBMODEL_ELEMENT,
-    "SubmodelElementList": aas_types.AASSubmodelElements.SUBMODEL_ELEMENT_LIST,
-    "SubmodelElementCollection": aas_types.AASSubmodelElements.SUBMODEL_ELEMENT_COLLECTION,
-}
-
-
-def aas_submodel_elements_from_str(
-    text: str,
-) -> Optional[aas_types.AASSubmodelElements]:
-    """
-    Parse :paramref:`text` as string representation
-    of :py:class:`aas_core3.AASSubmodelElements`.
-
-    If :paramref:`text` is not a valid string representation of a literal
-    of :py:class:`aas_core3.AASSubmodelElements`, return ``None``.
-
-    :param text: to be parsed
-    :return:
-        the corresponding literal of :py:class:`aas_core3.AASSubmodelElements`
-        or ``None``, if :paramref:`text` invalid.
-    """
-    return _AAS_SUBMODEL_ELEMENTS_FROM_STR.get(text, None)
-
-
-_ENTITY_TYPE_FROM_STR: Mapping[str, aas_types.EntityType] = {
-    "CoManagedEntity": aas_types.EntityType.CO_MANAGED_ENTITY,
-    "SelfManagedEntity": aas_types.EntityType.SELF_MANAGED_ENTITY,
-}
-
-
-def entity_type_from_str(text: str) -> Optional[aas_types.EntityType]:
-    """
-    Parse :paramref:`text` as string representation
-    of :py:class:`aas_core3.EntityType`.
-
-    If :paramref:`text` is not a valid string representation of a literal
-    of :py:class:`aas_core3.EntityType`, return ``None``.
-
-    :param text: to be parsed
-    :return:
-        the corresponding literal of :py:class:`aas_core3.EntityType`
-        or ``None``, if :paramref:`text` invalid.
-    """
-    return _ENTITY_TYPE_FROM_STR.get(text, None)
-
-
-_DIRECTION_FROM_STR: Mapping[str, aas_types.Direction] = {
-    "input": aas_types.Direction.INPUT,
-    "output": aas_types.Direction.OUTPUT,
-}
-
-
-def direction_from_str(text: str) -> Optional[aas_types.Direction]:
-    """
-    Parse :paramref:`text` as string representation
-    of :py:class:`aas_core3.Direction`.
-
-    If :paramref:`text` is not a valid string representation of a literal
-    of :py:class:`aas_core3.Direction`, return ``None``.
-
-    :param text: to be parsed
-    :return:
-        the corresponding literal of :py:class:`aas_core3.Direction`
-        or ``None``, if :paramref:`text` invalid.
-    """
-    return _DIRECTION_FROM_STR.get(text, None)
-
-
-_STATE_OF_EVENT_FROM_STR: Mapping[str, aas_types.StateOfEvent] = {
-    "on": aas_types.StateOfEvent.ON,
-    "off": aas_types.StateOfEvent.OFF,
-}
-
-
-def state_of_event_from_str(text: str) -> Optional[aas_types.StateOfEvent]:
-    """
-    Parse :paramref:`text` as string representation
-    of :py:class:`aas_core3.StateOfEvent`.
-
-    If :paramref:`text` is not a valid string representation of a literal
-    of :py:class:`aas_core3.StateOfEvent`, return ``None``.
-
-    :param text: to be parsed
-    :return:
-        the corresponding literal of :py:class:`aas_core3.StateOfEvent`
-        or ``None``, if :paramref:`text` invalid.
-    """
-    return _STATE_OF_EVENT_FROM_STR.get(text, None)
-
-
-_REFERENCE_TYPES_FROM_STR: Mapping[str, aas_types.ReferenceTypes] = {
-    "ExternalReference": aas_types.ReferenceTypes.EXTERNAL_REFERENCE,
-    "ModelReference": aas_types.ReferenceTypes.MODEL_REFERENCE,
-}
-
-
-def reference_types_from_str(text: str) -> Optional[aas_types.ReferenceTypes]:
-    """
-    Parse :paramref:`text` as string representation
-    of :py:class:`aas_core3.ReferenceTypes`.
-
-    If :paramref:`text` is not a valid string representation of a literal
-    of :py:class:`aas_core3.ReferenceTypes`, return ``None``.
-
-    :param text: to be parsed
-    :return:
-        the corresponding literal of :py:class:`aas_core3.ReferenceTypes`
-        or ``None``, if :paramref:`text` invalid.
-    """
-    return _REFERENCE_TYPES_FROM_STR.get(text, None)
-
-
-_KEY_TYPES_FROM_STR: Mapping[str, aas_types.KeyTypes] = {
-    "AnnotatedRelationshipElement": aas_types.KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT,
-    "AssetAdministrationShell": aas_types.KeyTypes.ASSET_ADMINISTRATION_SHELL,
-    "BasicEventElement": aas_types.KeyTypes.BASIC_EVENT_ELEMENT,
-    "Blob": aas_types.KeyTypes.BLOB,
-    "Capability": aas_types.KeyTypes.CAPABILITY,
-    "ConceptDescription": aas_types.KeyTypes.CONCEPT_DESCRIPTION,
-    "DataElement": aas_types.KeyTypes.DATA_ELEMENT,
-    "Entity": aas_types.KeyTypes.ENTITY,
-    "EventElement": aas_types.KeyTypes.EVENT_ELEMENT,
-    "File": aas_types.KeyTypes.FILE,
-    "FragmentReference": aas_types.KeyTypes.FRAGMENT_REFERENCE,
-    "GlobalReference": aas_types.KeyTypes.GLOBAL_REFERENCE,
-    "Identifiable": aas_types.KeyTypes.IDENTIFIABLE,
-    "MultiLanguageProperty": aas_types.KeyTypes.MULTI_LANGUAGE_PROPERTY,
-    "Operation": aas_types.KeyTypes.OPERATION,
-    "Property": aas_types.KeyTypes.PROPERTY,
-    "Range": aas_types.KeyTypes.RANGE,
-    "Referable": aas_types.KeyTypes.REFERABLE,
-    "ReferenceElement": aas_types.KeyTypes.REFERENCE_ELEMENT,
-    "RelationshipElement": aas_types.KeyTypes.RELATIONSHIP_ELEMENT,
-    "Submodel": aas_types.KeyTypes.SUBMODEL,
-    "SubmodelElement": aas_types.KeyTypes.SUBMODEL_ELEMENT,
-    "SubmodelElementCollection": aas_types.KeyTypes.SUBMODEL_ELEMENT_COLLECTION,
-    "SubmodelElementList": aas_types.KeyTypes.SUBMODEL_ELEMENT_LIST,
-}
-
-
-def key_types_from_str(text: str) -> Optional[aas_types.KeyTypes]:
-    """
-    Parse :paramref:`text` as string representation
-    of :py:class:`aas_core3.KeyTypes`.
-
-    If :paramref:`text` is not a valid string representation of a literal
-    of :py:class:`aas_core3.KeyTypes`, return ``None``.
-
-    :param text: to be parsed
-    :return:
-        the corresponding literal of :py:class:`aas_core3.KeyTypes`
-        or ``None``, if :paramref:`text` invalid.
-    """
-    return _KEY_TYPES_FROM_STR.get(text, None)
-
-
-_DATA_TYPE_DEF_XSD_FROM_STR: Mapping[str, aas_types.DataTypeDefXSD] = {
-    "xs:anyURI": aas_types.DataTypeDefXSD.ANY_URI,
-    "xs:base64Binary": aas_types.DataTypeDefXSD.BASE_64_BINARY,
-    "xs:boolean": aas_types.DataTypeDefXSD.BOOLEAN,
-    "xs:byte": aas_types.DataTypeDefXSD.BYTE,
-    "xs:date": aas_types.DataTypeDefXSD.DATE,
-    "xs:dateTime": aas_types.DataTypeDefXSD.DATE_TIME,
-    "xs:decimal": aas_types.DataTypeDefXSD.DECIMAL,
-    "xs:double": aas_types.DataTypeDefXSD.DOUBLE,
-    "xs:duration": aas_types.DataTypeDefXSD.DURATION,
-    "xs:float": aas_types.DataTypeDefXSD.FLOAT,
-    "xs:gDay": aas_types.DataTypeDefXSD.G_DAY,
-    "xs:gMonth": aas_types.DataTypeDefXSD.G_MONTH,
-    "xs:gMonthDay": aas_types.DataTypeDefXSD.G_MONTH_DAY,
-    "xs:gYear": aas_types.DataTypeDefXSD.G_YEAR,
-    "xs:gYearMonth": aas_types.DataTypeDefXSD.G_YEAR_MONTH,
-    "xs:hexBinary": aas_types.DataTypeDefXSD.HEX_BINARY,
-    "xs:int": aas_types.DataTypeDefXSD.INT,
-    "xs:integer": aas_types.DataTypeDefXSD.INTEGER,
-    "xs:long": aas_types.DataTypeDefXSD.LONG,
-    "xs:negativeInteger": aas_types.DataTypeDefXSD.NEGATIVE_INTEGER,
-    "xs:nonNegativeInteger": aas_types.DataTypeDefXSD.NON_NEGATIVE_INTEGER,
-    "xs:nonPositiveInteger": aas_types.DataTypeDefXSD.NON_POSITIVE_INTEGER,
-    "xs:positiveInteger": aas_types.DataTypeDefXSD.POSITIVE_INTEGER,
-    "xs:short": aas_types.DataTypeDefXSD.SHORT,
-    "xs:string": aas_types.DataTypeDefXSD.STRING,
-    "xs:time": aas_types.DataTypeDefXSD.TIME,
-    "xs:unsignedByte": aas_types.DataTypeDefXSD.UNSIGNED_BYTE,
-    "xs:unsignedInt": aas_types.DataTypeDefXSD.UNSIGNED_INT,
-    "xs:unsignedLong": aas_types.DataTypeDefXSD.UNSIGNED_LONG,
-    "xs:unsignedShort": aas_types.DataTypeDefXSD.UNSIGNED_SHORT,
-}
-
-
-def data_type_def_xsd_from_str(text: str) -> Optional[aas_types.DataTypeDefXSD]:
-    """
-    Parse :paramref:`text` as string representation
-    of :py:class:`aas_core3.DataTypeDefXSD`.
-
-    If :paramref:`text` is not a valid string representation of a literal
-    of :py:class:`aas_core3.DataTypeDefXSD`, return ``None``.
-
-    :param text: to be parsed
-    :return:
-        the corresponding literal of :py:class:`aas_core3.DataTypeDefXSD`
-        or ``None``, if :paramref:`text` invalid.
-    """
-    return _DATA_TYPE_DEF_XSD_FROM_STR.get(text, None)
-
-
-_DATA_TYPE_IEC_61360_FROM_STR: Mapping[str, aas_types.DataTypeIEC61360] = {
-    "DATE": aas_types.DataTypeIEC61360.DATE,
-    "STRING": aas_types.DataTypeIEC61360.STRING,
-    "STRING_TRANSLATABLE": aas_types.DataTypeIEC61360.STRING_TRANSLATABLE,
-    "INTEGER_MEASURE": aas_types.DataTypeIEC61360.INTEGER_MEASURE,
-    "INTEGER_COUNT": aas_types.DataTypeIEC61360.INTEGER_COUNT,
-    "INTEGER_CURRENCY": aas_types.DataTypeIEC61360.INTEGER_CURRENCY,
-    "REAL_MEASURE": aas_types.DataTypeIEC61360.REAL_MEASURE,
-    "REAL_COUNT": aas_types.DataTypeIEC61360.REAL_COUNT,
-    "REAL_CURRENCY": aas_types.DataTypeIEC61360.REAL_CURRENCY,
-    "BOOLEAN": aas_types.DataTypeIEC61360.BOOLEAN,
-    "IRI": aas_types.DataTypeIEC61360.IRI,
-    "IRDI": aas_types.DataTypeIEC61360.IRDI,
-    "RATIONAL": aas_types.DataTypeIEC61360.RATIONAL,
-    "RATIONAL_MEASURE": aas_types.DataTypeIEC61360.RATIONAL_MEASURE,
-    "TIME": aas_types.DataTypeIEC61360.TIME,
-    "TIMESTAMP": aas_types.DataTypeIEC61360.TIMESTAMP,
-    "FILE": aas_types.DataTypeIEC61360.FILE,
-    "HTML": aas_types.DataTypeIEC61360.HTML,
-    "BLOB": aas_types.DataTypeIEC61360.BLOB,
-}
-
-
-def data_type_iec_61360_from_str(text: str) -> Optional[aas_types.DataTypeIEC61360]:
-    """
-    Parse :paramref:`text` as string representation
-    of :py:class:`aas_core3.DataTypeIEC61360`.
-
-    If :paramref:`text` is not a valid string representation of a literal
-    of :py:class:`aas_core3.DataTypeIEC61360`, return ``None``.
-
-    :param text: to be parsed
-    :return:
-        the corresponding literal of :py:class:`aas_core3.DataTypeIEC61360`
-        or ``None``, if :paramref:`text` invalid.
-    """
-    return _DATA_TYPE_IEC_61360_FROM_STR.get(text, None)
-
-
-# This code has been automatically generated by aas-core-codegen.
-# Do NOT edit or append.
+"""De-serialize enumerations from string representations."""
+
+
+# This code has been automatically generated by aas-core-codegen.
+# Do NOT edit or append.
+
+
+from typing import (
+    Mapping,
+    Optional,
+)
+
+import aas_core3.types as aas_types
+
+
+_MODELLING_KIND_FROM_STR: Mapping[str, aas_types.ModellingKind] = {
+    "Template": aas_types.ModellingKind.TEMPLATE,
+    "Instance": aas_types.ModellingKind.INSTANCE,
+}
+
+
+def modelling_kind_from_str(text: str) -> Optional[aas_types.ModellingKind]:
+    """
+    Parse :paramref:`text` as string representation
+    of :py:class:`aas_core3.ModellingKind`.
+
+    If :paramref:`text` is not a valid string representation of a literal
+    of :py:class:`aas_core3.ModellingKind`, return ``None``.
+
+    :param text: to be parsed
+    :return:
+        the corresponding literal of :py:class:`aas_core3.ModellingKind`
+        or ``None``, if :paramref:`text` invalid.
+    """
+    return _MODELLING_KIND_FROM_STR.get(text, None)
+
+
+_QUALIFIER_KIND_FROM_STR: Mapping[str, aas_types.QualifierKind] = {
+    "ValueQualifier": aas_types.QualifierKind.VALUE_QUALIFIER,
+    "ConceptQualifier": aas_types.QualifierKind.CONCEPT_QUALIFIER,
+    "TemplateQualifier": aas_types.QualifierKind.TEMPLATE_QUALIFIER,
+}
+
+
+def qualifier_kind_from_str(text: str) -> Optional[aas_types.QualifierKind]:
+    """
+    Parse :paramref:`text` as string representation
+    of :py:class:`aas_core3.QualifierKind`.
+
+    If :paramref:`text` is not a valid string representation of a literal
+    of :py:class:`aas_core3.QualifierKind`, return ``None``.
+
+    :param text: to be parsed
+    :return:
+        the corresponding literal of :py:class:`aas_core3.QualifierKind`
+        or ``None``, if :paramref:`text` invalid.
+    """
+    return _QUALIFIER_KIND_FROM_STR.get(text, None)
+
+
+_ASSET_KIND_FROM_STR: Mapping[str, aas_types.AssetKind] = {
+    "Type": aas_types.AssetKind.TYPE,
+    "Instance": aas_types.AssetKind.INSTANCE,
+    "NotApplicable": aas_types.AssetKind.NOT_APPLICABLE,
+}
+
+
+def asset_kind_from_str(text: str) -> Optional[aas_types.AssetKind]:
+    """
+    Parse :paramref:`text` as string representation
+    of :py:class:`aas_core3.AssetKind`.
+
+    If :paramref:`text` is not a valid string representation of a literal
+    of :py:class:`aas_core3.AssetKind`, return ``None``.
+
+    :param text: to be parsed
+    :return:
+        the corresponding literal of :py:class:`aas_core3.AssetKind`
+        or ``None``, if :paramref:`text` invalid.
+    """
+    return _ASSET_KIND_FROM_STR.get(text, None)
+
+
+_AAS_SUBMODEL_ELEMENTS_FROM_STR: Mapping[str, aas_types.AASSubmodelElements] = {
+    "AnnotatedRelationshipElement": aas_types.AASSubmodelElements.ANNOTATED_RELATIONSHIP_ELEMENT,
+    "BasicEventElement": aas_types.AASSubmodelElements.BASIC_EVENT_ELEMENT,
+    "Blob": aas_types.AASSubmodelElements.BLOB,
+    "Capability": aas_types.AASSubmodelElements.CAPABILITY,
+    "DataElement": aas_types.AASSubmodelElements.DATA_ELEMENT,
+    "Entity": aas_types.AASSubmodelElements.ENTITY,
+    "EventElement": aas_types.AASSubmodelElements.EVENT_ELEMENT,
+    "File": aas_types.AASSubmodelElements.FILE,
+    "MultiLanguageProperty": aas_types.AASSubmodelElements.MULTI_LANGUAGE_PROPERTY,
+    "Operation": aas_types.AASSubmodelElements.OPERATION,
+    "Property": aas_types.AASSubmodelElements.PROPERTY,
+    "Range": aas_types.AASSubmodelElements.RANGE,
+    "ReferenceElement": aas_types.AASSubmodelElements.REFERENCE_ELEMENT,
+    "RelationshipElement": aas_types.AASSubmodelElements.RELATIONSHIP_ELEMENT,
+    "SubmodelElement": aas_types.AASSubmodelElements.SUBMODEL_ELEMENT,
+    "SubmodelElementList": aas_types.AASSubmodelElements.SUBMODEL_ELEMENT_LIST,
+    "SubmodelElementCollection": aas_types.AASSubmodelElements.SUBMODEL_ELEMENT_COLLECTION,
+}
+
+
+def aas_submodel_elements_from_str(
+    text: str,
+) -> Optional[aas_types.AASSubmodelElements]:
+    """
+    Parse :paramref:`text` as string representation
+    of :py:class:`aas_core3.AASSubmodelElements`.
+
+    If :paramref:`text` is not a valid string representation of a literal
+    of :py:class:`aas_core3.AASSubmodelElements`, return ``None``.
+
+    :param text: to be parsed
+    :return:
+        the corresponding literal of :py:class:`aas_core3.AASSubmodelElements`
+        or ``None``, if :paramref:`text` invalid.
+    """
+    return _AAS_SUBMODEL_ELEMENTS_FROM_STR.get(text, None)
+
+
+_ENTITY_TYPE_FROM_STR: Mapping[str, aas_types.EntityType] = {
+    "CoManagedEntity": aas_types.EntityType.CO_MANAGED_ENTITY,
+    "SelfManagedEntity": aas_types.EntityType.SELF_MANAGED_ENTITY,
+}
+
+
+def entity_type_from_str(text: str) -> Optional[aas_types.EntityType]:
+    """
+    Parse :paramref:`text` as string representation
+    of :py:class:`aas_core3.EntityType`.
+
+    If :paramref:`text` is not a valid string representation of a literal
+    of :py:class:`aas_core3.EntityType`, return ``None``.
+
+    :param text: to be parsed
+    :return:
+        the corresponding literal of :py:class:`aas_core3.EntityType`
+        or ``None``, if :paramref:`text` invalid.
+    """
+    return _ENTITY_TYPE_FROM_STR.get(text, None)
+
+
+_DIRECTION_FROM_STR: Mapping[str, aas_types.Direction] = {
+    "input": aas_types.Direction.INPUT,
+    "output": aas_types.Direction.OUTPUT,
+}
+
+
+def direction_from_str(text: str) -> Optional[aas_types.Direction]:
+    """
+    Parse :paramref:`text` as string representation
+    of :py:class:`aas_core3.Direction`.
+
+    If :paramref:`text` is not a valid string representation of a literal
+    of :py:class:`aas_core3.Direction`, return ``None``.
+
+    :param text: to be parsed
+    :return:
+        the corresponding literal of :py:class:`aas_core3.Direction`
+        or ``None``, if :paramref:`text` invalid.
+    """
+    return _DIRECTION_FROM_STR.get(text, None)
+
+
+_STATE_OF_EVENT_FROM_STR: Mapping[str, aas_types.StateOfEvent] = {
+    "on": aas_types.StateOfEvent.ON,
+    "off": aas_types.StateOfEvent.OFF,
+}
+
+
+def state_of_event_from_str(text: str) -> Optional[aas_types.StateOfEvent]:
+    """
+    Parse :paramref:`text` as string representation
+    of :py:class:`aas_core3.StateOfEvent`.
+
+    If :paramref:`text` is not a valid string representation of a literal
+    of :py:class:`aas_core3.StateOfEvent`, return ``None``.
+
+    :param text: to be parsed
+    :return:
+        the corresponding literal of :py:class:`aas_core3.StateOfEvent`
+        or ``None``, if :paramref:`text` invalid.
+    """
+    return _STATE_OF_EVENT_FROM_STR.get(text, None)
+
+
+_REFERENCE_TYPES_FROM_STR: Mapping[str, aas_types.ReferenceTypes] = {
+    "ExternalReference": aas_types.ReferenceTypes.EXTERNAL_REFERENCE,
+    "ModelReference": aas_types.ReferenceTypes.MODEL_REFERENCE,
+}
+
+
+def reference_types_from_str(text: str) -> Optional[aas_types.ReferenceTypes]:
+    """
+    Parse :paramref:`text` as string representation
+    of :py:class:`aas_core3.ReferenceTypes`.
+
+    If :paramref:`text` is not a valid string representation of a literal
+    of :py:class:`aas_core3.ReferenceTypes`, return ``None``.
+
+    :param text: to be parsed
+    :return:
+        the corresponding literal of :py:class:`aas_core3.ReferenceTypes`
+        or ``None``, if :paramref:`text` invalid.
+    """
+    return _REFERENCE_TYPES_FROM_STR.get(text, None)
+
+
+_KEY_TYPES_FROM_STR: Mapping[str, aas_types.KeyTypes] = {
+    "AnnotatedRelationshipElement": aas_types.KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT,
+    "AssetAdministrationShell": aas_types.KeyTypes.ASSET_ADMINISTRATION_SHELL,
+    "BasicEventElement": aas_types.KeyTypes.BASIC_EVENT_ELEMENT,
+    "Blob": aas_types.KeyTypes.BLOB,
+    "Capability": aas_types.KeyTypes.CAPABILITY,
+    "ConceptDescription": aas_types.KeyTypes.CONCEPT_DESCRIPTION,
+    "DataElement": aas_types.KeyTypes.DATA_ELEMENT,
+    "Entity": aas_types.KeyTypes.ENTITY,
+    "EventElement": aas_types.KeyTypes.EVENT_ELEMENT,
+    "File": aas_types.KeyTypes.FILE,
+    "FragmentReference": aas_types.KeyTypes.FRAGMENT_REFERENCE,
+    "GlobalReference": aas_types.KeyTypes.GLOBAL_REFERENCE,
+    "Identifiable": aas_types.KeyTypes.IDENTIFIABLE,
+    "MultiLanguageProperty": aas_types.KeyTypes.MULTI_LANGUAGE_PROPERTY,
+    "Operation": aas_types.KeyTypes.OPERATION,
+    "Property": aas_types.KeyTypes.PROPERTY,
+    "Range": aas_types.KeyTypes.RANGE,
+    "Referable": aas_types.KeyTypes.REFERABLE,
+    "ReferenceElement": aas_types.KeyTypes.REFERENCE_ELEMENT,
+    "RelationshipElement": aas_types.KeyTypes.RELATIONSHIP_ELEMENT,
+    "Submodel": aas_types.KeyTypes.SUBMODEL,
+    "SubmodelElement": aas_types.KeyTypes.SUBMODEL_ELEMENT,
+    "SubmodelElementCollection": aas_types.KeyTypes.SUBMODEL_ELEMENT_COLLECTION,
+    "SubmodelElementList": aas_types.KeyTypes.SUBMODEL_ELEMENT_LIST,
+}
+
+
+def key_types_from_str(text: str) -> Optional[aas_types.KeyTypes]:
+    """
+    Parse :paramref:`text` as string representation
+    of :py:class:`aas_core3.KeyTypes`.
+
+    If :paramref:`text` is not a valid string representation of a literal
+    of :py:class:`aas_core3.KeyTypes`, return ``None``.
+
+    :param text: to be parsed
+    :return:
+        the corresponding literal of :py:class:`aas_core3.KeyTypes`
+        or ``None``, if :paramref:`text` invalid.
+    """
+    return _KEY_TYPES_FROM_STR.get(text, None)
+
+
+_DATA_TYPE_DEF_XSD_FROM_STR: Mapping[str, aas_types.DataTypeDefXSD] = {
+    "xs:anyURI": aas_types.DataTypeDefXSD.ANY_URI,
+    "xs:base64Binary": aas_types.DataTypeDefXSD.BASE_64_BINARY,
+    "xs:boolean": aas_types.DataTypeDefXSD.BOOLEAN,
+    "xs:byte": aas_types.DataTypeDefXSD.BYTE,
+    "xs:date": aas_types.DataTypeDefXSD.DATE,
+    "xs:dateTime": aas_types.DataTypeDefXSD.DATE_TIME,
+    "xs:decimal": aas_types.DataTypeDefXSD.DECIMAL,
+    "xs:double": aas_types.DataTypeDefXSD.DOUBLE,
+    "xs:duration": aas_types.DataTypeDefXSD.DURATION,
+    "xs:float": aas_types.DataTypeDefXSD.FLOAT,
+    "xs:gDay": aas_types.DataTypeDefXSD.G_DAY,
+    "xs:gMonth": aas_types.DataTypeDefXSD.G_MONTH,
+    "xs:gMonthDay": aas_types.DataTypeDefXSD.G_MONTH_DAY,
+    "xs:gYear": aas_types.DataTypeDefXSD.G_YEAR,
+    "xs:gYearMonth": aas_types.DataTypeDefXSD.G_YEAR_MONTH,
+    "xs:hexBinary": aas_types.DataTypeDefXSD.HEX_BINARY,
+    "xs:int": aas_types.DataTypeDefXSD.INT,
+    "xs:integer": aas_types.DataTypeDefXSD.INTEGER,
+    "xs:long": aas_types.DataTypeDefXSD.LONG,
+    "xs:negativeInteger": aas_types.DataTypeDefXSD.NEGATIVE_INTEGER,
+    "xs:nonNegativeInteger": aas_types.DataTypeDefXSD.NON_NEGATIVE_INTEGER,
+    "xs:nonPositiveInteger": aas_types.DataTypeDefXSD.NON_POSITIVE_INTEGER,
+    "xs:positiveInteger": aas_types.DataTypeDefXSD.POSITIVE_INTEGER,
+    "xs:short": aas_types.DataTypeDefXSD.SHORT,
+    "xs:string": aas_types.DataTypeDefXSD.STRING,
+    "xs:time": aas_types.DataTypeDefXSD.TIME,
+    "xs:unsignedByte": aas_types.DataTypeDefXSD.UNSIGNED_BYTE,
+    "xs:unsignedInt": aas_types.DataTypeDefXSD.UNSIGNED_INT,
+    "xs:unsignedLong": aas_types.DataTypeDefXSD.UNSIGNED_LONG,
+    "xs:unsignedShort": aas_types.DataTypeDefXSD.UNSIGNED_SHORT,
+}
+
+
+def data_type_def_xsd_from_str(text: str) -> Optional[aas_types.DataTypeDefXSD]:
+    """
+    Parse :paramref:`text` as string representation
+    of :py:class:`aas_core3.DataTypeDefXSD`.
+
+    If :paramref:`text` is not a valid string representation of a literal
+    of :py:class:`aas_core3.DataTypeDefXSD`, return ``None``.
+
+    :param text: to be parsed
+    :return:
+        the corresponding literal of :py:class:`aas_core3.DataTypeDefXSD`
+        or ``None``, if :paramref:`text` invalid.
+    """
+    return _DATA_TYPE_DEF_XSD_FROM_STR.get(text, None)
+
+
+_DATA_TYPE_IEC_61360_FROM_STR: Mapping[str, aas_types.DataTypeIEC61360] = {
+    "DATE": aas_types.DataTypeIEC61360.DATE,
+    "STRING": aas_types.DataTypeIEC61360.STRING,
+    "STRING_TRANSLATABLE": aas_types.DataTypeIEC61360.STRING_TRANSLATABLE,
+    "INTEGER_MEASURE": aas_types.DataTypeIEC61360.INTEGER_MEASURE,
+    "INTEGER_COUNT": aas_types.DataTypeIEC61360.INTEGER_COUNT,
+    "INTEGER_CURRENCY": aas_types.DataTypeIEC61360.INTEGER_CURRENCY,
+    "REAL_MEASURE": aas_types.DataTypeIEC61360.REAL_MEASURE,
+    "REAL_COUNT": aas_types.DataTypeIEC61360.REAL_COUNT,
+    "REAL_CURRENCY": aas_types.DataTypeIEC61360.REAL_CURRENCY,
+    "BOOLEAN": aas_types.DataTypeIEC61360.BOOLEAN,
+    "IRI": aas_types.DataTypeIEC61360.IRI,
+    "IRDI": aas_types.DataTypeIEC61360.IRDI,
+    "RATIONAL": aas_types.DataTypeIEC61360.RATIONAL,
+    "RATIONAL_MEASURE": aas_types.DataTypeIEC61360.RATIONAL_MEASURE,
+    "TIME": aas_types.DataTypeIEC61360.TIME,
+    "TIMESTAMP": aas_types.DataTypeIEC61360.TIMESTAMP,
+    "FILE": aas_types.DataTypeIEC61360.FILE,
+    "HTML": aas_types.DataTypeIEC61360.HTML,
+    "BLOB": aas_types.DataTypeIEC61360.BLOB,
+}
+
+
+def data_type_iec_61360_from_str(text: str) -> Optional[aas_types.DataTypeIEC61360]:
+    """
+    Parse :paramref:`text` as string representation
+    of :py:class:`aas_core3.DataTypeIEC61360`.
+
+    If :paramref:`text` is not a valid string representation of a literal
+    of :py:class:`aas_core3.DataTypeIEC61360`, return ``None``.
+
+    :param text: to be parsed
+    :return:
+        the corresponding literal of :py:class:`aas_core3.DataTypeIEC61360`
+        or ``None``, if :paramref:`text` invalid.
+    """
+    return _DATA_TYPE_IEC_61360_FROM_STR.get(text, None)
+
+
+# This code has been automatically generated by aas-core-codegen.
+# Do NOT edit or append.
```

### Comparing `aas-core3.0-1.0.0rc1/aas_core3/types.py` & `aas-core3.0-1.0.0rc2/aas_core3/types.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,7850 +1,7923 @@
-"""
-Provide an implementation of the Asset Administration Shell (AAS) V3.0.
-
-The presented version of the Metamodel is related to the work of
-aas-core-works, which can be found here: https://github.com/aas-core-works.
-
-The presented content is neither related to the IDTA nor
-Plattform Industrie 4.0 and does not represent an official publication.
-
-We diverge from the book in the following points.
-
-We did not implement the following constraints as they are too general and can not
-be formalized as part of the core library, but affects external components such as
-AAS registry or AAS server:
-
-We did not implement the following constraints since they depend on registry and
-de-referencing, so we can not formalize them with formalizing such external
-dependencies:
-
-* :ref:`Constraint AASd-006 <constraint_AASd-006>`
-* :ref:`Constraint AASd-007 <constraint_AASd-007>`
-
-Some constraints are not enforceable as they depend on the wider context
-such as language understanding, so we could not formalize them:
-
-* :ref:`Constraint AASd-012 <constraint_AASd-012>`
-* :ref:`Constraint AASd-116 <constraint_AASd-116>`: In the book, :ref:`Constraint AASd-116 <constraint_AASd-116>` imposes a
-  case-insensitive equality against ``globalAssetId``. This is culturally-dependent,
-  and depends on the system settings. For example, the case-folding
-  for the letters "i" and "I" is different in Turkish from English.
-
-  We implement the constraint as case-sensitive instead to allow for interoperability
-  across different culture settings.
-
-Furthermore, we diverge from the book in the following points regarding
-the enumerations. We have to implement subsets of enumerations as sets as common
-programming languages do not support inheritance of enumerations. The relationship
-between the properties and the sets is defined through invariants. This causes
-the following divergences:
-
-* We decided therefore to remove the enumerations ``DataTypeDef`` and ``DataTypeDefRDF``
-  and keep only :py:class:`DataTypeDefXSD` as enumeration. Otherwise, we would have
-  to write redundant invariants all over the meta-model because ``DataTypeDef`` and
-  ``DataTypeDefRDF`` are actually never used in any type definition.
-* The enumeration :py:class:`AASSubmodelElements` is used in two different contexts.
-  One context is the definition of key types in a reference. Another context is
-  the definition of element types in a :py:class:`SubmodelElementList`.
-
-  To avoid confusion, we introduce two separate enumerations for the separate contexts.
-  Firstly, a set of :py:class:`KeyTypes`, :py:attr:`.constants.AAS_SUBMODEL_ELEMENTS_AS_KEYS` to
-  represent the first context (key type in a reference).
-  Secondly, the enumeration :py:class:`AASSubmodelElements` is kept as designator
-  for :py:attr:`SubmodelElementList.type_value_list_element`.
-
-Concerning the data specifications, we embed them within
-:py:class:`HasDataSpecification` instead of referencing them *via* a global reference.
-The working group decided to change the rules for serialization *after* the book was
-published. The data specifications are critical in applications, but there is no
-possibility to access them through a data channel as they are not part of
-an environment.
-
-:constraint AASd-022:
-    .. _constraint_AASd-022:
-
-    :py:attr:`Referable.id_short` of non-identifiable referables
-    within the same name space shall be unique (case-sensitive).
-"""
-
-
-# This code has been automatically generated by aas-core-codegen.
-# Do NOT edit or append.
-
-
-import abc
-import enum
-from typing import Generic, Iterator, Optional, TypeVar, List
-
-
-T = TypeVar("T")
-ContextT = TypeVar("ContextT")
-
-
-class Class(abc.ABC):
-    """Represent the most general class of an AAS model."""
-
-    @abc.abstractmethod
-    def descend_once(self) -> Iterator["Class"]:
-        """Iterate over all the instances referenced from this one."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def descend(self) -> Iterator["Class"]:
-        """Iterate recursively over all the instances referenced from this one."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """
-        Dispatch the :paramref:`visitor` on this instance.
-
-        :param visitor: to be dispatched
-        """
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """
-        Dispatch the :paramref:`visitor` on this instance with :paramref:`context`.
-
-        :param visitor: to be dispatched
-        :param context: of the visitation
-        """
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance.
-
-        :param transformer: to be dispatched
-        :return: transformed self
-        """
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance with :paramref:`context`.
-
-        :param transformer: to be dispatched
-        :return: transformed self
-        """
-        raise NotImplementedError()
-
-
-# pylint: disable=redefined-builtin
-
-
-class HasSemantics(Class):
-    """
-    Element that can have a semantic definition plus some supplemental semantic
-    definitions.
-
-    :constraint AASd-118:
-        .. _constraint_AASd-118:
-
-        If there are ID :py:attr:`supplemental_semantic_ids` defined
-        then there shall be also a main semantic ID :py:attr:`semantic_id`.
-    """
-
-    #: Identifier of the semantic definition of the element. It is called semantic ID
-    #: of the element or also main semantic ID of the element.
-    #:
-    #: .. note::
-    #:
-    #:     It is recommended to use a global reference.
-    semantic_id: Optional["Reference"]
-
-    #: Identifier of a supplemental semantic definition of the element.
-    #: It is called supplemental semantic ID of the element.
-    #:
-    #: .. note::
-    #:
-    #:     It is recommended to use a global reference.
-    supplemental_semantic_ids: Optional[List["Reference"]]
-
-    def over_supplemental_semantic_ids_or_empty(self) -> Iterator["Reference"]:
-        """Yield from :py:attr:`.supplemental_semantic_ids` if set."""
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-    def __init__(
-        self,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        self.semantic_id = semantic_id
-        self.supplemental_semantic_ids = supplemental_semantic_ids
-
-
-class Extension(HasSemantics):
-    """Single extension of an element."""
-
-    #: Name of the extension.
-    #:
-    #: :constraint AASd-077:
-    #:     .. _constraint_AASd-077:
-    #:
-    #:     The name of an extension (Extension/name) within :py:class:`HasExtensions` needs
-    #:     to be unique.
-    name: str
-
-    #: Type of the value of the extension.
-    #:
-    #: Default: :py:attr:`DataTypeDefXSD.STRING`
-    value_type: Optional["DataTypeDefXSD"]
-
-    #: Value of the extension
-    value: Optional[str]
-
-    #: Reference to an element the extension refers to.
-    refers_to: Optional[List["Reference"]]
-
-    def over_refers_to_or_empty(self) -> Iterator["Reference"]:
-        """Yield from :py:attr:`.refers_to` if set."""
-        if self.refers_to is not None:
-            yield from self.refers_to
-
-    def value_type_or_default(self) -> "DataTypeDefXSD":
-        """Return the :py:attr:`value_type` if set, or the default otherwise."""
-        return self.value_type if self.value_type is not None else DataTypeDefXSD.STRING
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.refers_to is not None:
-            yield from self.refers_to
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for an_item in self.supplemental_semantic_ids:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.refers_to is not None:
-            for another_item in self.refers_to:
-                yield another_item
-
-                yield from another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_extension(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_extension_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_extension(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_extension_with_context(self, context)
-
-    def __init__(
-        self,
-        name: str,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        value_type: Optional["DataTypeDefXSD"] = None,
-        value: Optional[str] = None,
-        refers_to: Optional[List["Reference"]] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        HasSemantics.__init__(self, semantic_id, supplemental_semantic_ids)
-        self.name = name
-        self.value_type = value_type
-        self.value = value
-        self.refers_to = refers_to
-
-
-class HasExtensions(Class):
-    """
-    Element that can be extended by proprietary extensions.
-
-    .. note::
-
-        Extensions are proprietary, i.e. they do not support global interoperability.
-    """
-
-    #: An extension of the element.
-    extensions: Optional[List["Extension"]]
-
-    def over_extensions_or_empty(self) -> Iterator["Extension"]:
-        """Yield from :py:attr:`.extensions` if set."""
-        if self.extensions is not None:
-            yield from self.extensions
-
-    def __init__(self, extensions: Optional[List["Extension"]] = None) -> None:
-        """Initialize with the given values."""
-        self.extensions = extensions
-
-
-class Referable(HasExtensions):
-    """
-    An element that is referable by its :py:attr:`id_short`.
-
-    This ID is not globally unique.
-    This ID is unique within the name space of the element.
-    """
-
-    #: The category is a value that gives further meta information
-    #: w.r.t. to the class of the element.
-    #: It affects the expected existence of attributes and the applicability of
-    #: constraints.
-    #:
-    #: .. note::
-    #:
-    #:     The category is not identical to the semantic definition
-    #:     (:py:class:`HasSemantics`) of an element. The category e.g. could denote that
-    #:     the element is a measurement value whereas the semantic definition of
-    #:     the element would denote that it is the measured temperature.
-    category: Optional[str]
-
-    #: In case of identifiables this attribute is a short name of the element.
-    #: In case of referable this ID is an identifying string of the element within
-    #: its name space.
-    #:
-    #: .. note::
-    #:
-    #:     In case the element is a property and the property has a semantic definition
-    #:     (:py:attr:`HasSemantics.semantic_id`) conformant to IEC61360
-    #:     the :py:attr:`id_short` is typically identical to the short name in English.
-    id_short: Optional[str]
-
-    #: Display name. Can be provided in several languages.
-    display_name: Optional[List["LangStringNameType"]]
-
-    #: Description or comments on the element.
-    #:
-    #: The description can be provided in several languages.
-    #:
-    #: If no description is defined, then the definition of the concept
-    #: description that defines the semantics of the element is used.
-    #:
-    #: Additional information can be provided, e.g., if the element is
-    #: qualified and which qualifier types can be expected in which
-    #: context or which additional data specification templates are
-    #: provided.
-    description: Optional[List["LangStringTextType"]]
-
-    def over_display_name_or_empty(self) -> Iterator["LangStringNameType"]:
-        """Yield from :py:attr:`.display_name` if set."""
-        if self.display_name is not None:
-            yield from self.display_name
-
-    def over_description_or_empty(self) -> Iterator["LangStringTextType"]:
-        """Yield from :py:attr:`.description` if set."""
-        if self.description is not None:
-            yield from self.description
-
-    def __init__(
-        self,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        HasExtensions.__init__(self, extensions)
-        self.id_short = id_short
-        self.display_name = display_name
-        self.category = category
-        self.description = description
-
-
-class Identifiable(Referable):
-    """An element that has a globally unique identifier."""
-
-    #: Administrative information of an identifiable element.
-    #:
-    #: .. note::
-    #:
-    #:     Some of the administrative information like the version number might need to
-    #:     be part of the identification.
-    administration: Optional["AdministrativeInformation"]
-
-    #: The globally unique identification of the element.
-    id: str
-
-    def __init__(
-        self,
-        id: str,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        administration: Optional["AdministrativeInformation"] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        Referable.__init__(
-            self, extensions, category, id_short, display_name, description
-        )
-        self.id = id
-        self.administration = administration
-
-
-class ModellingKind(enum.Enum):
-    """
-    Enumeration for denoting whether an element is a template or an instance.
-    """
-
-    #: Specification of the common features of a structured element in sufficient detail
-    #: that such a instance can be instantiated using it
-    TEMPLATE = "Template"
-
-    #: Concrete, clearly identifiable element instance. Its creation and validation
-    #: may be guided by a corresponding element template.
-    INSTANCE = "Instance"
-
-
-class HasKind(Class):
-    """
-    An element with a kind is an element that can either represent a template or an
-    instance.
-
-    Default for an element is that it is representing an instance.
-    """
-
-    #: Kind of the element: either type or instance.
-    #:
-    #: Default: :py:attr:`ModellingKind.INSTANCE`
-    kind: Optional["ModellingKind"]
-
-    def kind_or_default(self) -> "ModellingKind":
-        """Return :py:attr:`kind` if set, and the default otherwise."""
-        return self.kind if self.kind is not None else ModellingKind.INSTANCE
-
-    def __init__(self, kind: Optional["ModellingKind"] = None) -> None:
-        """Initialize with the given values."""
-        self.kind = kind
-
-
-class HasDataSpecification(Class):
-    """
-    Element that can be extended by using data specification templates.
-
-    A data specification template defines a named set of additional attributes an
-    element may or shall have. The data specifications used are explicitly specified
-    with their global ID.
-    """
-
-    #: Embedded data specification.
-    embedded_data_specifications: Optional[List["EmbeddedDataSpecification"]]
-
-    def over_embedded_data_specifications_or_empty(
-        self,
-    ) -> Iterator["EmbeddedDataSpecification"]:
-        """Yield from :py:attr:`.embedded_data_specifications` if set."""
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-    def __init__(
-        self,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        self.embedded_data_specifications = embedded_data_specifications
-
-
-class AdministrativeInformation(HasDataSpecification):
-    """
-    Administrative meta-information for an element like version
-    information.
-
-    :constraint AASd-005:
-        .. _constraint_AASd-005:
-
-        If :py:attr:`version` is not specified then also :py:attr:`revision` shall be
-        unspecified. This means, a revision requires a version. If there is no version
-        there is no revision neither. Revision is optional.
-    """
-
-    #: Version of the element.
-    version: Optional[str]
-
-    #: Revision of the element.
-    revision: Optional[str]
-
-    #: The subject ID of the subject responsible for making the element.
-    creator: Optional["Reference"]
-
-    #: Identifier of the template that guided the creation of the element.
-    #:
-    #: .. note::
-    #:
-    #:     In case of a submodel the :py:attr:`template_id` is the identifier
-    #:     of the submodel template ID that guided the creation of the submodel
-    #:
-    #: .. note::
-    #:
-    #:     The :py:attr:`template_id` is not relevant for validation in Submodels.
-    #:     For validation the :py:attr:`Submodel.semantic_id` shall be used.
-    #:
-    #: .. note::
-    #:
-    #:     Usage of :py:attr:`template_id` is not restricted to submodel instances. So also
-    #:     the creation of submodel templates can be guided by another submodel template.
-    template_id: Optional[str]
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        if self.creator is not None:
-            yield self.creator
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.embedded_data_specifications is not None:
-            for an_item in self.embedded_data_specifications:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.creator is not None:
-            yield self.creator
-
-            yield from self.creator.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_administrative_information(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_administrative_information_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_administrative_information(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_administrative_information_with_context(
-            self, context
-        )
-
-    def __init__(
-        self,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        version: Optional[str] = None,
-        revision: Optional[str] = None,
-        creator: Optional["Reference"] = None,
-        template_id: Optional[str] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        HasDataSpecification.__init__(self, embedded_data_specifications)
-        self.version = version
-        self.revision = revision
-        self.creator = creator
-        self.template_id = template_id
-
-
-class Qualifiable(Class):
-    """
-    The value of a qualifiable element may be further qualified by one or more
-    qualifiers.
-
-    .. note::
-
-        This constraint is checked at :py:class:`Submodel`.
-
-    :constraint AASd-119:
-        .. _constraint_AASd-119:
-
-        If any :py:attr:`Qualifier.kind` value of :py:attr:`qualifiers` is
-        equal to :py:attr:`QualifierKind.TEMPLATE_QUALIFIER` and the qualified element
-        inherits from :py:class:`HasKind` then the qualified element shall be of
-        kind Template (:py:attr:`HasKind.kind` = :py:attr:`ModellingKind.TEMPLATE`).
-    """
-
-    #: Additional qualification of a qualifiable element.
-    #:
-    #: :constraint AASd-021:
-    #:     .. _constraint_AASd-021:
-    #:
-    #:     Every qualifiable can only have one qualifier with the same
-    #:     :py:attr:`Qualifier.type`.
-    qualifiers: Optional[List["Qualifier"]]
-
-    def over_qualifiers_or_empty(self) -> Iterator["Qualifier"]:
-        """Yield from :py:attr:`.qualifiers` if set."""
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-    def __init__(self, qualifiers: Optional[List["Qualifier"]] = None) -> None:
-        """Initialize with the given values."""
-        self.qualifiers = qualifiers
-
-
-class QualifierKind(enum.Enum):
-    """
-    Enumeration for kinds of qualifiers.
-
-    .. note::
-
-        This element is experimental and therefore may be subject to change or may be
-        removed completely in future versions of the meta-model.
-    """
-
-    #: qualifies the value of the element and can change during run-time.
-    #:
-    #: Value qualifiers are only applicable to elements with kind
-    #: :py:attr:`ModellingKind.INSTANCE`.
-    VALUE_QUALIFIER = "ValueQualifier"
-
-    #: qualifies the semantic definition the element is referring to
-    #: (:py:attr:`HasSemantics.semantic_id`)
-    CONCEPT_QUALIFIER = "ConceptQualifier"
-
-    #: qualifies the elements within a specific submodel on concept level.
-    #:
-    #: Template qualifiers are only applicable to elements with kind
-    #: :py:attr:`ModellingKind.TEMPLATE`.
-    TEMPLATE_QUALIFIER = "TemplateQualifier"
-
-
-class Qualifier(HasSemantics):
-    """
-    A qualifier is a type-value-pair that makes additional statements w.r.t. the value
-    of the element.
-
-    :constraint AASd-006:
-        .. _constraint_AASd-006:
-
-        If both the :py:attr:`value` and the :py:attr:`value_id` of
-        a :py:class:`Qualifier` are present then the :py:attr:`value` needs
-        to be identical to the value of the referenced coded value
-        in :py:attr:`value_id`.
-
-    :constraint AASd-020:
-        .. _constraint_AASd-020:
-
-        The value of :py:attr:`value` shall be consistent to the data type as
-        defined in :py:attr:`value_type`.
-    """
-
-    #: The qualifier kind describes the kind of the qualifier that is applied to the
-    #: element.
-    #:
-    #: Default: :py:attr:`QualifierKind.CONCEPT_QUALIFIER`
-    kind: Optional["QualifierKind"]
-
-    #: The qualifier *type* describes the type of the qualifier that is applied to
-    #: the element.
-    type: str
-
-    #: Data type of the qualifier value.
-    value_type: "DataTypeDefXSD"
-
-    #: The qualifier value is the value of the qualifier.
-    value: Optional[str]
-
-    #: Reference to the global unique ID of a coded value.
-    #:
-    #: .. note::
-    #:
-    #:     It is recommended to use a global reference.
-    value_id: Optional["Reference"]
-
-    def kind_or_default(self) -> "QualifierKind":
-        """Return :py:attr:`kind` if set, and the default otherwise."""
-        return self.kind if self.kind is not None else QualifierKind.CONCEPT_QUALIFIER
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.value_id is not None:
-            yield self.value_id
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for an_item in self.supplemental_semantic_ids:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.value_id is not None:
-            yield self.value_id
-
-            yield from self.value_id.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_qualifier(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_qualifier_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_qualifier(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_qualifier_with_context(self, context)
-
-    def __init__(
-        self,
-        type: str,
-        value_type: "DataTypeDefXSD",
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        kind: Optional["QualifierKind"] = None,
-        value: Optional[str] = None,
-        value_id: Optional["Reference"] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        HasSemantics.__init__(self, semantic_id, supplemental_semantic_ids)
-        self.type = type
-        self.value_type = value_type
-        self.kind = kind
-        self.value = value
-        self.value_id = value_id
-
-
-class AssetAdministrationShell(Identifiable, HasDataSpecification):
-    """An asset administration shell."""
-
-    #: The reference to the AAS the AAS was derived from.
-    derived_from: Optional["Reference"]
-
-    #: Meta-information about the asset the AAS is representing.
-    asset_information: "AssetInformation"
-
-    #: References to submodels of the AAS.
-    #:
-    #: A submodel is a description of an aspect of the asset the AAS is representing.
-    #:
-    #: The asset of an AAS is typically described by one or more submodels.
-    #:
-    #: Temporarily no submodel might be assigned to the AAS.
-    submodels: Optional[List["Reference"]]
-
-    def over_submodels_or_empty(self) -> Iterator["Reference"]:
-        """Yield from :py:attr:`.submodels` if set."""
-        if self.submodels is not None:
-            yield from self.submodels
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.administration is not None:
-            yield self.administration
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        if self.derived_from is not None:
-            yield self.derived_from
-
-        yield self.asset_information
-
-        if self.submodels is not None:
-            yield from self.submodels
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.administration is not None:
-            yield self.administration
-
-            yield from self.administration.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.derived_from is not None:
-            yield self.derived_from
-
-            yield from self.derived_from.descend()
-
-        yield self.asset_information
-
-        yield from self.asset_information.descend()
-
-        if self.submodels is not None:
-            for yet_yet_yet_another_item in self.submodels:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_asset_administration_shell(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_asset_administration_shell_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_asset_administration_shell(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_asset_administration_shell_with_context(
-            self, context
-        )
-
-    def __init__(
-        self,
-        id: str,
-        asset_information: "AssetInformation",
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        administration: Optional["AdministrativeInformation"] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        derived_from: Optional["Reference"] = None,
-        submodels: Optional[List["Reference"]] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        Identifiable.__init__(
-            self,
-            id,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            administration,
-        )
-        HasDataSpecification.__init__(self, embedded_data_specifications)
-        self.derived_from = derived_from
-        self.asset_information = asset_information
-        self.submodels = submodels
-
-
-class AssetInformation(Class):
-    """
-    In :py:class:`AssetInformation` identifying meta data of the asset that is
-    represented by an AAS is defined.
-
-    The asset may either represent an asset type or an asset instance.
-
-    The asset has a globally unique identifier plus  if needed  additional domain
-    specific (proprietary) identifiers. However, to support the corner case of very
-    first phase of lifecycle where a stabilised/constant_set global asset identifier
-    does not already exist, the corresponding attribute :py:attr:`global_asset_id` is
-    optional.
-
-    .. note::
-
-        :ref:`Constraint AASd-116 <constraint_AASd-116>` is important to enable a generic search across global
-        and specific asset IDs.
-
-    .. note::
-
-        In the book, :ref:`Constraint AASd-116 <constraint_AASd-116>` imposes a
-        case-insensitive equality against ``globalAssetId``. This is
-        culturally-dependent, and depends on the system settings.
-        For example, the case-folding for the letters "i" and "I" is
-        different in Turkish from English.
-
-        We implement the constraint as case-sensitive instead to allow
-        for interoperability across different culture settings.
-
-    :constraint AASd-116:
-        .. _constraint_AASd-116:
-
-        ``globalAssetId`` is a reserved key. If used as value for
-        :py:attr:`SpecificAssetID.name` then :py:attr:`SpecificAssetID.value` shall be
-        identical to :py:attr:`global_asset_id`.
-
-    :constraint AASd-131:
-        .. _constraint_AASd-131:
-
-        For :py:class:`AssetInformation` either the :py:attr:`global_asset_id` shall be
-        defined or at least one item in :py:attr:`specific_asset_ids`.
-    """
-
-    #: Denotes whether the Asset is of kind :py:attr:`AssetKind.TYPE` or
-    #: :py:attr:`AssetKind.INSTANCE`.
-    asset_kind: "AssetKind"
-
-    #: Global identifier of the asset the AAS is representing.
-    #:
-    #: This attribute is required as soon as the AAS is exchanged via partners in the life
-    #: cycle of the asset. In a first phase of the life cycle the asset might not yet have
-    #: a global ID but already an internal identifier. The internal identifier would be
-    #: modelled via :py:attr:`specific_asset_ids`.
-    #:
-    #: .. note::
-    #:
-    #:     This is a global reference.
-    global_asset_id: Optional[str]
-
-    #: Additional domain-specific, typically proprietary identifier for the asset like
-    #: e.g., serial number etc.
-    specific_asset_ids: Optional[List["SpecificAssetID"]]
-
-    #: In case :py:attr:`asset_kind` is applicable the :py:attr:`asset_type` is the asset ID
-    #: of the type asset of the asset under consideration
-    #: as identified by :py:attr:`global_asset_id`.
-    #:
-    #: .. note::
-    #:
-    #:     In case :py:attr:`asset_kind` is "Instance" than the :py:attr:`asset_type` denotes
-    #:     which "Type" the asset is of. But it is also possible
-    #:     to have an :py:attr:`asset_type` of an asset of kind "Type".
-    asset_type: Optional[str]
-
-    #: Thumbnail of the asset represented by the Asset Administration Shell.
-    #:
-    #: Used as default.
-    default_thumbnail: Optional["Resource"]
-
-    def over_specific_asset_ids_or_empty(self) -> Iterator["SpecificAssetID"]:
-        """Yield from :py:attr:`.specific_asset_ids` if set."""
-        if self.specific_asset_ids is not None:
-            yield from self.specific_asset_ids
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.specific_asset_ids is not None:
-            yield from self.specific_asset_ids
-
-        if self.default_thumbnail is not None:
-            yield self.default_thumbnail
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.specific_asset_ids is not None:
-            for an_item in self.specific_asset_ids:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.default_thumbnail is not None:
-            yield self.default_thumbnail
-
-            yield from self.default_thumbnail.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_asset_information(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_asset_information_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_asset_information(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_asset_information_with_context(self, context)
-
-    def __init__(
-        self,
-        asset_kind: "AssetKind",
-        global_asset_id: Optional[str] = None,
-        specific_asset_ids: Optional[List["SpecificAssetID"]] = None,
-        asset_type: Optional[str] = None,
-        default_thumbnail: Optional["Resource"] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        self.asset_kind = asset_kind
-        self.global_asset_id = global_asset_id
-        self.specific_asset_ids = specific_asset_ids
-        self.asset_type = asset_type
-        self.default_thumbnail = default_thumbnail
-
-
-class Resource(Class):
-    """
-    Resource represents an address to a file (a locator). The value is an URI that
-    can represent an absolute or relative path
-    """
-
-    #: Path and name of the resource (with file extension).
-    #:
-    #: The path can be absolute or relative.
-    path: str
-
-    #: Content type of the content of the file.
-    #:
-    #: The content type states which file extensions the file can have.
-    content_type: Optional[str]
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_resource(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_resource_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_resource(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_resource_with_context(self, context)
-
-    def __init__(self, path: str, content_type: Optional[str] = None) -> None:
-        """Initialize with the given values."""
-        self.path = path
-        self.content_type = content_type
-
-
-class AssetKind(enum.Enum):
-    """
-    Enumeration for denoting whether an asset is a type asset or an instance asset.
-    """
-
-    #: Type asset
-    TYPE = "Type"
-
-    #: Instance asset
-    INSTANCE = "Instance"
-
-    #: Neither a type asset nor an instance asset
-    NOT_APPLICABLE = "NotApplicable"
-
-
-class SpecificAssetID(HasSemantics):
-    """
-    A specific asset ID describes a generic supplementary identifying attribute of the
-    asset.
-
-    The specific asset ID is not necessarily globally unique.
-
-    :constraint AASd-133:
-        .. _constraint_AASd-133:
-
-        :py:attr:`external_subject_id` shall be an external reference,
-        i.e. :py:attr:`Reference.type` = :py:attr:`ReferenceTypes.EXTERNAL_REFERENCE`.
-    """
-
-    #: Name of the identifier
-    name: str
-
-    #: The value of the specific asset identifier with the corresponding name.
-    value: str
-
-    #: The (external) subject the key belongs to or has meaning to.
-    #:
-    #: .. note::
-    #:
-    #:     This is a global reference.
-    external_subject_id: Optional["Reference"]
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.external_subject_id is not None:
-            yield self.external_subject_id
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for an_item in self.supplemental_semantic_ids:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.external_subject_id is not None:
-            yield self.external_subject_id
-
-            yield from self.external_subject_id.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_specific_asset_id(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_specific_asset_id_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_specific_asset_id(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_specific_asset_id_with_context(self, context)
-
-    def __init__(
-        self,
-        name: str,
-        value: str,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        external_subject_id: Optional["Reference"] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        HasSemantics.__init__(self, semantic_id, supplemental_semantic_ids)
-        self.name = name
-        self.value = value
-        self.external_subject_id = external_subject_id
-
-
-class Submodel(Identifiable, HasKind, HasSemantics, Qualifiable, HasDataSpecification):
-    """
-    A submodel defines a specific aspect of the asset represented by the AAS.
-
-    A submodel is used to structure the digital representation and technical
-    functionality of an Administration Shell into distinguishable parts. Each submodel
-    refers to a well-defined domain or subject matter. Submodels can become
-    standardized and, thus, become submodels templates.
-    """
-
-    #: A submodel consists of zero or more submodel elements.
-    submodel_elements: Optional[List["SubmodelElement"]]
-
-    def over_submodel_elements_or_empty(self) -> Iterator["SubmodelElement"]:
-        """Yield from :py:attr:`.submodel_elements` if set."""
-        if self.submodel_elements is not None:
-            yield from self.submodel_elements
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.administration is not None:
-            yield self.administration
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        if self.submodel_elements is not None:
-            yield from self.submodel_elements
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.administration is not None:
-            yield self.administration
-
-            yield from self.administration.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-        if self.submodel_elements is not None:
-            for yet_yet_yet_yet_yet_another_item in self.submodel_elements:
-                yield yet_yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_submodel(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_submodel_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_submodel(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_submodel_with_context(self, context)
-
-    def __init__(
-        self,
-        id: str,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        administration: Optional["AdministrativeInformation"] = None,
-        kind: Optional["ModellingKind"] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        submodel_elements: Optional[List["SubmodelElement"]] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        Identifiable.__init__(
-            self,
-            id,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            administration,
-        )
-        HasKind.__init__(self, kind)
-        HasSemantics.__init__(self, semantic_id, supplemental_semantic_ids)
-        Qualifiable.__init__(self, qualifiers)
-        HasDataSpecification.__init__(self, embedded_data_specifications)
-        self.submodel_elements = submodel_elements
-
-
-class SubmodelElement(Referable, HasSemantics, Qualifiable, HasDataSpecification):
-    """
-    A submodel element is an element suitable for the description and differentiation of
-    assets.
-
-    It is recommended to add a :py:attr:`HasSemantics.semantic_id` to a submodel element.
-
-    :constraint AASd-129:
-        .. _constraint_AASd-129:
-
-        If any :py:attr:`Qualifier.kind` value of :py:attr:`qualifiers` (attribute qualifier
-        inherited via Qualifiable) is equal to :py:attr:`QualifierKind.TEMPLATE_QUALIFIER`
-        then the submodel element shall be part of a submodel template, i.e.
-        a Submodel with :py:attr:`Submodel.kind` (attribute kind inherited via
-        :py:class:`HasKind`) value is equal to :py:attr:`ModellingKind.TEMPLATE`.
-    """
-
-    def __init__(
-        self,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        Referable.__init__(
-            self, extensions, category, id_short, display_name, description
-        )
-        HasSemantics.__init__(self, semantic_id, supplemental_semantic_ids)
-        Qualifiable.__init__(self, qualifiers)
-        HasDataSpecification.__init__(self, embedded_data_specifications)
-
-
-class RelationshipElement(SubmodelElement):
-    """
-    A relationship element is used to define a relationship between two elements
-    being either referable (model reference) or external (global reference).
-    """
-
-    #: Reference to the first element in the relationship taking the role of the subject.
-    first: "Reference"
-
-    #: Reference to the second element in the relationship taking the role of the object.
-    second: "Reference"
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        yield self.first
-
-        yield self.second
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-        yield self.first
-
-        yield from self.first.descend()
-
-        yield self.second
-
-        yield from self.second.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_relationship_element(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_relationship_element_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_relationship_element(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_relationship_element_with_context(self, context)
-
-    def __init__(
-        self,
-        first: "Reference",
-        second: "Reference",
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        SubmodelElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.first = first
-        self.second = second
-
-
-class AASSubmodelElements(enum.Enum):
-    """
-    Enumeration of all possible elements of a :py:class:`SubmodelElementList`.
-    """
-
-    ANNOTATED_RELATIONSHIP_ELEMENT = "AnnotatedRelationshipElement"
-
-    BASIC_EVENT_ELEMENT = "BasicEventElement"
-
-    BLOB = "Blob"
-
-    CAPABILITY = "Capability"
-
-    DATA_ELEMENT = "DataElement"
-
-    ENTITY = "Entity"
-
-    EVENT_ELEMENT = "EventElement"
-
-    FILE = "File"
-
-    MULTI_LANGUAGE_PROPERTY = "MultiLanguageProperty"
-
-    OPERATION = "Operation"
-
-    PROPERTY = "Property"
-
-    RANGE = "Range"
-
-    REFERENCE_ELEMENT = "ReferenceElement"
-
-    RELATIONSHIP_ELEMENT = "RelationshipElement"
-
-    SUBMODEL_ELEMENT = "SubmodelElement"
-
-    SUBMODEL_ELEMENT_LIST = "SubmodelElementList"
-
-    SUBMODEL_ELEMENT_COLLECTION = "SubmodelElementCollection"
-
-
-class SubmodelElementList(SubmodelElement):
-    """
-    A submodel element list is an ordered list of submodel elements.
-
-    The numbering starts with zero (0).
-
-    :constraint AASd-107:
-        .. _constraint_AASd-107:
-
-        If a first level child element in a :py:class:`SubmodelElementList` has
-        a :py:attr:`HasSemantics.semantic_id` it
-        shall be identical to :py:attr:`semantic_id_list_element`.
-
-    :constraint AASd-114:
-        .. _constraint_AASd-114:
-
-        If two first level child elements in a :py:class:`SubmodelElementList` have
-        a :py:attr:`HasSemantics.semantic_id` then they shall be identical.
-
-    :constraint AASd-115:
-        .. _constraint_AASd-115:
-
-        If a first level child element in a :py:class:`SubmodelElementList` does not
-        specify a :py:attr:`HasSemantics.semantic_id` then the value is assumed to be
-        identical to :py:attr:`semantic_id_list_element`.
-
-    :constraint AASd-108:
-        .. _constraint_AASd-108:
-
-        All first level child elements in a :py:class:`SubmodelElementList` shall have
-        the same submodel element type as specified in :py:attr:`type_value_list_element`.
-
-    :constraint AASd-109:
-        .. _constraint_AASd-109:
-
-        If :py:attr:`type_value_list_element` is equal to
-        :py:attr:`AASSubmodelElements.PROPERTY` or
-        :py:attr:`AASSubmodelElements.RANGE`
-        :py:attr:`value_type_list_element` shall be set and all first
-        level child elements in the :py:class:`SubmodelElementList` shall have
-        the value type as specified in :py:attr:`value_type_list_element`.
-    """
-
-    #: Defines whether order in list is relevant. If :py:attr:`order_relevant` = ``False``
-    #: then the list is representing a set or a bag.
-    #:
-    #: Default: ``True``
-    order_relevant: Optional[bool]
-
-    #: Semantic ID the submodel elements contained in the list match to.
-    #:
-    #: .. note::
-    #:
-    #:     It is recommended to use a global reference.
-    semantic_id_list_element: Optional["Reference"]
-
-    #: The submodel element type of the submodel elements contained in the list.
-    type_value_list_element: "AASSubmodelElements"
-
-    #: The value type of the submodel element contained in the list.
-    value_type_list_element: Optional["DataTypeDefXSD"]
-
-    #: Submodel element contained in the list.
-    #:
-    #: The list is ordered.
-    value: Optional[List["SubmodelElement"]]
-
-    def over_value_or_empty(self) -> Iterator["SubmodelElement"]:
-        """Yield from :py:attr:`.value` if set."""
-        if self.value is not None:
-            yield from self.value
-
-    def order_relevant_or_default(self) -> bool:
-        """Return :py:attr:`order_relevant` if set, and the default otherwise."""
-        return self.order_relevant if self.order_relevant is not None else True
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        if self.semantic_id_list_element is not None:
-            yield self.semantic_id_list_element
-
-        if self.value is not None:
-            yield from self.value
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-        if self.semantic_id_list_element is not None:
-            yield self.semantic_id_list_element
-
-            yield from self.semantic_id_list_element.descend()
-
-        if self.value is not None:
-            for yet_yet_yet_yet_yet_another_item in self.value:
-                yield yet_yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_submodel_element_list(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_submodel_element_list_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_submodel_element_list(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_submodel_element_list_with_context(self, context)
-
-    def __init__(
-        self,
-        type_value_list_element: "AASSubmodelElements",
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        order_relevant: Optional[bool] = None,
-        semantic_id_list_element: Optional["Reference"] = None,
-        value_type_list_element: Optional["DataTypeDefXSD"] = None,
-        value: Optional[List["SubmodelElement"]] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        SubmodelElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.type_value_list_element = type_value_list_element
-        self.order_relevant = order_relevant
-        self.semantic_id_list_element = semantic_id_list_element
-        self.value_type_list_element = value_type_list_element
-        self.value = value
-
-
-class SubmodelElementCollection(SubmodelElement):
-    """
-    A submodel element collection is a kind of struct, i.e. a a logical encapsulation
-    of multiple named values. It has a fixed number of submodel elements.
-    """
-
-    #: Submodel element contained in the collection.
-    value: Optional[List["SubmodelElement"]]
-
-    def over_value_or_empty(self) -> Iterator["SubmodelElement"]:
-        """Yield from :py:attr:`.value` if set."""
-        if self.value is not None:
-            yield from self.value
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        if self.value is not None:
-            yield from self.value
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-        if self.value is not None:
-            for yet_yet_yet_yet_yet_another_item in self.value:
-                yield yet_yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_submodel_element_collection(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_submodel_element_collection_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_submodel_element_collection(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_submodel_element_collection_with_context(
-            self, context
-        )
-
-    def __init__(
-        self,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        value: Optional[List["SubmodelElement"]] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        SubmodelElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.value = value
-
-
-class DataElement(SubmodelElement):
-    """
-    A data element is a submodel element that is not further composed out of
-    other submodel elements.
-
-    A data element is a submodel element that has a value. The type of value differs
-    for different subtypes of data elements.
-
-    :constraint AASd-090:
-        .. _constraint_AASd-090:
-
-        For data elements :py:attr:`category` shall be one of the following
-        values: ``CONSTANT``, ``PARAMETER`` or ``VARIABLE``.
-
-        Default: ``VARIABLE``
-    """
-
-    def category_or_default(self) -> str:
-        """Return the :py:attr:`category` if set or the default value otherwise."""
-        return self.category if self.category else "VARIABLE"
-
-    def __init__(
-        self,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        SubmodelElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-
-
-class Property(DataElement):
-    """
-    A property is a data element that has a single value.
-
-    :constraint AASd-007:
-        .. _constraint_AASd-007:
-
-        If both, the :py:attr:`value` and the :py:attr:`value_id` are
-        present then the value of :py:attr:`value` needs to be identical to
-        the value of the referenced coded value in :py:attr:`value_id`.
-    """
-
-    #: Data type of the value
-    value_type: "DataTypeDefXSD"
-
-    #: The value of the property instance.
-    value: Optional[str]
-
-    #: Reference to the global unique ID of a coded value.
-    #:
-    #: .. note::
-    #:
-    #:     It is recommended to use a global reference.
-    value_id: Optional["Reference"]
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        if self.value_id is not None:
-            yield self.value_id
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-        if self.value_id is not None:
-            yield self.value_id
-
-            yield from self.value_id.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_property(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_property_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_property(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_property_with_context(self, context)
-
-    def __init__(
-        self,
-        value_type: "DataTypeDefXSD",
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        value: Optional[str] = None,
-        value_id: Optional["Reference"] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        DataElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.value_type = value_type
-        self.value = value
-        self.value_id = value_id
-
-
-class MultiLanguageProperty(DataElement):
-    """
-    A property is a data element that has a multi-language value.
-
-    :constraint AASd-012:
-        .. _constraint_AASd-012:
-
-        If both the :py:attr:`value` and the :py:attr:`value_id` are present then for each
-        string in a specific language the meaning must be the same as specified in
-        :py:attr:`value_id`.
-    """
-
-    #: The value of the property instance.
-    value: Optional[List["LangStringTextType"]]
-
-    #: Reference to the global unique ID of a coded value.
-    #:
-    #: .. note::
-    #:
-    #:     It is recommended to use a global reference.
-    value_id: Optional["Reference"]
-
-    def over_value_or_empty(self) -> Iterator["LangStringTextType"]:
-        """Yield from :py:attr:`.value` if set."""
-        if self.value is not None:
-            yield from self.value
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        if self.value is not None:
-            yield from self.value
-
-        if self.value_id is not None:
-            yield self.value_id
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-        if self.value is not None:
-            for yet_yet_yet_yet_yet_another_item in self.value:
-                yield yet_yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_yet_another_item.descend()
-
-        if self.value_id is not None:
-            yield self.value_id
-
-            yield from self.value_id.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_multi_language_property(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_multi_language_property_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_multi_language_property(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_multi_language_property_with_context(self, context)
-
-    def __init__(
-        self,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        value: Optional[List["LangStringTextType"]] = None,
-        value_id: Optional["Reference"] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        DataElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.value = value
-        self.value_id = value_id
-
-
-class Range(DataElement):
-    """
-    A range data element is a data element that defines a range with min and max.
-    """
-
-    #: Data type of the min und max
-    value_type: "DataTypeDefXSD"
-
-    #: The minimum value of the range.
-    #:
-    #: If the min value is missing, then the value is assumed to be negative infinite.
-    min: Optional[str]
-
-    #: The maximum value of the range.
-    #:
-    #: If the max value is missing, then the value is assumed to be positive infinite.
-    max: Optional[str]
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_range(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_range_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_range(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_range_with_context(self, context)
-
-    def __init__(
-        self,
-        value_type: "DataTypeDefXSD",
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        min: Optional[str] = None,
-        max: Optional[str] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        DataElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.value_type = value_type
-        self.min = min
-        self.max = max
-
-
-class ReferenceElement(DataElement):
-    """
-    A reference element is a data element that defines a logical reference to another
-    element within the same or another AAS or a reference to an external object or
-    entity.
-    """
-
-    #: Global reference to an external object or entity or a logical reference to
-    #: another element within the same or another AAS (i.e. a model reference to
-    #: a Referable).
-    value: Optional["Reference"]
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        if self.value is not None:
-            yield self.value
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-        if self.value is not None:
-            yield self.value
-
-            yield from self.value.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_reference_element(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_reference_element_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_reference_element(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_reference_element_with_context(self, context)
-
-    def __init__(
-        self,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        value: Optional["Reference"] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        DataElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.value = value
-
-
-class Blob(DataElement):
-    """
-    A :py:class:`Blob` is a data element that represents a file that is contained with its
-    source code in the value attribute.
-    """
-
-    #: The value of the :py:class:`Blob` instance of a blob data element.
-    #:
-    #: .. note::
-    #:
-    #:     In contrast to the file property the file content is stored directly as value
-    #:     in the :py:class:`Blob` data element.
-    value: Optional[bytes]
-
-    #: Content type of the content of the :py:class:`Blob`.
-    #:
-    #: The content type (MIME type) states which file extensions the file can have.
-    #:
-    #: Valid values are content types like e.g. ``application/json``, ``application/xls``,
-    #: ``image/jpg``.
-    #:
-    #: The allowed values are defined as in RFC2046.
-    content_type: str
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_blob(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_blob_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_blob(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_blob_with_context(self, context)
-
-    def __init__(
-        self,
-        content_type: str,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        value: Optional[bytes] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        DataElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.content_type = content_type
-        self.value = value
-
-
-class File(DataElement):
-    """
-    A File is a data element that represents an address to a file (a locator).
-
-    The value is an URI that can represent an absolute or relative path.
-    """
-
-    #: Path and name of the referenced file (with file extension).
-    #:
-    #: The path can be absolute or relative.
-    value: Optional[str]
-
-    #: Content type of the content of the file.
-    #:
-    #: The content type states which file extensions the file can have.
-    content_type: str
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_file(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_file_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_file(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_file_with_context(self, context)
-
-    def __init__(
-        self,
-        content_type: str,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        value: Optional[str] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        DataElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.content_type = content_type
-        self.value = value
-
-
-class AnnotatedRelationshipElement(RelationshipElement):
-    """
-    An annotated relationship element is a relationship element that can be annotated
-    with additional data elements.
-    """
-
-    #: A data element that represents an annotation that holds for the relationship
-    #: between the two elements
-    annotations: Optional[List["DataElement"]]
-
-    def over_annotations_or_empty(self) -> Iterator["DataElement"]:
-        """Yield from :py:attr:`.annotations` if set."""
-        if self.annotations is not None:
-            yield from self.annotations
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        yield self.first
-
-        yield self.second
-
-        if self.annotations is not None:
-            yield from self.annotations
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-        yield self.first
-
-        yield from self.first.descend()
-
-        yield self.second
-
-        yield from self.second.descend()
-
-        if self.annotations is not None:
-            for yet_yet_yet_yet_yet_another_item in self.annotations:
-                yield yet_yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_annotated_relationship_element(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_annotated_relationship_element_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_annotated_relationship_element(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_annotated_relationship_element_with_context(
-            self, context
-        )
-
-    def __init__(
-        self,
-        first: "Reference",
-        second: "Reference",
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        annotations: Optional[List["DataElement"]] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        RelationshipElement.__init__(
-            self,
-            first,
-            second,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.annotations = annotations
-
-
-class Entity(SubmodelElement):
-    """
-    An entity is a submodel element that is used to model entities.
-
-    :constraint AASd-014:
-        .. _constraint_AASd-014:
-
-        Either the attribute :py:attr:`global_asset_id` or :py:attr:`specific_asset_ids`
-        of an :py:class:`Entity` must be set if :py:attr:`entity_type` is set to
-        :py:attr:`EntityType.SELF_MANAGED_ENTITY`. They are not existing otherwise.
-    """
-
-    #: Describes statements applicable to the entity by a set of submodel elements,
-    #: typically with a qualified value.
-    statements: Optional[List["SubmodelElement"]]
-
-    #: Describes whether the entity is a co-managed entity or a self-managed entity.
-    entity_type: "EntityType"
-
-    #: Global identifier of the asset the entity is representing.
-    #:
-    #: .. note::
-    #:
-    #:     This is a global reference.
-    global_asset_id: Optional[str]
-
-    #: Reference to a specific asset ID representing a supplementary identifier
-    #: of the asset represented by the Asset Administration Shell.
-    specific_asset_ids: Optional[List["SpecificAssetID"]]
-
-    def over_statements_or_empty(self) -> Iterator["SubmodelElement"]:
-        """Yield from :py:attr:`.statements` if set."""
-        if self.statements is not None:
-            yield from self.statements
-
-    def over_specific_asset_ids_or_empty(self) -> Iterator["SpecificAssetID"]:
-        """Yield from :py:attr:`.specific_asset_ids` if set."""
-        if self.specific_asset_ids is not None:
-            yield from self.specific_asset_ids
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        if self.statements is not None:
-            yield from self.statements
-
-        if self.specific_asset_ids is not None:
-            yield from self.specific_asset_ids
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-        if self.statements is not None:
-            for yet_yet_yet_yet_yet_another_item in self.statements:
-                yield yet_yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_yet_another_item.descend()
-
-        if self.specific_asset_ids is not None:
-            for yet_yet_yet_yet_yet_yet_another_item in self.specific_asset_ids:
-                yield yet_yet_yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_yet_yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_entity(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_entity_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_entity(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_entity_with_context(self, context)
-
-    def __init__(
-        self,
-        entity_type: "EntityType",
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        statements: Optional[List["SubmodelElement"]] = None,
-        global_asset_id: Optional[str] = None,
-        specific_asset_ids: Optional[List["SpecificAssetID"]] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        SubmodelElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.statements = statements
-        self.entity_type = entity_type
-        self.global_asset_id = global_asset_id
-        self.specific_asset_ids = specific_asset_ids
-
-
-class EntityType(enum.Enum):
-    """
-    Enumeration for denoting whether an entity is a self-managed entity or a co-managed
-    entity.
-    """
-
-    #: For co-managed entities there is no separate AAS. Co-managed entities need to be
-    #: part of a self-managed entity.
-    CO_MANAGED_ENTITY = "CoManagedEntity"
-
-    #: Self-Managed Entities have their own AAS but can be part of the bill of material of
-    #: a composite self-managed entity.
-    #:
-    #: The asset of an I4.0 Component is a self-managed entity per definition.
-    SELF_MANAGED_ENTITY = "SelfManagedEntity"
-
-
-class Direction(enum.Enum):
-    """
-    Direction
-
-    .. note::
-
-        This element is experimental and therefore may be subject to change or may be
-        removed completely in future versions of the meta-model.
-    """
-
-    #: Input direction.
-    INPUT = "input"
-
-    #: Output direction
-    OUTPUT = "output"
-
-
-class StateOfEvent(enum.Enum):
-    """
-    State of an event
-
-    .. note::
-
-        This element is experimental and therefore may be subject to change or may be
-        removed completely in future versions of the meta-model.
-    """
-
-    #: Event is on
-    ON = "on"
-
-    #: Event is off.
-    OFF = "off"
-
-
-class EventPayload(Class):
-    """
-    Defines the necessary information of an event instance sent out or received.
-
-    .. note::
-
-        This element is experimental and therefore may be subject to change or may be
-        removed completely in future versions of the meta-model.
-    """
-
-    #: Reference to the source event element, including identification of
-    #: :py:class:`AssetAdministrationShell`, :py:class:`Submodel`,
-    #: :py:class:`SubmodelElement`'s.
-    source: "Reference"
-
-    #: :py:attr:`HasSemantics.semantic_id` of the source event element, if available
-    #:
-    #: .. note::
-    #:
-    #:     It is recommended to use a global reference.
-    source_semantic_id: Optional["Reference"]
-
-    #: Reference to the referable, which defines the scope of the event.
-    #:
-    #: Can be :py:class:`AssetAdministrationShell`, :py:class:`Submodel` or
-    #: :py:class:`SubmodelElement`.
-    observable_reference: "Reference"
-
-    #: :py:attr:`HasSemantics.semantic_id` of the referable which defines the scope of
-    #: the event, if available.
-    #:
-    #: .. note::
-    #:
-    #:     It is recommended to use a global reference.
-    observable_semantic_id: Optional["Reference"]
-
-    #: Information for the outer message infrastructure for scheduling the event to
-    #: the respective communication channel.
-    topic: Optional[str]
-
-    #: Subject, who/which initiated the creation.
-    #:
-    #: .. note::
-    #:
-    #:     This is an external reference.
-    subject_id: Optional["Reference"]
-
-    #: Timestamp in UTC, when this event was triggered.
-    time_stamp: str
-
-    #: Event specific payload.
-    payload: Optional[bytes]
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        yield self.source
-
-        if self.source_semantic_id is not None:
-            yield self.source_semantic_id
-
-        yield self.observable_reference
-
-        if self.observable_semantic_id is not None:
-            yield self.observable_semantic_id
-
-        if self.subject_id is not None:
-            yield self.subject_id
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        yield self.source
-
-        yield from self.source.descend()
-
-        if self.source_semantic_id is not None:
-            yield self.source_semantic_id
-
-            yield from self.source_semantic_id.descend()
-
-        yield self.observable_reference
-
-        yield from self.observable_reference.descend()
-
-        if self.observable_semantic_id is not None:
-            yield self.observable_semantic_id
-
-            yield from self.observable_semantic_id.descend()
-
-        if self.subject_id is not None:
-            yield self.subject_id
-
-            yield from self.subject_id.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_event_payload(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_event_payload_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_event_payload(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_event_payload_with_context(self, context)
-
-    def __init__(
-        self,
-        source: "Reference",
-        observable_reference: "Reference",
-        time_stamp: str,
-        source_semantic_id: Optional["Reference"] = None,
-        observable_semantic_id: Optional["Reference"] = None,
-        topic: Optional[str] = None,
-        subject_id: Optional["Reference"] = None,
-        payload: Optional[bytes] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        self.source = source
-        self.observable_reference = observable_reference
-        self.time_stamp = time_stamp
-        self.source_semantic_id = source_semantic_id
-        self.observable_semantic_id = observable_semantic_id
-        self.topic = topic
-        self.subject_id = subject_id
-        self.payload = payload
-
-
-class EventElement(SubmodelElement):
-    """
-    An event element.
-
-    .. note::
-
-        This element is experimental and therefore may be subject to change or may be
-        removed completely in future versions of the meta-model.
-    """
-
-    def __init__(
-        self,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        SubmodelElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-
-
-class BasicEventElement(EventElement):
-    """
-    A basic event element.
-
-    .. note::
-
-        This element is experimental and therefore may be subject to change or may be
-        removed completely in future versions of the meta-model.
-    """
-
-    #: Reference to the :py:class:`Referable`, which defines the scope of the event.
-    #: Can be :py:class:`AssetAdministrationShell`, :py:class:`Submodel`, or
-    #: :py:class:`SubmodelElement`.
-    #:
-    #: Reference to a referable, e.g., a data element or
-    #: a submodel, that is being observed.
-    observed: "Reference"
-
-    #: Direction of event.
-    #:
-    #: Can be ``{ Input, Output }``.
-    direction: "Direction"
-
-    #: State of event.
-    #:
-    #: Can be ``{ On, Off }``.
-    state: "StateOfEvent"
-
-    #: Information for the outer message infrastructure for scheduling the event to the
-    #: respective communication channel.
-    message_topic: Optional[str]
-
-    #: Information, which outer message infrastructure shall handle messages for
-    #: the :py:class:`EventElement`. Refers to a :py:class:`Submodel`,
-    #: :py:class:`SubmodelElementList`, :py:class:`SubmodelElementCollection` or
-    #: :py:class:`Entity`, which contains :py:class:`DataElement`'s describing
-    #: the proprietary specification for the message broker.
-    #:
-    #: .. note::
-    #:
-    #:     For different message infrastructure, e.g., OPC UA or MQTT or AMQP, this
-    #:     proprietary specification could be standardized by having respective Submodels.
-    message_broker: Optional["Reference"]
-
-    #: Timestamp in UTC, when the last event was received (input direction) or sent
-    #: (output direction).
-    last_update: Optional[str]
-
-    #: For input direction, reports on the maximum frequency, the software entity behind
-    #: the respective Referable can handle input events.
-    #:
-    #: For output events, specifies the maximum frequency of outputting this event to
-    #: an outer infrastructure.
-    #:
-    #: Might be not specified, that is, there is no minimum interval.
-    min_interval: Optional[str]
-
-    #: For input direction: not applicable.
-    #:
-    #: For output direction: maximum interval in time, the respective Referable shall send
-    #: an update of the status of the event, even if no other trigger condition for
-    #: the event was not met.
-    #:
-    #: Might be not specified, that is, there is no maximum interval
-    max_interval: Optional[str]
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        yield self.observed
-
-        if self.message_broker is not None:
-            yield self.message_broker
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-        yield self.observed
-
-        yield from self.observed.descend()
-
-        if self.message_broker is not None:
-            yield self.message_broker
-
-            yield from self.message_broker.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_basic_event_element(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_basic_event_element_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_basic_event_element(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_basic_event_element_with_context(self, context)
-
-    def __init__(
-        self,
-        observed: "Reference",
-        direction: "Direction",
-        state: "StateOfEvent",
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        message_topic: Optional[str] = None,
-        message_broker: Optional["Reference"] = None,
-        last_update: Optional[str] = None,
-        min_interval: Optional[str] = None,
-        max_interval: Optional[str] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        EventElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.observed = observed
-        self.direction = direction
-        self.state = state
-        self.message_topic = message_topic
-        self.message_broker = message_broker
-        self.last_update = last_update
-        self.min_interval = min_interval
-        self.max_interval = max_interval
-
-
-class Operation(SubmodelElement):
-    """
-    An operation is a submodel element with input and output variables.
-
-    :constraint AASd-134:
-        .. _constraint_AASd-134:
-
-        For an :py:class:`Operation` the :py:attr:`Referable.id_short` of all
-        :py:attr:`OperationVariable.value`'s in
-        :py:attr:`input_variables`, :py:attr:`output_variables`
-        and :py:attr:`inoutput_variables` shall be unique.
-    """
-
-    #: Input parameter of the operation.
-    input_variables: Optional[List["OperationVariable"]]
-
-    #: Output parameter of the operation.
-    output_variables: Optional[List["OperationVariable"]]
-
-    #: Parameter that is input and output of the operation.
-    inoutput_variables: Optional[List["OperationVariable"]]
-
-    def over_input_variables_or_empty(self) -> Iterator["OperationVariable"]:
-        """Yield from :py:attr:`.input_variables` if set."""
-        if self.input_variables is not None:
-            yield from self.input_variables
-
-    def over_output_variables_or_empty(self) -> Iterator["OperationVariable"]:
-        """Yield from :py:attr:`.output_variables` if set."""
-        if self.output_variables is not None:
-            yield from self.output_variables
-
-    def over_inoutput_variables_or_empty(self) -> Iterator["OperationVariable"]:
-        """Yield from :py:attr:`.inoutput_variables` if set."""
-        if self.inoutput_variables is not None:
-            yield from self.inoutput_variables
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        if self.input_variables is not None:
-            yield from self.input_variables
-
-        if self.output_variables is not None:
-            yield from self.output_variables
-
-        if self.inoutput_variables is not None:
-            yield from self.inoutput_variables
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-        if self.input_variables is not None:
-            for yet_yet_yet_yet_yet_another_item in self.input_variables:
-                yield yet_yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_yet_another_item.descend()
-
-        if self.output_variables is not None:
-            for yet_yet_yet_yet_yet_yet_another_item in self.output_variables:
-                yield yet_yet_yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_yet_yet_another_item.descend()
-
-        if self.inoutput_variables is not None:
-            for yet_yet_yet_yet_yet_yet_yet_another_item in self.inoutput_variables:
-                yield yet_yet_yet_yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_yet_yet_yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_operation(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_operation_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_operation(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_operation_with_context(self, context)
-
-    def __init__(
-        self,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        input_variables: Optional[List["OperationVariable"]] = None,
-        output_variables: Optional[List["OperationVariable"]] = None,
-        inoutput_variables: Optional[List["OperationVariable"]] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        SubmodelElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-        self.input_variables = input_variables
-        self.output_variables = output_variables
-        self.inoutput_variables = inoutput_variables
-
-
-class OperationVariable(Class):
-    """
-    The value of an operation variable is a submodel element that is used as input
-    and/or output variable of an operation.
-    """
-
-    #: Describes an argument or result of an operation via a submodel element
-    value: "SubmodelElement"
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        yield self.value
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        yield self.value
-
-        yield from self.value.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_operation_variable(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_operation_variable_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_operation_variable(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_operation_variable_with_context(self, context)
-
-    def __init__(self, value: "SubmodelElement") -> None:
-        """Initialize with the given values."""
-        self.value = value
-
-
-class Capability(SubmodelElement):
-    """
-    A capability is the implementation-independent description of the potential of an
-    asset to achieve a certain effect in the physical or virtual world.
-
-    .. note::
-
-        The :py:attr:`semantic_id` of a capability is typically an ontology.
-        Thus, reasoning on capabilities is enabled.
-    """
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-        if self.supplemental_semantic_ids is not None:
-            yield from self.supplemental_semantic_ids
-
-        if self.qualifiers is not None:
-            yield from self.qualifiers
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.semantic_id is not None:
-            yield self.semantic_id
-
-            yield from self.semantic_id.descend()
-
-        if self.supplemental_semantic_ids is not None:
-            for yet_yet_another_item in self.supplemental_semantic_ids:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.qualifiers is not None:
-            for yet_yet_yet_another_item in self.qualifiers:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_yet_yet_another_item
-
-                yield from yet_yet_yet_yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_capability(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_capability_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_capability(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_capability_with_context(self, context)
-
-    def __init__(
-        self,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        semantic_id: Optional["Reference"] = None,
-        supplemental_semantic_ids: Optional[List["Reference"]] = None,
-        qualifiers: Optional[List["Qualifier"]] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        SubmodelElement.__init__(
-            self,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            semantic_id,
-            supplemental_semantic_ids,
-            qualifiers,
-            embedded_data_specifications,
-        )
-
-
-class ConceptDescription(Identifiable, HasDataSpecification):
-    """
-    The semantics of a property or other elements that may have a semantic description
-    is defined by a concept description.
-
-    The description of the concept should follow a standardized schema (realized as
-    data specification template).
-
-    .. note::
-
-        Note: categories are deprecated since V3.0 of Part 1a of the document series
-        "Details of the Asset Administration Shell".
-
-    .. note::
-
-        Note: categories are deprecated since V3.0 of Part 1a of the document series
-        "Details of the Asset Administration Shell".
-
-    .. note::
-
-        Categories are deprecated since V3.0 of Part 1a of the document series
-        "Details of the Asset Administration Shell".
-
-    .. note::
-
-        Categories are deprecated since V3.0 of Part 1a of the document series
-        "Details of the Asset Administration Shell".
-
-    :constraint AASc-3a-008:
-        .. _constraint_AASc-3a-008:
-
-        For a :py:class:`ConceptDescription` using data specification template IEC61360,
-        :py:attr:`DataSpecificationIEC61360.definition` is mandatory and shall be
-        defined at least in English.
-
-        Exception: The concept description describes a value, i.e.
-        :py:attr:`DataSpecificationIEC61360.value` is defined.
-
-    :constraint AASc-3a-003:
-        .. _constraint_AASc-3a-003:
-
-        For a :py:class:`ConceptDescription` using data specification template IEC61360,
-        referenced via :py:attr:`DataSpecificationIEC61360.value_list`
-        :py:attr:`ValueReferencePair.value_id`
-        the :py:attr:`DataSpecificationIEC61360.value` shall be set.
-    """
-
-    #: Reference to an external definition the concept is compatible to or was derived
-    #: from.
-    #:
-    #: .. note::
-    #:
-    #:     It is recommended to use a global reference.
-    #:
-    #: .. note::
-    #:
-    #:     Compare to is-case-of relationship in ISO 13584-32 & IEC EN 61360
-    is_case_of: Optional[List["Reference"]]
-
-    def over_is_case_of_or_empty(self) -> Iterator["Reference"]:
-        """Yield from :py:attr:`.is_case_of` if set."""
-        if self.is_case_of is not None:
-            yield from self.is_case_of
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.extensions is not None:
-            yield from self.extensions
-
-        if self.display_name is not None:
-            yield from self.display_name
-
-        if self.description is not None:
-            yield from self.description
-
-        if self.administration is not None:
-            yield self.administration
-
-        if self.embedded_data_specifications is not None:
-            yield from self.embedded_data_specifications
-
-        if self.is_case_of is not None:
-            yield from self.is_case_of
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.extensions is not None:
-            for an_item in self.extensions:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.display_name is not None:
-            for another_item in self.display_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.description is not None:
-            for yet_another_item in self.description:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.administration is not None:
-            yield self.administration
-
-            yield from self.administration.descend()
-
-        if self.embedded_data_specifications is not None:
-            for yet_yet_another_item in self.embedded_data_specifications:
-                yield yet_yet_another_item
-
-                yield from yet_yet_another_item.descend()
-
-        if self.is_case_of is not None:
-            for yet_yet_yet_another_item in self.is_case_of:
-                yield yet_yet_yet_another_item
-
-                yield from yet_yet_yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_concept_description(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_concept_description_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_concept_description(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_concept_description_with_context(self, context)
-
-    def __init__(
-        self,
-        id: str,
-        extensions: Optional[List["Extension"]] = None,
-        category: Optional[str] = None,
-        id_short: Optional[str] = None,
-        display_name: Optional[List["LangStringNameType"]] = None,
-        description: Optional[List["LangStringTextType"]] = None,
-        administration: Optional["AdministrativeInformation"] = None,
-        embedded_data_specifications: Optional[
-            List["EmbeddedDataSpecification"]
-        ] = None,
-        is_case_of: Optional[List["Reference"]] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        Identifiable.__init__(
-            self,
-            id,
-            extensions,
-            category,
-            id_short,
-            display_name,
-            description,
-            administration,
-        )
-        HasDataSpecification.__init__(self, embedded_data_specifications)
-        self.is_case_of = is_case_of
-
-
-class ReferenceTypes(enum.Enum):
-    """Reference types"""
-
-    #: External reference.
-    EXTERNAL_REFERENCE = "ExternalReference"
-
-    #: Model reference.
-    MODEL_REFERENCE = "ModelReference"
-
-
-class Reference(Class):
-    """
-    Reference to either a model element of the same or another AAS or to an external
-    entity.
-
-    A reference is an ordered list of keys.
-
-    A model reference is an ordered list of keys, each key referencing an element. The
-    complete list of keys may for example be concatenated to a path that then gives
-    unique access to an element.
-
-    An external reference is a reference to an external entity.
-
-    :constraint AASd-121:
-        .. _constraint_AASd-121:
-
-        For :py:class:`Reference`'s the value of :py:attr:`Key.type` of the first key of "
-        :py:attr:`keys` shall be one of :py:attr:`.constants.GLOBALLY_IDENTIFIABLES`.
-
-    :constraint AASd-122:
-        .. _constraint_AASd-122:
-
-        For external references, i.e. :py:class:`Reference`'s with
-        :py:attr:`type` = :py:attr:`ReferenceTypes.EXTERNAL_REFERENCE`, the value
-        of :py:attr:`Key.type` of the first key of :py:attr:`keys` shall be one of
-        :py:attr:`.constants.GENERIC_GLOBALLY_IDENTIFIABLES`.
-
-    :constraint AASd-123:
-        .. _constraint_AASd-123:
-
-        For model references, i.e. :py:class:`Reference`'s with
-        :py:attr:`type` = :py:attr:`ReferenceTypes.MODEL_REFERENCE`, the value
-        of :py:attr:`Key.type` of the first key of :py:attr:`keys` shall be one of
-        :py:attr:`.constants.AAS_IDENTIFIABLES`.
-
-    :constraint AASd-124:
-        .. _constraint_AASd-124:
-
-        For external references, i.e. :py:class:`Reference`'s with
-        :py:attr:`type` = :py:attr:`ReferenceTypes.EXTERNAL_REFERENCE`, the last
-        key of :py:attr:`keys` shall be either one of
-        :py:attr:`.constants.GENERIC_GLOBALLY_IDENTIFIABLES` or one of
-        :py:attr:`.constants.GENERIC_FRAGMENT_KEYS`.
-
-    :constraint AASd-125:
-        .. _constraint_AASd-125:
-
-        For model references, i.e. :py:class:`Reference`'s with
-        :py:attr:`type` = :py:attr:`ReferenceTypes.MODEL_REFERENCE`, with more
-        than one key in :py:attr:`keys` the value of :py:attr:`Key.type`
-        of each of the keys following the first
-        key of :py:attr:`keys` shall be one of :py:attr:`.constants.FRAGMENT_KEYS`.
-
-        .. note::
-
-            :ref:`Constraint AASd-125 <constraint_AASd-125>` ensures that the shortest path is used.
-
-    :constraint AASd-126:
-        .. _constraint_AASd-126:
-
-        For model references, i.e. :py:class:`Reference`'s with
-        :py:attr:`type` = :py:attr:`ReferenceTypes.MODEL_REFERENCE`, with more
-        than one key in :py:attr:`keys` the value of :py:attr:`Key.type`
-        of the last key in the reference key chain may be
-        one of :py:attr:`.constants.GENERIC_FRAGMENT_KEYS` or no key at all
-        shall have a value out of :py:attr:`.constants.GENERIC_FRAGMENT_KEYS`.
-
-    :constraint AASd-127:
-        .. _constraint_AASd-127:
-
-        For model references, i.e. :py:class:`Reference`'s with
-        :py:attr:`type` = :py:attr:`ReferenceTypes.MODEL_REFERENCE`, with more
-        than one key in :py:attr:`keys` a key with :py:attr:`Key.type`
-        :py:attr:`KeyTypes.FRAGMENT_REFERENCE` shall be preceded by a key with
-        :py:attr:`Key.type` :py:attr:`KeyTypes.FILE` or :py:attr:`KeyTypes.BLOB`. All other
-        AAS fragments, i.e. :py:attr:`Key.type` values
-        out of :py:attr:`.constants.AAS_SUBMODEL_ELEMENTS_AS_KEYS`, do not support fragments.
-
-        .. note::
-
-            Which kind of fragments are supported depends on the content type and the
-            specification of allowed fragment identifiers for the corresponding resource
-            being referenced via the reference.
-
-    :constraint AASd-128:
-        .. _constraint_AASd-128:
-
-        For model references, i.e. :py:class:`Reference`'s with
-        :py:attr:`type` = :py:attr:`ReferenceTypes.MODEL_REFERENCE`, the
-        :py:attr:`Key.value` of a :py:class:`Key` preceded by a :py:class:`Key` with
-        :py:attr:`Key.type` = :py:attr:`KeyTypes.SUBMODEL_ELEMENT_LIST` is an integer
-        number denoting the position in the array of the submodel element list.
-    """
-
-    #: Type of the reference.
-    #:
-    #: Denotes, whether reference is an external reference or a model reference.
-    type: "ReferenceTypes"
-
-    #: :py:attr:`HasSemantics.semantic_id` of the referenced model element
-    #: (:py:attr:`type` = :py:attr:`ReferenceTypes.MODEL_REFERENCE`).
-    #:
-    #: For external references there typically is no semantic ID.
-    #:
-    #: .. note::
-    #:
-    #:     It is recommended to use a external reference.
-    referred_semantic_id: Optional["Reference"]
-
-    #: Unique references in their name space.
-    keys: List["Key"]
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.referred_semantic_id is not None:
-            yield self.referred_semantic_id
-
-        yield from self.keys
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.referred_semantic_id is not None:
-            yield self.referred_semantic_id
-
-            yield from self.referred_semantic_id.descend()
-
-        for an_item in self.keys:
-            yield an_item
-
-            yield from an_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_reference(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_reference_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_reference(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_reference_with_context(self, context)
-
-    def __init__(
-        self,
-        type: "ReferenceTypes",
-        keys: List["Key"],
-        referred_semantic_id: Optional["Reference"] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        self.type = type
-        self.keys = keys
-        self.referred_semantic_id = referred_semantic_id
-
-
-class Key(Class):
-    """A key is a reference to an element by its ID."""
-
-    #: Denotes which kind of entity is referenced.
-    #:
-    #: In case :py:attr:`type` = :py:attr:`KeyTypes.FRAGMENT_REFERENCE` the key represents
-    #: a bookmark or a similar local identifier within its parent element as specified
-    #: by the key that precedes this key.
-    #:
-    #: In all other cases the key references a model element of the same or of another AAS.
-    #: The name of the model element is explicitly listed.
-    type: "KeyTypes"
-
-    #: The key value, for example an IRDI or an URI
-    value: str
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_key(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_key_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_key(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_key_with_context(self, context)
-
-    def __init__(self, type: "KeyTypes", value: str) -> None:
-        """Initialize with the given values."""
-        self.type = type
-        self.value = value
-
-
-class KeyTypes(enum.Enum):
-    """Enumeration of different key value types within a key."""
-
-    ANNOTATED_RELATIONSHIP_ELEMENT = "AnnotatedRelationshipElement"
-
-    ASSET_ADMINISTRATION_SHELL = "AssetAdministrationShell"
-
-    BASIC_EVENT_ELEMENT = "BasicEventElement"
-
-    BLOB = "Blob"
-
-    CAPABILITY = "Capability"
-
-    CONCEPT_DESCRIPTION = "ConceptDescription"
-
-    #: Data element.
-    #:
-    #: .. note::
-    #:
-    #:     Data Element is abstract, *i.e.* if a key uses :py:attr:`DATA_ELEMENT`
-    #:     the reference may be a Property, a File etc.
-    DATA_ELEMENT = "DataElement"
-
-    ENTITY = "Entity"
-
-    #: Event.
-    #:
-    #: .. note::
-    #:
-    #:     :py:class:`EventElement` is abstract.
-    EVENT_ELEMENT = "EventElement"
-
-    FILE = "File"
-
-    #: Bookmark or a similar local identifier of a subordinate part of
-    #: a primary resource
-    FRAGMENT_REFERENCE = "FragmentReference"
-
-    GLOBAL_REFERENCE = "GlobalReference"
-
-    #: Identifiable.
-    #:
-    #: .. note::
-    #:
-    #:     Identifiable is abstract, i.e. if a key uses Identifiable the reference
-    #:     may be an Asset Administration Shell, a Submodel or a Concept Description.
-    IDENTIFIABLE = "Identifiable"
-
-    #: Property with a value that can be provided in multiple languages
-    MULTI_LANGUAGE_PROPERTY = "MultiLanguageProperty"
-
-    OPERATION = "Operation"
-
-    PROPERTY = "Property"
-
-    #: Range with min and max
-    RANGE = "Range"
-
-    REFERABLE = "Referable"
-
-    #: Reference
-    REFERENCE_ELEMENT = "ReferenceElement"
-
-    #: Relationship
-    RELATIONSHIP_ELEMENT = "RelationshipElement"
-
-    SUBMODEL = "Submodel"
-
-    #: Submodel Element
-    #:
-    #: .. note::
-    #:
-    #:     Submodel Element is abstract, *i.e.* if a key uses :py:attr:`SUBMODEL_ELEMENT`
-    #:     the reference may be a :py:class:`Property`, an :py:class:`Operation` etc.
-    SUBMODEL_ELEMENT = "SubmodelElement"
-
-    #: Struct of Submodel Elements
-    SUBMODEL_ELEMENT_COLLECTION = "SubmodelElementCollection"
-
-    #: List of Submodel Elements
-    SUBMODEL_ELEMENT_LIST = "SubmodelElementList"
-
-
-class DataTypeDefXSD(enum.Enum):
-    """Enumeration listing all XSD anySimpleTypes"""
-
-    ANY_URI = "xs:anyURI"
-
-    BASE_64_BINARY = "xs:base64Binary"
-
-    BOOLEAN = "xs:boolean"
-
-    BYTE = "xs:byte"
-
-    DATE = "xs:date"
-
-    DATE_TIME = "xs:dateTime"
-
-    DECIMAL = "xs:decimal"
-
-    DOUBLE = "xs:double"
-
-    DURATION = "xs:duration"
-
-    FLOAT = "xs:float"
-
-    G_DAY = "xs:gDay"
-
-    G_MONTH = "xs:gMonth"
-
-    G_MONTH_DAY = "xs:gMonthDay"
-
-    G_YEAR = "xs:gYear"
-
-    G_YEAR_MONTH = "xs:gYearMonth"
-
-    HEX_BINARY = "xs:hexBinary"
-
-    INT = "xs:int"
-
-    INTEGER = "xs:integer"
-
-    LONG = "xs:long"
-
-    NEGATIVE_INTEGER = "xs:negativeInteger"
-
-    NON_NEGATIVE_INTEGER = "xs:nonNegativeInteger"
-
-    NON_POSITIVE_INTEGER = "xs:nonPositiveInteger"
-
-    POSITIVE_INTEGER = "xs:positiveInteger"
-
-    SHORT = "xs:short"
-
-    STRING = "xs:string"
-
-    TIME = "xs:time"
-
-    UNSIGNED_BYTE = "xs:unsignedByte"
-
-    UNSIGNED_INT = "xs:unsignedInt"
-
-    UNSIGNED_LONG = "xs:unsignedLong"
-
-    UNSIGNED_SHORT = "xs:unsignedShort"
-
-
-class AbstractLangString(Class):
-    """Strings with language tags"""
-
-    #: Language tag conforming to BCP 47
-    language: str
-
-    #: Text in the :py:attr:`language`
-    text: str
-
-    def __init__(self, language: str, text: str) -> None:
-        """Initialize with the given values."""
-        self.language = language
-        self.text = text
-
-
-class LangStringNameType(AbstractLangString):
-    """
-    String with length 128 maximum and minimum 1 characters and with language tags
-    """
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_lang_string_name_type(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_lang_string_name_type_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_lang_string_name_type(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_lang_string_name_type_with_context(self, context)
-
-    def __init__(self, language: str, text: str) -> None:
-        """Initialize with the given values."""
-        AbstractLangString.__init__(self, language, text)
-
-
-class LangStringTextType(AbstractLangString):
-    """
-    String with length 1023 maximum and minimum 1 characters and with language tags
-    """
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_lang_string_text_type(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_lang_string_text_type_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_lang_string_text_type(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_lang_string_text_type_with_context(self, context)
-
-    def __init__(self, language: str, text: str) -> None:
-        """Initialize with the given values."""
-        AbstractLangString.__init__(self, language, text)
-
-
-class Environment(Class):
-    """
-    Container for the sets of different identifiables.
-
-    .. note::
-
-        w.r.t. file exchange: There is exactly one environment independent on how many
-        files the contained elements are split. If the file is split then there
-        shall be no element with the same identifier in two different files.
-    """
-
-    #: Asset administration shell
-    asset_administration_shells: Optional[List["AssetAdministrationShell"]]
-
-    #: Submodel
-    submodels: Optional[List["Submodel"]]
-
-    #: Concept description
-    concept_descriptions: Optional[List["ConceptDescription"]]
-
-    def over_asset_administration_shells_or_empty(
-        self,
-    ) -> Iterator["AssetAdministrationShell"]:
-        """Yield from :py:attr:`.asset_administration_shells` if set."""
-        if self.asset_administration_shells is not None:
-            yield from self.asset_administration_shells
-
-    def over_submodels_or_empty(self) -> Iterator["Submodel"]:
-        """Yield from :py:attr:`.submodels` if set."""
-        if self.submodels is not None:
-            yield from self.submodels
-
-    def over_concept_descriptions_or_empty(self) -> Iterator["ConceptDescription"]:
-        """Yield from :py:attr:`.concept_descriptions` if set."""
-        if self.concept_descriptions is not None:
-            yield from self.concept_descriptions
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        if self.asset_administration_shells is not None:
-            yield from self.asset_administration_shells
-
-        if self.submodels is not None:
-            yield from self.submodels
-
-        if self.concept_descriptions is not None:
-            yield from self.concept_descriptions
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        if self.asset_administration_shells is not None:
-            for an_item in self.asset_administration_shells:
-                yield an_item
-
-                yield from an_item.descend()
-
-        if self.submodels is not None:
-            for another_item in self.submodels:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.concept_descriptions is not None:
-            for yet_another_item in self.concept_descriptions:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_environment(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_environment_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_environment(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_environment_with_context(self, context)
-
-    def __init__(
-        self,
-        asset_administration_shells: Optional[List["AssetAdministrationShell"]] = None,
-        submodels: Optional[List["Submodel"]] = None,
-        concept_descriptions: Optional[List["ConceptDescription"]] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        self.asset_administration_shells = asset_administration_shells
-        self.submodels = submodels
-        self.concept_descriptions = concept_descriptions
-
-
-class DataSpecificationContent(Class):
-    """
-    Data specification content is part of a data specification template and defines
-    which additional attributes shall be added to the element instance that references
-    the data specification template and meta information about the template itself.
-
-    :constraint AASc-3a-050:
-        .. _constraint_AASc-3a-050:
-
-        If the :py:class:`DataSpecificationIEC61360` is used
-        for an element, the value of
-        :py:attr:`HasDataSpecification.embedded_data_specifications`
-        shall contain the global reference to the IRI of the corresponding
-        data specification template
-        https://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/3/0
-    """
-
-
-class EmbeddedDataSpecification(Class):
-    """Embed the content of a data specification."""
-
-    #: Reference to the data specification
-    data_specification: "Reference"
-
-    #: Actual content of the data specification
-    data_specification_content: "DataSpecificationContent"
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        yield self.data_specification
-
-        yield self.data_specification_content
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        yield self.data_specification
-
-        yield from self.data_specification.descend()
-
-        yield self.data_specification_content
-
-        yield from self.data_specification_content.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_embedded_data_specification(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_embedded_data_specification_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_embedded_data_specification(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_embedded_data_specification_with_context(
-            self, context
-        )
-
-    def __init__(
-        self,
-        data_specification: "Reference",
-        data_specification_content: "DataSpecificationContent",
-    ) -> None:
-        """Initialize with the given values."""
-        self.data_specification = data_specification
-        self.data_specification_content = data_specification_content
-
-
-class DataTypeIEC61360(enum.Enum):
-    # pylint: disable=missing-class-docstring
-
-    #: values containing a calendar date, conformant to ISO 8601:2004 Format yyyy-mm-dd
-    #: Example from IEC 61360-1:2017: "1999-05-31" is the [DATE] representation of:
-    #: "31 May 1999".
-    DATE = "DATE"
-
-    #: values consisting of sequence of characters but cannot be translated into other
-    #: languages
-    STRING = "STRING"
-
-    #: values containing string but shall be represented as different string in different
-    #: languages
-    STRING_TRANSLATABLE = "STRING_TRANSLATABLE"
-
-    #: values containing values that are measure of type INTEGER. In addition such a value
-    #: comes with a physical unit.
-    INTEGER_MEASURE = "INTEGER_MEASURE"
-
-    #: values containing values of type INTEGER but are no currencies or measures
-    INTEGER_COUNT = "INTEGER_COUNT"
-
-    #: values containing values of type INTEGER that are currencies
-    INTEGER_CURRENCY = "INTEGER_CURRENCY"
-
-    #: values containing values that are measures of type REAL. In addition such a value
-    #: comes with a physical unit.
-    REAL_MEASURE = "REAL_MEASURE"
-
-    #: values containing numbers that can be written as a terminating or non-terminating
-    #: decimal; a rational or irrational number but are no currencies or measures
-    REAL_COUNT = "REAL_COUNT"
-
-    #: values containing values of type REAL that are currencies
-    REAL_CURRENCY = "REAL_CURRENCY"
-
-    #: values representing truth of logic or Boolean algebra (TRUE, FALSE)
-    BOOLEAN = "BOOLEAN"
-
-    #: values containing values of type STRING conformant to Rfc 3987
-    #:
-    #: .. note::
-    #:
-    #:     In IEC61360-1 (2017) only URI is supported.
-    #:     An IRI type allows in particular to express an URL or an URI.
-    IRI = "IRI"
-
-    #: values conforming to ISO/IEC 11179 series global identifier sequences
-    #:
-    #: IRDI can be used instead of the more specific data types ICID or ISO29002_IRDI.
-    #:
-    #: ICID values are value conformant to an IRDI, where the delimiter between RAI and ID
-    #: is # while the delimiter between DI and VI is confined to ##
-    #:
-    #: ISO29002_IRDI values are values containing a global identifier that identifies an
-    #: administrated item in a registry. The structure of this identifier complies with
-    #: identifier syntax defined in ISO/TS 29002-5. The identifier shall fulfil the
-    #: requirements specified in ISO/TS 29002-5 for an "international registration data
-    #: identifier" (IRDI).
-    IRDI = "IRDI"
-
-    #: values containing values of type rational
-    RATIONAL = "RATIONAL"
-
-    #: values containing values of type rational. In addition such a value comes with a
-    #: physical unit.
-    RATIONAL_MEASURE = "RATIONAL_MEASURE"
-
-    #: values containing a time, conformant to ISO 8601:2004 but restricted to what is
-    #: allowed in the corresponding type in xml.
-    #:
-    #: Format hh:mm (ECLASS)
-    #:
-    #: Example from IEC 61360-1:2017: "13:20:00-05:00" is the [TIME] representation of:
-    #: 1.20 p.m. for Eastern Standard Time, which is 5 hours behind Coordinated
-    #: Universal Time (UTC).
-    TIME = "TIME"
-
-    #: values containing a time, conformant to ISO 8601:2004 but restricted to what is
-    #: allowed in the corresponding type in xml.
-    #:
-    #: Format yyyy-mm-dd hh:mm (ECLASS)
-    TIMESTAMP = "TIMESTAMP"
-
-    #: values containing an address to a file. The values are of type URI and can represent
-    #: an absolute or relative path.
-    #:
-    #: .. note::
-    #:
-    #:     IEC61360 does not support the file type.
-    FILE = "FILE"
-
-    #: Values containing string with any sequence of characters, using the syntax of HTML5
-    #: (see W3C Recommendation 28:2014)
-    HTML = "HTML"
-
-    #: values containing the content of a file. Values may be binaries.
-    #:
-    #: HTML conformant to HTML5 is a special blob.
-    #:
-    #: In IEC61360 binary is for a sequence of bits, each bit being represented by 0 and
-    #: 1 only. A binary is a blob but a blob may also contain other source code.
-    BLOB = "BLOB"
-
-
-class LevelType(Class):
-    """
-    Value represented by up to four variants of a numeric value in a specific role:
-    ``MIN``, ``NOM``, ``TYP`` and ``MAX``. True means that the value is available,
-    false means the value is not available.
-
-    EXAMPLE from [IEC61360-1]: In the case of having a property which is
-    of the LEVEL_TYPE min/max  expressing a range  only those two values
-    need to be provided.
-
-    .. note::
-
-        This is how AAS deals with the following combinations of level types:
-
-        * Either all attributes are false. In this case the concept is mapped
-          to a :py:class:`Property` and level type is ignored.
-        * At most one of the attributes is set to true. In this case
-          the concept is mapped to a :py:class:`Property`.
-        * Min and max are set to true. In this case the concept is mapped
-          to a :py:class:`Range`.
-        * More than one attribute is set to true but not min and max only
-          (see second case). In this case the concept is mapped
-          to a :py:class:`SubmodelElementCollection` with the corresponding
-          number of Properties.
-          Example: If attribute :py:attr:`min` and :py:attr:`nom` are set to true
-          then the concept is mapped to a :py:class:`SubmodelElementCollection`
-          with two Properties within: min and nom.
-          The data type of both Properties is the same.
-
-    .. note::
-
-        In the cases 2. and 4. the :py:attr:`Property.semantic_id` of the Property
-        or Properties within the :py:class:`SubmodelElementCollection` needs to include
-        information about the level type. Otherwise, the semantics is not described
-        in a unique way. Please refer to the specification.
-    """
-
-    #: Minimum of the value
-    min: bool
-
-    #: Nominal value (value as designated)
-    nom: bool
-
-    #: Value as typically present
-    typ: bool
-
-    #: Maximum of the value
-    max: bool
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_level_type(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_level_type_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_level_type(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_level_type_with_context(self, context)
-
-    def __init__(self, min: bool, nom: bool, typ: bool, max: bool) -> None:
-        """Initialize with the given values."""
-        self.min = min
-        self.nom = nom
-        self.typ = typ
-        self.max = max
-
-
-class ValueReferencePair(Class):
-    """
-    A value reference pair within a value list. Each value has a global unique id
-    defining its semantic.
-    """
-
-    #: The value of the referenced concept definition of the value in :py:attr:`value_id`.
-    value: str
-
-    #: Global unique id of the value.
-    #:
-    #: .. note::
-    #:
-    #:     It is recommended to use a global reference.
-    value_id: "Reference"
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        yield self.value_id
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        yield self.value_id
-
-        yield from self.value_id.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_value_reference_pair(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_value_reference_pair_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_value_reference_pair(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_value_reference_pair_with_context(self, context)
-
-    def __init__(self, value: str, value_id: "Reference") -> None:
-        """Initialize with the given values."""
-        self.value = value
-        self.value_id = value_id
-
-
-class ValueList(Class):
-    """A set of value reference pairs."""
-
-    #: A pair of a value together with its global unique id.
-    value_reference_pairs: List["ValueReferencePair"]
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        yield from self.value_reference_pairs
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        for an_item in self.value_reference_pairs:
-            yield an_item
-
-            yield from an_item.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_value_list(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_value_list_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_value_list(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_value_list_with_context(self, context)
-
-    def __init__(self, value_reference_pairs: List["ValueReferencePair"]) -> None:
-        """Initialize with the given values."""
-        self.value_reference_pairs = value_reference_pairs
-
-
-class LangStringPreferredNameTypeIEC61360(AbstractLangString):
-    """
-    String with length 255 maximum and minimum 1 characters and with language tags
-
-    .. note::
-
-        It is advised to keep the length of the name limited to 35 characters.
-    """
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_lang_string_preferred_name_type_iec_61360(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_lang_string_preferred_name_type_iec_61360_with_context(
-            self, context
-        )
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_lang_string_preferred_name_type_iec_61360(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_lang_string_preferred_name_type_iec_61360_with_context(
-            self, context
-        )
-
-    def __init__(self, language: str, text: str) -> None:
-        """Initialize with the given values."""
-        AbstractLangString.__init__(self, language, text)
-
-
-class LangStringShortNameTypeIEC61360(AbstractLangString):
-    """
-    String with length 18 maximum and minimum 1 characters and with language tags
-    """
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_lang_string_short_name_type_iec_61360(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_lang_string_short_name_type_iec_61360_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_lang_string_short_name_type_iec_61360(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_lang_string_short_name_type_iec_61360_with_context(
-            self, context
-        )
-
-    def __init__(self, language: str, text: str) -> None:
-        """Initialize with the given values."""
-        AbstractLangString.__init__(self, language, text)
-
-
-class LangStringDefinitionTypeIEC61360(AbstractLangString):
-    """
-    String with length 1023 maximum and minimum 1 characters and with language tags
-    """
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        # No descendable properties
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_lang_string_definition_type_iec_61360(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_lang_string_definition_type_iec_61360_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_lang_string_definition_type_iec_61360(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_lang_string_definition_type_iec_61360_with_context(
-            self, context
-        )
-
-    def __init__(self, language: str, text: str) -> None:
-        """Initialize with the given values."""
-        AbstractLangString.__init__(self, language, text)
-
-
-class DataSpecificationIEC61360(DataSpecificationContent):
-    """
-    Content of data specification template for concept descriptions for properties,
-    values and value lists conformant to IEC 61360.
-
-    .. note::
-
-        It is also possible that both :py:attr:`value` and :py:attr:`value_list` are empty.
-        This is the case for concept descriptions that define the semantics of a
-        property but do not have an enumeration (:py:attr:`value_list`) as data type.
-
-    .. note::
-
-        Although it is possible to define a :py:class:`ConceptDescription` for a
-        :attr:value_list`,
-        it is not possible to reuse this :py:attr:`value_list`.
-        It is only possible to directly add a :py:attr:`value_list` as data type
-        to a specific semantic definition of a property.
-
-    .. note::
-
-        IEC61360 requires also a globally unique identifier for a concept
-        description. This ID is not part of the data specification template.
-        Instead the :py:attr:`ConceptDescription.id` as inherited via
-        :py:class:`Identifiable` is used. Same holds for administrative
-        information like the version and revision.
-
-    .. note::
-
-        :py:attr:`ConceptDescription.id_short` and :py:attr:`short_name` are very
-        similar. However, in this case the decision was to add
-        :py:attr:`short_name` explicitly to the data specification. Same holds for
-        :py:attr:`ConceptDescription.display_name` and
-        :py:attr:`preferred_name`. Same holds for
-        :py:attr:`ConceptDescription.description` and :py:attr:`definition`.
-
-    :constraint AASc-3a-009:
-        .. _constraint_AASc-3a-009:
-
-        If :py:attr:`data_type` one of:
-        :py:attr:`DataTypeIEC61360.INTEGER_MEASURE`,
-        :py:attr:`DataTypeIEC61360.REAL_MEASURE`,
-        :py:attr:`DataTypeIEC61360.RATIONAL_MEASURE`,
-        :py:attr:`DataTypeIEC61360.INTEGER_CURRENCY`,
-        :py:attr:`DataTypeIEC61360.REAL_CURRENCY`, then :py:attr:`unit` or
-        :py:attr:`unit_id` shall be defined.
-    """
-
-    #: Preferred name
-    #:
-    #: .. note::
-    #:
-    #:     It is advised to keep the length of the name limited to 35 characters.
-    #:
-    #: :constraint AASc-3a-002:
-    #:     .. _constraint_AASc-3a-002:
-    #:
-    #:     :py:attr:`preferred_name` shall be provided at least in English.
-    preferred_name: List["LangStringPreferredNameTypeIEC61360"]
-
-    #: Short name
-    short_name: Optional[List["LangStringShortNameTypeIEC61360"]]
-
-    #: Unit
-    unit: Optional[str]
-
-    #: Unique unit id
-    #:
-    #: :py:attr:`unit` and :py:attr:`unit_id` need to be consistent if both attributes
-    #: are set
-    #:
-    #: .. note::
-    #:
-    #:     It is recommended to use an external reference ID.
-    unit_id: Optional["Reference"]
-
-    #: Source of definition
-    source_of_definition: Optional[str]
-
-    #: Symbol
-    symbol: Optional[str]
-
-    #: Data Type
-    data_type: Optional["DataTypeIEC61360"]
-
-    #: Definition in different languages
-    definition: Optional[List["LangStringDefinitionTypeIEC61360"]]
-
-    #: Value Format
-    #:
-    #: .. note::
-    #:
-    #:     The value format is based on ISO 13584-42 and IEC 61360-2.
-    value_format: Optional[str]
-
-    #: List of allowed values
-    value_list: Optional["ValueList"]
-
-    #: Value
-    value: Optional[str]
-
-    #: Set of levels.
-    level_type: Optional["LevelType"]
-
-    def over_short_name_or_empty(self) -> Iterator["LangStringShortNameTypeIEC61360"]:
-        """Yield from :py:attr:`.short_name` if set."""
-        if self.short_name is not None:
-            yield from self.short_name
-
-    def over_definition_or_empty(self) -> Iterator["LangStringDefinitionTypeIEC61360"]:
-        """Yield from :py:attr:`.definition` if set."""
-        if self.definition is not None:
-            yield from self.definition
-
-    def descend_once(self) -> Iterator[Class]:
-        """
-        Iterate over the instances referenced from this instance.
-
-        We do not recurse into the referenced instance.
-
-        :yield: instances directly referenced from this instance
-        """
-        yield from self.preferred_name
-
-        if self.short_name is not None:
-            yield from self.short_name
-
-        if self.unit_id is not None:
-            yield self.unit_id
-
-        if self.definition is not None:
-            yield from self.definition
-
-        if self.value_list is not None:
-            yield self.value_list
-
-        if self.level_type is not None:
-            yield self.level_type
-
-    def descend(self) -> Iterator[Class]:
-        """
-        Iterate recursively over the instances referenced from this one.
-
-        :yield: instances recursively referenced from this instance
-        """
-        for an_item in self.preferred_name:
-            yield an_item
-
-            yield from an_item.descend()
-
-        if self.short_name is not None:
-            for another_item in self.short_name:
-                yield another_item
-
-                yield from another_item.descend()
-
-        if self.unit_id is not None:
-            yield self.unit_id
-
-            yield from self.unit_id.descend()
-
-        if self.definition is not None:
-            for yet_another_item in self.definition:
-                yield yet_another_item
-
-                yield from yet_another_item.descend()
-
-        if self.value_list is not None:
-            yield self.value_list
-
-            yield from self.value_list.descend()
-
-        if self.level_type is not None:
-            yield self.level_type
-
-            yield from self.level_type.descend()
-
-    def accept(self, visitor: "AbstractVisitor") -> None:
-        """Dispatch the :paramref:`visitor` on this instance."""
-        visitor.visit_data_specification_iec_61360(self)
-
-    def accept_with_context(
-        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
-    ) -> None:
-        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
-        visitor.visit_data_specification_iec_61360_with_context(self, context)
-
-    def transform(self, transformer: "AbstractTransformer[T]") -> T:
-        """Dispatch the :paramref:`transformer` on this instance."""
-        return transformer.transform_data_specification_iec_61360(self)
-
-    def transform_with_context(
-        self,
-        transformer: "AbstractTransformerWithContext[ContextT, T]",
-        context: ContextT,
-    ) -> T:
-        """
-        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
-        """
-        return transformer.transform_data_specification_iec_61360_with_context(
-            self, context
-        )
-
-    def __init__(
-        self,
-        preferred_name: List["LangStringPreferredNameTypeIEC61360"],
-        short_name: Optional[List["LangStringShortNameTypeIEC61360"]] = None,
-        unit: Optional[str] = None,
-        unit_id: Optional["Reference"] = None,
-        source_of_definition: Optional[str] = None,
-        symbol: Optional[str] = None,
-        data_type: Optional["DataTypeIEC61360"] = None,
-        definition: Optional[List["LangStringDefinitionTypeIEC61360"]] = None,
-        value_format: Optional[str] = None,
-        value_list: Optional["ValueList"] = None,
-        value: Optional[str] = None,
-        level_type: Optional["LevelType"] = None,
-    ) -> None:
-        """Initialize with the given values."""
-        self.preferred_name = preferred_name
-        self.short_name = short_name
-        self.unit = unit
-        self.unit_id = unit_id
-        self.source_of_definition = source_of_definition
-        self.symbol = symbol
-        self.data_type = data_type
-        self.definition = definition
-        self.value_format = value_format
-        self.value_list = value_list
-        self.value = value
-        self.level_type = level_type
-
-
-class AbstractVisitor:
-    """Visit the instances of the model."""
-
-    def visit(self, that: Class) -> None:
-        """Double-dispatch on :paramref:`that`."""
-        that.accept(self)
-
-    @abc.abstractmethod
-    def visit_extension(self, that: Extension) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_administrative_information(self, that: AdministrativeInformation) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_qualifier(self, that: Qualifier) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_asset_administration_shell(self, that: AssetAdministrationShell) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_asset_information(self, that: AssetInformation) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_resource(self, that: Resource) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_specific_asset_id(self, that: SpecificAssetID) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_submodel(self, that: Submodel) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_relationship_element(self, that: RelationshipElement) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_submodel_element_list(self, that: SubmodelElementList) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_submodel_element_collection(
-        self, that: SubmodelElementCollection
-    ) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_property(self, that: Property) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_multi_language_property(self, that: MultiLanguageProperty) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_range(self, that: Range) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_reference_element(self, that: ReferenceElement) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_blob(self, that: Blob) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_file(self, that: File) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_annotated_relationship_element(
-        self, that: AnnotatedRelationshipElement
-    ) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_entity(self, that: Entity) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_event_payload(self, that: EventPayload) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_basic_event_element(self, that: BasicEventElement) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_operation(self, that: Operation) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_operation_variable(self, that: OperationVariable) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_capability(self, that: Capability) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_concept_description(self, that: ConceptDescription) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_reference(self, that: Reference) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_key(self, that: Key) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_lang_string_name_type(self, that: LangStringNameType) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_lang_string_text_type(self, that: LangStringTextType) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_environment(self, that: Environment) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_embedded_data_specification(
-        self, that: EmbeddedDataSpecification
-    ) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_level_type(self, that: LevelType) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_value_reference_pair(self, that: ValueReferencePair) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_value_list(self, that: ValueList) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_lang_string_preferred_name_type_iec_61360(
-        self, that: LangStringPreferredNameTypeIEC61360
-    ) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_lang_string_short_name_type_iec_61360(
-        self, that: LangStringShortNameTypeIEC61360
-    ) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_lang_string_definition_type_iec_61360(
-        self, that: LangStringDefinitionTypeIEC61360
-    ) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_data_specification_iec_61360(
-        self, that: DataSpecificationIEC61360
-    ) -> None:
-        """Visit :paramref:`that`."""
-        raise NotImplementedError()
-
-
-class AbstractVisitorWithContext(Generic[ContextT]):
-    """Visit the instances of the model with context."""
-
-    def visit_with_context(self, that: Class, context: ContextT) -> None:
-        """Double-dispatch on :paramref:`that`."""
-        that.accept_with_context(self, context)
-
-    @abc.abstractmethod
-    def visit_extension_with_context(self, that: Extension, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_administrative_information_with_context(
-        self, that: AdministrativeInformation, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_qualifier_with_context(self, that: Qualifier, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_asset_administration_shell_with_context(
-        self, that: AssetAdministrationShell, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_asset_information_with_context(
-        self, that: AssetInformation, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_resource_with_context(self, that: Resource, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_specific_asset_id_with_context(
-        self, that: SpecificAssetID, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_submodel_with_context(self, that: Submodel, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_relationship_element_with_context(
-        self, that: RelationshipElement, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_submodel_element_list_with_context(
-        self, that: SubmodelElementList, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_submodel_element_collection_with_context(
-        self, that: SubmodelElementCollection, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_property_with_context(self, that: Property, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_multi_language_property_with_context(
-        self, that: MultiLanguageProperty, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_range_with_context(self, that: Range, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_reference_element_with_context(
-        self, that: ReferenceElement, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_blob_with_context(self, that: Blob, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_file_with_context(self, that: File, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_annotated_relationship_element_with_context(
-        self, that: AnnotatedRelationshipElement, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_entity_with_context(self, that: Entity, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_event_payload_with_context(
-        self, that: EventPayload, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_basic_event_element_with_context(
-        self, that: BasicEventElement, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_operation_with_context(self, that: Operation, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_operation_variable_with_context(
-        self, that: OperationVariable, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_capability_with_context(
-        self, that: Capability, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_concept_description_with_context(
-        self, that: ConceptDescription, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_reference_with_context(self, that: Reference, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_key_with_context(self, that: Key, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_lang_string_name_type_with_context(
-        self, that: LangStringNameType, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_lang_string_text_type_with_context(
-        self, that: LangStringTextType, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_environment_with_context(
-        self, that: Environment, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_embedded_data_specification_with_context(
-        self, that: EmbeddedDataSpecification, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_level_type_with_context(self, that: LevelType, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_value_reference_pair_with_context(
-        self, that: ValueReferencePair, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_value_list_with_context(self, that: ValueList, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_lang_string_preferred_name_type_iec_61360_with_context(
-        self, that: LangStringPreferredNameTypeIEC61360, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_lang_string_short_name_type_iec_61360_with_context(
-        self, that: LangStringShortNameTypeIEC61360, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_lang_string_definition_type_iec_61360_with_context(
-        self, that: LangStringDefinitionTypeIEC61360, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def visit_data_specification_iec_61360_with_context(
-        self, that: DataSpecificationIEC61360, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-
-class PassThroughVisitor(AbstractVisitor):
-    """
-    Visit the instances of the model without action.
-
-    This visitor is not meant to be directly used. Instead, you usually
-    inherit from it, and implement only the relevant visit methods.
-    """
-
-    def visit(self, that: Class) -> None:
-        """Double-dispatch on :paramref:`that`."""
-        that.accept(self)
-
-    def visit_extension(self, that: Extension) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_administrative_information(self, that: AdministrativeInformation) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_qualifier(self, that: Qualifier) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_asset_administration_shell(self, that: AssetAdministrationShell) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_asset_information(self, that: AssetInformation) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_resource(self, that: Resource) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_specific_asset_id(self, that: SpecificAssetID) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_submodel(self, that: Submodel) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_relationship_element(self, that: RelationshipElement) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_submodel_element_list(self, that: SubmodelElementList) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_submodel_element_collection(
-        self, that: SubmodelElementCollection
-    ) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_property(self, that: Property) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_multi_language_property(self, that: MultiLanguageProperty) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_range(self, that: Range) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_reference_element(self, that: ReferenceElement) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_blob(self, that: Blob) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_file(self, that: File) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_annotated_relationship_element(
-        self, that: AnnotatedRelationshipElement
-    ) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_entity(self, that: Entity) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_event_payload(self, that: EventPayload) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_basic_event_element(self, that: BasicEventElement) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_operation(self, that: Operation) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_operation_variable(self, that: OperationVariable) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_capability(self, that: Capability) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_concept_description(self, that: ConceptDescription) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_reference(self, that: Reference) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_key(self, that: Key) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_lang_string_name_type(self, that: LangStringNameType) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_lang_string_text_type(self, that: LangStringTextType) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_environment(self, that: Environment) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_embedded_data_specification(
-        self, that: EmbeddedDataSpecification
-    ) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_level_type(self, that: LevelType) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_value_reference_pair(self, that: ValueReferencePair) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_value_list(self, that: ValueList) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_lang_string_preferred_name_type_iec_61360(
-        self, that: LangStringPreferredNameTypeIEC61360
-    ) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_lang_string_short_name_type_iec_61360(
-        self, that: LangStringShortNameTypeIEC61360
-    ) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_lang_string_definition_type_iec_61360(
-        self, that: LangStringDefinitionTypeIEC61360
-    ) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-    def visit_data_specification_iec_61360(
-        self, that: DataSpecificationIEC61360
-    ) -> None:
-        """Visit :paramref:`that`."""
-        for another in that.descend_once():
-            self.visit(another)
-
-
-class PassThroughVisitorWithContext(AbstractVisitorWithContext[ContextT]):
-    """
-    Visit the instances of the model without action and in context.
-
-    This visitor is not meant to be directly used. Instead, you usually
-    inherit from it, and implement only the relevant visit methods.
-    """
-
-    def visit_with_context(self, that: Class, context: ContextT) -> None:
-        """Double-dispatch on :paramref:`that`."""
-        that.accept_with_context(self, context)
-
-    def visit_extension_with_context(self, that: Extension, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_administrative_information_with_context(
-        self, that: AdministrativeInformation, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_qualifier_with_context(self, that: Qualifier, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_asset_administration_shell_with_context(
-        self, that: AssetAdministrationShell, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_asset_information_with_context(
-        self, that: AssetInformation, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_resource_with_context(self, that: Resource, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_specific_asset_id_with_context(
-        self, that: SpecificAssetID, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_submodel_with_context(self, that: Submodel, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_relationship_element_with_context(
-        self, that: RelationshipElement, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_submodel_element_list_with_context(
-        self, that: SubmodelElementList, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_submodel_element_collection_with_context(
-        self, that: SubmodelElementCollection, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_property_with_context(self, that: Property, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_multi_language_property_with_context(
-        self, that: MultiLanguageProperty, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_range_with_context(self, that: Range, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_reference_element_with_context(
-        self, that: ReferenceElement, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_blob_with_context(self, that: Blob, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_file_with_context(self, that: File, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_annotated_relationship_element_with_context(
-        self, that: AnnotatedRelationshipElement, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_entity_with_context(self, that: Entity, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_event_payload_with_context(
-        self, that: EventPayload, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_basic_event_element_with_context(
-        self, that: BasicEventElement, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_operation_with_context(self, that: Operation, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_operation_variable_with_context(
-        self, that: OperationVariable, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_capability_with_context(
-        self, that: Capability, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_concept_description_with_context(
-        self, that: ConceptDescription, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_reference_with_context(self, that: Reference, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_key_with_context(self, that: Key, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_lang_string_name_type_with_context(
-        self, that: LangStringNameType, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_lang_string_text_type_with_context(
-        self, that: LangStringTextType, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_environment_with_context(
-        self, that: Environment, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_embedded_data_specification_with_context(
-        self, that: EmbeddedDataSpecification, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_level_type_with_context(self, that: LevelType, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_value_reference_pair_with_context(
-        self, that: ValueReferencePair, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_value_list_with_context(self, that: ValueList, context: ContextT) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_lang_string_preferred_name_type_iec_61360_with_context(
-        self, that: LangStringPreferredNameTypeIEC61360, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_lang_string_short_name_type_iec_61360_with_context(
-        self, that: LangStringShortNameTypeIEC61360, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_lang_string_definition_type_iec_61360_with_context(
-        self, that: LangStringDefinitionTypeIEC61360, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-    def visit_data_specification_iec_61360_with_context(
-        self, that: DataSpecificationIEC61360, context: ContextT
-    ) -> None:
-        """Visit :paramref:`that` in :paramref:`context`."""
-        for another in that.descend_once():
-            self.visit_with_context(another, context)
-
-
-class AbstractTransformer(Generic[T]):
-    """Transform the instances of the model."""
-
-    def transform(self, that: Class) -> T:
-        """Double-dispatch on :paramref:`that`."""
-        return that.transform(self)
-
-    @abc.abstractmethod
-    def transform_extension(self, that: Extension) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_administrative_information(
-        self, that: AdministrativeInformation
-    ) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_qualifier(self, that: Qualifier) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_asset_administration_shell(self, that: AssetAdministrationShell) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_asset_information(self, that: AssetInformation) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_resource(self, that: Resource) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_specific_asset_id(self, that: SpecificAssetID) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_submodel(self, that: Submodel) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_relationship_element(self, that: RelationshipElement) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_submodel_element_list(self, that: SubmodelElementList) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_submodel_element_collection(
-        self, that: SubmodelElementCollection
-    ) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_property(self, that: Property) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_multi_language_property(self, that: MultiLanguageProperty) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_range(self, that: Range) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_reference_element(self, that: ReferenceElement) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_blob(self, that: Blob) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_file(self, that: File) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_annotated_relationship_element(
-        self, that: AnnotatedRelationshipElement
-    ) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_entity(self, that: Entity) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_event_payload(self, that: EventPayload) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_basic_event_element(self, that: BasicEventElement) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_operation(self, that: Operation) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_operation_variable(self, that: OperationVariable) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_capability(self, that: Capability) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_concept_description(self, that: ConceptDescription) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_reference(self, that: Reference) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_key(self, that: Key) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_lang_string_name_type(self, that: LangStringNameType) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_lang_string_text_type(self, that: LangStringTextType) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_environment(self, that: Environment) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_embedded_data_specification(
-        self, that: EmbeddedDataSpecification
-    ) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_level_type(self, that: LevelType) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_value_reference_pair(self, that: ValueReferencePair) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_value_list(self, that: ValueList) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_lang_string_preferred_name_type_iec_61360(
-        self, that: LangStringPreferredNameTypeIEC61360
-    ) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_lang_string_short_name_type_iec_61360(
-        self, that: LangStringShortNameTypeIEC61360
-    ) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_lang_string_definition_type_iec_61360(
-        self, that: LangStringDefinitionTypeIEC61360
-    ) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_data_specification_iec_61360(
-        self, that: DataSpecificationIEC61360
-    ) -> T:
-        """Transform :paramref:`that`."""
-        raise NotImplementedError()
-
-
-class AbstractTransformerWithContext(Generic[ContextT, T]):
-    """Transform the instances of the model in context."""
-
-    def transform_with_context(self, that: Class, context: ContextT) -> T:
-        """Double-dispatch on :paramref:`that`."""
-        return that.transform_with_context(self, context)
-
-    @abc.abstractmethod
-    def transform_extension_with_context(self, that: Extension, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_administrative_information_with_context(
-        self, that: AdministrativeInformation, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_qualifier_with_context(self, that: Qualifier, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_asset_administration_shell_with_context(
-        self, that: AssetAdministrationShell, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_asset_information_with_context(
-        self, that: AssetInformation, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_resource_with_context(self, that: Resource, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_specific_asset_id_with_context(
-        self, that: SpecificAssetID, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_submodel_with_context(self, that: Submodel, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_relationship_element_with_context(
-        self, that: RelationshipElement, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_submodel_element_list_with_context(
-        self, that: SubmodelElementList, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_submodel_element_collection_with_context(
-        self, that: SubmodelElementCollection, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_property_with_context(self, that: Property, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_multi_language_property_with_context(
-        self, that: MultiLanguageProperty, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_range_with_context(self, that: Range, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_reference_element_with_context(
-        self, that: ReferenceElement, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_blob_with_context(self, that: Blob, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_file_with_context(self, that: File, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_annotated_relationship_element_with_context(
-        self, that: AnnotatedRelationshipElement, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_entity_with_context(self, that: Entity, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_event_payload_with_context(
-        self, that: EventPayload, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_basic_event_element_with_context(
-        self, that: BasicEventElement, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_operation_with_context(self, that: Operation, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_operation_variable_with_context(
-        self, that: OperationVariable, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_capability_with_context(
-        self, that: Capability, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_concept_description_with_context(
-        self, that: ConceptDescription, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_reference_with_context(self, that: Reference, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_key_with_context(self, that: Key, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_lang_string_name_type_with_context(
-        self, that: LangStringNameType, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_lang_string_text_type_with_context(
-        self, that: LangStringTextType, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_environment_with_context(
-        self, that: Environment, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_embedded_data_specification_with_context(
-        self, that: EmbeddedDataSpecification, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_level_type_with_context(
-        self, that: LevelType, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_value_reference_pair_with_context(
-        self, that: ValueReferencePair, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_value_list_with_context(
-        self, that: ValueList, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_lang_string_preferred_name_type_iec_61360_with_context(
-        self, that: LangStringPreferredNameTypeIEC61360, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_lang_string_short_name_type_iec_61360_with_context(
-        self, that: LangStringShortNameTypeIEC61360, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_lang_string_definition_type_iec_61360_with_context(
-        self, that: LangStringDefinitionTypeIEC61360, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-    @abc.abstractmethod
-    def transform_data_specification_iec_61360_with_context(
-        self, that: DataSpecificationIEC61360, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        raise NotImplementedError()
-
-
-class TransformerWithDefault(AbstractTransformer[T]):
-    """
-    Transform the instances of the model.
-
-    If you do not override the transformation methods, they simply
-    return :py:attr:`.default`.
-    """
-
-    #: Default value which is returned if no override of the transformation
-    default: T
-
-    def __init__(self, default: T) -> None:
-        """Initialize with the given :paramref:`default` value."""
-        self.default = default
-
-    def transform(self, that: Class) -> T:
-        """Double-dispatch on :paramref:`that`."""
-        return that.transform(self)
-
-    def transform_extension(self, that: Extension) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_administrative_information(
-        self, that: AdministrativeInformation
-    ) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_qualifier(self, that: Qualifier) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_asset_administration_shell(self, that: AssetAdministrationShell) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_asset_information(self, that: AssetInformation) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_resource(self, that: Resource) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_specific_asset_id(self, that: SpecificAssetID) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_submodel(self, that: Submodel) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_relationship_element(self, that: RelationshipElement) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_submodel_element_list(self, that: SubmodelElementList) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_submodel_element_collection(
-        self, that: SubmodelElementCollection
-    ) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_property(self, that: Property) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_multi_language_property(self, that: MultiLanguageProperty) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_range(self, that: Range) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_reference_element(self, that: ReferenceElement) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_blob(self, that: Blob) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_file(self, that: File) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_annotated_relationship_element(
-        self, that: AnnotatedRelationshipElement
-    ) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_entity(self, that: Entity) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_event_payload(self, that: EventPayload) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_basic_event_element(self, that: BasicEventElement) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_operation(self, that: Operation) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_operation_variable(self, that: OperationVariable) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_capability(self, that: Capability) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_concept_description(self, that: ConceptDescription) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_reference(self, that: Reference) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_key(self, that: Key) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_lang_string_name_type(self, that: LangStringNameType) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_lang_string_text_type(self, that: LangStringTextType) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_environment(self, that: Environment) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_embedded_data_specification(
-        self, that: EmbeddedDataSpecification
-    ) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_level_type(self, that: LevelType) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_value_reference_pair(self, that: ValueReferencePair) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_value_list(self, that: ValueList) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_lang_string_preferred_name_type_iec_61360(
-        self, that: LangStringPreferredNameTypeIEC61360
-    ) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_lang_string_short_name_type_iec_61360(
-        self, that: LangStringShortNameTypeIEC61360
-    ) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_lang_string_definition_type_iec_61360(
-        self, that: LangStringDefinitionTypeIEC61360
-    ) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-    def transform_data_specification_iec_61360(
-        self, that: DataSpecificationIEC61360
-    ) -> T:
-        """Transform :paramref:`that`."""
-        return self.default
-
-
-class TransformerWithDefaultAndContext(AbstractTransformerWithContext[ContextT, T]):
-    """
-    Transform the instances of the model in context.
-
-    If you do not override the transformation methods, they simply
-    return :py:attr:`.default`.
-    """
-
-    #: Default value which is returned if no override of the transformation
-    default: T
-
-    def __init__(self, default: T) -> None:
-        """Initialize with the given :paramref:`default` value."""
-        self.default = default
-
-    def transform_with_context(self, that: Class, context: ContextT) -> T:
-        """Double-dispatch on :paramref:`that`."""
-        return that.transform_with_context(self, context)
-
-    def transform_extension_with_context(self, that: Extension, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_administrative_information_with_context(
-        self, that: AdministrativeInformation, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_qualifier_with_context(self, that: Qualifier, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_asset_administration_shell_with_context(
-        self, that: AssetAdministrationShell, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_asset_information_with_context(
-        self, that: AssetInformation, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_resource_with_context(self, that: Resource, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_specific_asset_id_with_context(
-        self, that: SpecificAssetID, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_submodel_with_context(self, that: Submodel, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_relationship_element_with_context(
-        self, that: RelationshipElement, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_submodel_element_list_with_context(
-        self, that: SubmodelElementList, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_submodel_element_collection_with_context(
-        self, that: SubmodelElementCollection, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_property_with_context(self, that: Property, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_multi_language_property_with_context(
-        self, that: MultiLanguageProperty, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_range_with_context(self, that: Range, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_reference_element_with_context(
-        self, that: ReferenceElement, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_blob_with_context(self, that: Blob, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_file_with_context(self, that: File, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_annotated_relationship_element_with_context(
-        self, that: AnnotatedRelationshipElement, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_entity_with_context(self, that: Entity, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_event_payload_with_context(
-        self, that: EventPayload, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_basic_event_element_with_context(
-        self, that: BasicEventElement, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_operation_with_context(self, that: Operation, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_operation_variable_with_context(
-        self, that: OperationVariable, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_capability_with_context(
-        self, that: Capability, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_concept_description_with_context(
-        self, that: ConceptDescription, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_reference_with_context(self, that: Reference, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_key_with_context(self, that: Key, context: ContextT) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_lang_string_name_type_with_context(
-        self, that: LangStringNameType, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_lang_string_text_type_with_context(
-        self, that: LangStringTextType, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_environment_with_context(
-        self, that: Environment, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_embedded_data_specification_with_context(
-        self, that: EmbeddedDataSpecification, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_level_type_with_context(
-        self, that: LevelType, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_value_reference_pair_with_context(
-        self, that: ValueReferencePair, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_value_list_with_context(
-        self, that: ValueList, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_lang_string_preferred_name_type_iec_61360_with_context(
-        self, that: LangStringPreferredNameTypeIEC61360, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_lang_string_short_name_type_iec_61360_with_context(
-        self, that: LangStringShortNameTypeIEC61360, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_lang_string_definition_type_iec_61360_with_context(
-        self, that: LangStringDefinitionTypeIEC61360, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-    def transform_data_specification_iec_61360_with_context(
-        self, that: DataSpecificationIEC61360, context: ContextT
-    ) -> T:
-        """Transform :paramref:`that` in :paramref:`context`."""
-        return self.default
-
-
-# This code has been automatically generated by aas-core-codegen.
-# Do NOT edit or append.
+"""
+Provide an implementation of the Asset Administration Shell (AAS) V3.0.
+
+The presented version of the Metamodel is related to the work of
+aas-core-works, which can be found here: https://github.com/aas-core-works.
+
+The presented content is neither related to the IDTA nor
+Plattform Industrie 4.0 and does not represent an official publication.
+
+We diverge from the book in the following points.
+
+We did not implement the following constraints as they are too general and can not
+be formalized as part of the core library, but affects external components such as
+AAS registry or AAS server:
+
+* :ref:`Constraint AASd-022 <constraint_AASd-022>`
+
+We did not implement the following constraints since they depend on registry and
+de-referencing of :py:class:`Reference` objects:
+
+* :ref:`Constraint AASd-006 <constraint_AASd-006>`
+* :ref:`Constraint AASd-007 <constraint_AASd-007>`
+* :ref:`Constraint AASc-3a-003 <constraint_AASc-3a-003>`
+
+Some constraints are not enforceable as they depend on the wider context
+such as language understanding, so we could not formalize them:
+
+* :ref:`Constraint AASd-012 <constraint_AASd-012>`: This constraint requires that the texts inside
+  ``Multi_language_property`` shall have the same meanings in the separate languages.
+  This cannot be tested.
+* :ref:`Constraint AASd-116 <constraint_AASd-116>`: In the book, :ref:`Constraint AASd-116 <constraint_AASd-116>` imposes a
+  case-insensitive equality against ``globalAssetId``. This is culturally-dependent,
+  and depends on the system settings. For example, the case-folding
+  for the letters "i" and "I" is different in Turkish from English.
+
+  We implement the constraint as case-sensitive instead to allow for interoperability
+  across different culture settings.
+
+Furthermore, we diverge from the book in the following points regarding
+the enumerations. We have to implement subsets of enumerations as sets as common
+programming languages do not support inheritance of enumerations. The relationship
+between the properties and the sets is defined through invariants. This causes
+the following divergences:
+
+* We decided therefore to remove the enumeration ``DataTypeDefRDF``
+  and keep only :py:class:`DataTypeDefXSD` as enumeration. Otherwise, we would have
+  to write redundant invariants all over the meta-model because ``DataTypeDefRDF``
+  is actually never used in any type definition.
+* The enumeration :py:class:`AASSubmodelElements` is used in two different contexts.
+  One context is the definition of key types in a reference. Another context is
+  the definition of element types in a :py:class:`SubmodelElementList`.
+
+  To avoid confusion, we introduce two separate enumerations for the separate contexts.
+  Firstly, a set of :py:class:`KeyTypes`, :py:attr:`.constants.AAS_SUBMODEL_ELEMENTS_AS_KEYS` to
+  represent the first context (key type in a reference).
+  Secondly, the enumeration :py:class:`AASSubmodelElements` is kept as designator
+  for :py:attr:`SubmodelElementList.type_value_list_element`.
+* The specification introduces several types of ``Lang_string_set``.
+  These types differ between the allowed length of their text inside the singular
+  ``Lang_string`` objects. Since the native representation of ``Lang_string_set`` as
+  ``List`` of ``Lang_string`` is required by specification, it is impossible to
+  introduce separate ``Lang_string_set`` types. Therefore, the distinction is drawn here
+  between the ``Lang_string`` types.
+
+  ``DefinitionTypeIEC61360`` is represented as a
+  ``List`` of :py:class:`LangStringDefinitionTypeIEC61360`
+
+  ``MultiLanguageNameType`` is represented as a
+  ``List`` of :py:class:`LangStringNameType`
+
+  ``PreferredNameTypeIEC61360`` is represented as a
+  ``List`` of :py:class:`LangStringPreferredNameTypeIEC61360`
+
+  ``ShortNameTypeIEC61360`` is represented as a
+  ``List`` of :py:class:`LangStringShortNameTypeIEC61360`
+
+  ``MultiLanguageTextType`` is represented as a
+  ``List`` of :py:class:`LangStringTextType`
+
+  Furthermore, since ``Lang_string`` is not used anywhere, we rename it to
+  :py:class:`AbstractLangString`.
+
+Concerning the data specifications, we embed them within
+:py:class:`HasDataSpecification` instead of referencing them *via* an external reference.
+The working group decided to change the rules for serialization *after* the book was
+published. The data specifications are critical in applications, but there is no
+possibility to access them through a data channel as they are not part of
+an environment.
+"""
+
+
+# This code has been automatically generated by aas-core-codegen.
+# Do NOT edit or append.
+
+
+import abc
+import enum
+from typing import Generic, Iterator, Optional, TypeVar, List
+
+
+T = TypeVar("T")
+ContextT = TypeVar("ContextT")
+
+
+class Class(abc.ABC):
+    """Represent the most general class of an AAS model."""
+
+    @abc.abstractmethod
+    def descend_once(self) -> Iterator["Class"]:
+        """Iterate over all the instances referenced from this one."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def descend(self) -> Iterator["Class"]:
+        """Iterate recursively over all the instances referenced from this one."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """
+        Dispatch the :paramref:`visitor` on this instance.
+
+        :param visitor: to be dispatched
+        """
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """
+        Dispatch the :paramref:`visitor` on this instance with :paramref:`context`.
+
+        :param visitor: to be dispatched
+        :param context: of the visitation
+        """
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance.
+
+        :param transformer: to be dispatched
+        :return: transformed self
+        """
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance with :paramref:`context`.
+
+        :param transformer: to be dispatched
+        :return: transformed self
+        """
+        raise NotImplementedError()
+
+
+# pylint: disable=redefined-builtin
+
+
+class HasSemantics(Class):
+    """
+    Element that can have a semantic definition plus some supplemental semantic
+    definitions.
+
+    :constraint AASd-118:
+        .. _constraint_AASd-118:
+
+        If there are ID :py:attr:`supplemental_semantic_ids` defined
+        then there shall be also a main semantic ID :py:attr:`semantic_id`.
+    """
+
+    #: Identifier of the semantic definition of the element. It is called semantic ID
+    #: of the element or also main semantic ID of the element.
+    #:
+    #: .. note::
+    #:
+    #:     It is recommended to use a global reference.
+    semantic_id: Optional["Reference"]
+
+    #: Identifier of a supplemental semantic definition of the element.
+    #: It is called supplemental semantic ID of the element.
+    #:
+    #: .. note::
+    #:
+    #:     It is recommended to use a global reference.
+    supplemental_semantic_ids: Optional[List["Reference"]]
+
+    def over_supplemental_semantic_ids_or_empty(self) -> Iterator["Reference"]:
+        """Yield from :py:attr:`.supplemental_semantic_ids` if set."""
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+    def __init__(
+        self,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        self.semantic_id = semantic_id
+        self.supplemental_semantic_ids = supplemental_semantic_ids
+
+
+class Extension(HasSemantics):
+    """Single extension of an element."""
+
+    #: Name of the extension.
+    #:
+    #: :constraint AASd-077:
+    #:     .. _constraint_AASd-077:
+    #:
+    #:     The name of an extension (Extension/name) within :py:class:`HasExtensions` needs
+    #:     to be unique.
+    name: str
+
+    #: Type of the value of the extension.
+    #:
+    #: Default: :py:attr:`DataTypeDefXSD.STRING`
+    value_type: Optional["DataTypeDefXSD"]
+
+    #: Value of the extension
+    value: Optional[str]
+
+    #: Reference to an element the extension refers to.
+    refers_to: Optional[List["Reference"]]
+
+    def over_refers_to_or_empty(self) -> Iterator["Reference"]:
+        """Yield from :py:attr:`.refers_to` if set."""
+        if self.refers_to is not None:
+            yield from self.refers_to
+
+    def value_type_or_default(self) -> "DataTypeDefXSD":
+        """Return the :py:attr:`value_type` if set, or the default otherwise."""
+        return self.value_type if self.value_type is not None else DataTypeDefXSD.STRING
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.refers_to is not None:
+            yield from self.refers_to
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for an_item in self.supplemental_semantic_ids:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.refers_to is not None:
+            for another_item in self.refers_to:
+                yield another_item
+
+                yield from another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_extension(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_extension_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_extension(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_extension_with_context(self, context)
+
+    def __init__(
+        self,
+        name: str,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        value_type: Optional["DataTypeDefXSD"] = None,
+        value: Optional[str] = None,
+        refers_to: Optional[List["Reference"]] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        HasSemantics.__init__(self, semantic_id, supplemental_semantic_ids)
+        self.name = name
+        self.value_type = value_type
+        self.value = value
+        self.refers_to = refers_to
+
+
+class HasExtensions(Class):
+    """
+    Element that can be extended by proprietary extensions.
+
+    .. note::
+
+        Extensions are proprietary, i.e. they do not support global interoperability.
+    """
+
+    #: An extension of the element.
+    extensions: Optional[List["Extension"]]
+
+    def over_extensions_or_empty(self) -> Iterator["Extension"]:
+        """Yield from :py:attr:`.extensions` if set."""
+        if self.extensions is not None:
+            yield from self.extensions
+
+    def __init__(self, extensions: Optional[List["Extension"]] = None) -> None:
+        """Initialize with the given values."""
+        self.extensions = extensions
+
+
+class Referable(HasExtensions):
+    """
+    An element that is referable by its :py:attr:`id_short`.
+
+    This ID is not globally unique.
+    This ID is unique within the name space of the element.
+
+    :constraint AASd-022:
+        .. _constraint_AASd-022:
+
+        :py:attr:`id_short` of non-identifiable referables
+        within the same name space shall be unique (case-sensitive).
+    """
+
+    #: The category is a value that gives further meta information
+    #: w.r.t. to the class of the element.
+    #: It affects the expected existence of attributes and the applicability of
+    #: constraints.
+    #:
+    #: .. note::
+    #:
+    #:     The category is not identical to the semantic definition
+    #:     (:py:class:`HasSemantics`) of an element. The category e.g. could denote that
+    #:     the element is a measurement value whereas the semantic definition of
+    #:     the element would denote that it is the measured temperature.
+    category: Optional[str]
+
+    #: In case of identifiables this attribute is a short name of the element.
+    #: In case of referable this ID is an identifying string of the element within
+    #: its name space.
+    #:
+    #: .. note::
+    #:
+    #:     In case the element is a property and the property has a semantic definition
+    #:     (:py:attr:`HasSemantics.semantic_id`) conformant to IEC61360
+    #:     the :py:attr:`id_short` is typically identical to the short name in English.
+    id_short: Optional[str]
+
+    #: Display name. Can be provided in several languages.
+    display_name: Optional[List["LangStringNameType"]]
+
+    #: Description or comments on the element.
+    #:
+    #: The description can be provided in several languages.
+    #:
+    #: If no description is defined, then the definition of the concept
+    #: description that defines the semantics of the element is used.
+    #:
+    #: Additional information can be provided, e.g., if the element is
+    #: qualified and which qualifier types can be expected in which
+    #: context or which additional data specification templates are
+    #: provided.
+    description: Optional[List["LangStringTextType"]]
+
+    def over_display_name_or_empty(self) -> Iterator["LangStringNameType"]:
+        """Yield from :py:attr:`.display_name` if set."""
+        if self.display_name is not None:
+            yield from self.display_name
+
+    def over_description_or_empty(self) -> Iterator["LangStringTextType"]:
+        """Yield from :py:attr:`.description` if set."""
+        if self.description is not None:
+            yield from self.description
+
+    def __init__(
+        self,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        HasExtensions.__init__(self, extensions)
+        self.id_short = id_short
+        self.display_name = display_name
+        self.category = category
+        self.description = description
+
+
+class Identifiable(Referable):
+    """An element that has a globally unique identifier."""
+
+    #: Administrative information of an identifiable element.
+    #:
+    #: .. note::
+    #:
+    #:     Some of the administrative information like the version number might need to
+    #:     be part of the identification.
+    administration: Optional["AdministrativeInformation"]
+
+    #: The globally unique identification of the element.
+    id: str
+
+    def __init__(
+        self,
+        id: str,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        administration: Optional["AdministrativeInformation"] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        Referable.__init__(
+            self, extensions, category, id_short, display_name, description
+        )
+        self.id = id
+        self.administration = administration
+
+
+class ModellingKind(enum.Enum):
+    """
+    Enumeration for denoting whether an element is a template or an instance.
+    """
+
+    #: Specification of the common features of a structured element in sufficient detail
+    #: that such a instance can be instantiated using it
+    TEMPLATE = "Template"
+
+    #: Concrete, clearly identifiable element instance. Its creation and validation
+    #: may be guided by a corresponding element template.
+    INSTANCE = "Instance"
+
+
+class HasKind(Class):
+    """
+    An element with a kind is an element that can either represent a template or an
+    instance.
+
+    Default for an element is that it is representing an instance.
+    """
+
+    #: Kind of the element: either type or instance.
+    #:
+    #: Default: :py:attr:`ModellingKind.INSTANCE`
+    kind: Optional["ModellingKind"]
+
+    def kind_or_default(self) -> "ModellingKind":
+        """Return :py:attr:`kind` if set, and the default otherwise."""
+        return self.kind if self.kind is not None else ModellingKind.INSTANCE
+
+    def __init__(self, kind: Optional["ModellingKind"] = None) -> None:
+        """Initialize with the given values."""
+        self.kind = kind
+
+
+class HasDataSpecification(Class):
+    """
+    Element that can be extended by using data specification templates.
+
+    A data specification template defines a named set of additional attributes an
+    element may or shall have. The data specifications used are explicitly specified
+    with their global ID.
+    """
+
+    #: Embedded data specification.
+    embedded_data_specifications: Optional[List["EmbeddedDataSpecification"]]
+
+    def over_embedded_data_specifications_or_empty(
+        self,
+    ) -> Iterator["EmbeddedDataSpecification"]:
+        """Yield from :py:attr:`.embedded_data_specifications` if set."""
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+    def __init__(
+        self,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        self.embedded_data_specifications = embedded_data_specifications
+
+
+class AdministrativeInformation(HasDataSpecification):
+    """
+    Administrative meta-information for an element like version
+    information.
+
+    :constraint AASd-005:
+        .. _constraint_AASd-005:
+
+        If :py:attr:`version` is not specified then also :py:attr:`revision` shall be
+        unspecified. This means, a revision requires a version. If there is no version
+        there is no revision neither. Revision is optional.
+    """
+
+    #: Version of the element.
+    version: Optional[str]
+
+    #: Revision of the element.
+    revision: Optional[str]
+
+    #: The subject ID of the subject responsible for making the element.
+    creator: Optional["Reference"]
+
+    #: Identifier of the template that guided the creation of the element.
+    #:
+    #: .. note::
+    #:
+    #:     In case of a submodel the :py:attr:`template_id` is the identifier
+    #:     of the submodel template ID that guided the creation of the submodel
+    #:
+    #: .. note::
+    #:
+    #:     The :py:attr:`template_id` is not relevant for validation in Submodels.
+    #:     For validation the :py:attr:`Submodel.semantic_id` shall be used.
+    #:
+    #: .. note::
+    #:
+    #:     Usage of :py:attr:`template_id` is not restricted to submodel instances. So also
+    #:     the creation of submodel templates can be guided by another submodel template.
+    template_id: Optional[str]
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        if self.creator is not None:
+            yield self.creator
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.embedded_data_specifications is not None:
+            for an_item in self.embedded_data_specifications:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.creator is not None:
+            yield self.creator
+
+            yield from self.creator.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_administrative_information(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_administrative_information_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_administrative_information(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_administrative_information_with_context(
+            self, context
+        )
+
+    def __init__(
+        self,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        version: Optional[str] = None,
+        revision: Optional[str] = None,
+        creator: Optional["Reference"] = None,
+        template_id: Optional[str] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        HasDataSpecification.__init__(self, embedded_data_specifications)
+        self.version = version
+        self.revision = revision
+        self.creator = creator
+        self.template_id = template_id
+
+
+class Qualifiable(Class):
+    """
+    The value of a qualifiable element may be further qualified by one or more
+    qualifiers.
+
+    :constraint AASd-119:
+        .. _constraint_AASd-119:
+
+        If any :py:attr:`Qualifier.kind` value of :py:attr:`qualifiers` is
+        equal to :py:attr:`QualifierKind.TEMPLATE_QUALIFIER` and the qualified element
+        inherits from :py:class:`HasKind` then the qualified element shall be of
+        kind Template (:py:attr:`HasKind.kind` = :py:attr:`ModellingKind.TEMPLATE`).
+
+        .. note::
+
+            This constraint is checked at :py:class:`Submodel`.
+    """
+
+    #: Additional qualification of a qualifiable element.
+    #:
+    #: :constraint AASd-021:
+    #:     .. _constraint_AASd-021:
+    #:
+    #:     Every qualifiable can only have one qualifier with the same
+    #:     :py:attr:`Qualifier.type`.
+    qualifiers: Optional[List["Qualifier"]]
+
+    def over_qualifiers_or_empty(self) -> Iterator["Qualifier"]:
+        """Yield from :py:attr:`.qualifiers` if set."""
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+    def __init__(self, qualifiers: Optional[List["Qualifier"]] = None) -> None:
+        """Initialize with the given values."""
+        self.qualifiers = qualifiers
+
+
+class QualifierKind(enum.Enum):
+    """
+    Enumeration for kinds of qualifiers.
+
+    .. note::
+
+        This element is experimental and therefore may be subject to change or may be
+        removed completely in future versions of the meta-model.
+    """
+
+    #: qualifies the value of the element and can change during run-time.
+    #:
+    #: Value qualifiers are only applicable to elements with kind
+    #: :py:attr:`ModellingKind.INSTANCE`.
+    VALUE_QUALIFIER = "ValueQualifier"
+
+    #: qualifies the semantic definition the element is referring to
+    #: (:py:attr:`HasSemantics.semantic_id`)
+    CONCEPT_QUALIFIER = "ConceptQualifier"
+
+    #: qualifies the elements within a specific submodel on concept level.
+    #:
+    #: Template qualifiers are only applicable to elements with kind
+    #: :py:attr:`ModellingKind.TEMPLATE`.
+    TEMPLATE_QUALIFIER = "TemplateQualifier"
+
+
+class Qualifier(HasSemantics):
+    """
+    A qualifier is a type-value-pair that makes additional statements w.r.t. the value
+    of the element.
+
+    :constraint AASd-006:
+        .. _constraint_AASd-006:
+
+        If both the :py:attr:`value` and the :py:attr:`value_id` of
+        a :py:class:`Qualifier` are present then the :py:attr:`value` needs
+        to be identical to the value of the referenced coded value
+        in :py:attr:`value_id`.
+
+    :constraint AASd-020:
+        .. _constraint_AASd-020:
+
+        The value of :py:attr:`value` shall be consistent to the data type as
+        defined in :py:attr:`value_type`.
+    """
+
+    #: The qualifier kind describes the kind of the qualifier that is applied to the
+    #: element.
+    #:
+    #: Default: :py:attr:`QualifierKind.CONCEPT_QUALIFIER`
+    kind: Optional["QualifierKind"]
+
+    #: The qualifier *type* describes the type of the qualifier that is applied to
+    #: the element.
+    type: str
+
+    #: Data type of the qualifier value.
+    value_type: "DataTypeDefXSD"
+
+    #: The qualifier value is the value of the qualifier.
+    value: Optional[str]
+
+    #: Reference to the global unique ID of a coded value.
+    #:
+    #: .. note::
+    #:
+    #:     It is recommended to use a global reference.
+    value_id: Optional["Reference"]
+
+    def kind_or_default(self) -> "QualifierKind":
+        """Return :py:attr:`kind` if set, and the default otherwise."""
+        return self.kind if self.kind is not None else QualifierKind.CONCEPT_QUALIFIER
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.value_id is not None:
+            yield self.value_id
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for an_item in self.supplemental_semantic_ids:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.value_id is not None:
+            yield self.value_id
+
+            yield from self.value_id.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_qualifier(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_qualifier_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_qualifier(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_qualifier_with_context(self, context)
+
+    def __init__(
+        self,
+        type: str,
+        value_type: "DataTypeDefXSD",
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        kind: Optional["QualifierKind"] = None,
+        value: Optional[str] = None,
+        value_id: Optional["Reference"] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        HasSemantics.__init__(self, semantic_id, supplemental_semantic_ids)
+        self.type = type
+        self.value_type = value_type
+        self.kind = kind
+        self.value = value
+        self.value_id = value_id
+
+
+class AssetAdministrationShell(Identifiable, HasDataSpecification):
+    """An asset administration shell."""
+
+    #: The reference to the AAS the AAS was derived from.
+    derived_from: Optional["Reference"]
+
+    #: Meta-information about the asset the AAS is representing.
+    asset_information: "AssetInformation"
+
+    #: References to submodels of the AAS.
+    #:
+    #: A submodel is a description of an aspect of the asset the AAS is representing.
+    #:
+    #: The asset of an AAS is typically described by one or more submodels.
+    #:
+    #: Temporarily no submodel might be assigned to the AAS.
+    submodels: Optional[List["Reference"]]
+
+    def over_submodels_or_empty(self) -> Iterator["Reference"]:
+        """Yield from :py:attr:`.submodels` if set."""
+        if self.submodels is not None:
+            yield from self.submodels
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.administration is not None:
+            yield self.administration
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        if self.derived_from is not None:
+            yield self.derived_from
+
+        yield self.asset_information
+
+        if self.submodels is not None:
+            yield from self.submodels
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.administration is not None:
+            yield self.administration
+
+            yield from self.administration.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.derived_from is not None:
+            yield self.derived_from
+
+            yield from self.derived_from.descend()
+
+        yield self.asset_information
+
+        yield from self.asset_information.descend()
+
+        if self.submodels is not None:
+            for yet_yet_yet_another_item in self.submodels:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_asset_administration_shell(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_asset_administration_shell_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_asset_administration_shell(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_asset_administration_shell_with_context(
+            self, context
+        )
+
+    def __init__(
+        self,
+        id: str,
+        asset_information: "AssetInformation",
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        administration: Optional["AdministrativeInformation"] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        derived_from: Optional["Reference"] = None,
+        submodels: Optional[List["Reference"]] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        Identifiable.__init__(
+            self,
+            id,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            administration,
+        )
+        HasDataSpecification.__init__(self, embedded_data_specifications)
+        self.derived_from = derived_from
+        self.asset_information = asset_information
+        self.submodels = submodels
+
+
+class AssetInformation(Class):
+    """
+    In :py:class:`AssetInformation` identifying meta data of the asset that is
+    represented by an AAS is defined.
+
+    The asset may either represent an asset type or an asset instance.
+
+    The asset has a globally unique identifier plus  if needed  additional domain
+    specific (proprietary) identifiers. However, to support the corner case of very
+    first phase of lifecycle where a stabilised/constant_set global asset identifier
+    does not already exist, the corresponding attribute :py:attr:`global_asset_id` is
+    optional.
+
+    :constraint AASd-116:
+        .. _constraint_AASd-116:
+
+        ``globalAssetId`` is a reserved key. If used as value for
+        :py:attr:`SpecificAssetID.name` then :py:attr:`SpecificAssetID.value` shall be
+        identical to :py:attr:`global_asset_id`.
+
+        .. note::
+
+            :ref:`Constraint AASd-116 <constraint_AASd-116>` is important to enable a generic search across
+            global and specific asset IDs.
+
+        .. note::
+
+            In the book, :ref:`Constraint AASd-116 <constraint_AASd-116>` imposes a
+            case-insensitive equality against ``globalAssetId``. This is
+            culturally-dependent, and depends on the system settings.
+            For example, the case-folding for the letters "i" and "I" is
+            different in Turkish from English.
+
+            We implement the constraint as case-sensitive instead to allow
+            for interoperability across different culture settings.
+
+    :constraint AASd-131:
+        .. _constraint_AASd-131:
+
+        For :py:class:`AssetInformation` either the :py:attr:`global_asset_id` shall be
+        defined or at least one item in :py:attr:`specific_asset_ids`.
+    """
+
+    #: Denotes whether the Asset is of kind :py:attr:`AssetKind.TYPE` or
+    #: :py:attr:`AssetKind.INSTANCE`.
+    asset_kind: "AssetKind"
+
+    #: Global identifier of the asset the AAS is representing.
+    #:
+    #: This attribute is required as soon as the AAS is exchanged via partners in the life
+    #: cycle of the asset. In a first phase of the life cycle the asset might not yet have
+    #: a global ID but already an internal identifier. The internal identifier would be
+    #: modelled via :py:attr:`specific_asset_ids`.
+    #:
+    #: .. note::
+    #:
+    #:     This is a global reference.
+    global_asset_id: Optional[str]
+
+    #: Additional domain-specific, typically proprietary identifier for the asset like
+    #: e.g., serial number etc.
+    specific_asset_ids: Optional[List["SpecificAssetID"]]
+
+    #: In case :py:attr:`asset_kind` is applicable the :py:attr:`asset_type` is the asset ID
+    #: of the type asset of the asset under consideration
+    #: as identified by :py:attr:`global_asset_id`.
+    #:
+    #: .. note::
+    #:
+    #:     In case :py:attr:`asset_kind` is "Instance" than the :py:attr:`asset_type` denotes
+    #:     which "Type" the asset is of. But it is also possible
+    #:     to have an :py:attr:`asset_type` of an asset of kind "Type".
+    asset_type: Optional[str]
+
+    #: Thumbnail of the asset represented by the Asset Administration Shell.
+    #:
+    #: Used as default.
+    default_thumbnail: Optional["Resource"]
+
+    def over_specific_asset_ids_or_empty(self) -> Iterator["SpecificAssetID"]:
+        """Yield from :py:attr:`.specific_asset_ids` if set."""
+        if self.specific_asset_ids is not None:
+            yield from self.specific_asset_ids
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.specific_asset_ids is not None:
+            yield from self.specific_asset_ids
+
+        if self.default_thumbnail is not None:
+            yield self.default_thumbnail
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.specific_asset_ids is not None:
+            for an_item in self.specific_asset_ids:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.default_thumbnail is not None:
+            yield self.default_thumbnail
+
+            yield from self.default_thumbnail.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_asset_information(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_asset_information_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_asset_information(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_asset_information_with_context(self, context)
+
+    def __init__(
+        self,
+        asset_kind: "AssetKind",
+        global_asset_id: Optional[str] = None,
+        specific_asset_ids: Optional[List["SpecificAssetID"]] = None,
+        asset_type: Optional[str] = None,
+        default_thumbnail: Optional["Resource"] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        self.asset_kind = asset_kind
+        self.global_asset_id = global_asset_id
+        self.specific_asset_ids = specific_asset_ids
+        self.asset_type = asset_type
+        self.default_thumbnail = default_thumbnail
+
+
+class Resource(Class):
+    """
+    Resource represents an address to a file (a locator). The value is an URI that
+    can represent an absolute or relative path
+    """
+
+    #: Path and name of the resource (with file extension).
+    #:
+    #: The path can be absolute or relative.
+    path: str
+
+    #: Content type of the content of the file.
+    #:
+    #: The content type states which file extensions the file can have.
+    content_type: Optional[str]
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_resource(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_resource_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_resource(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_resource_with_context(self, context)
+
+    def __init__(self, path: str, content_type: Optional[str] = None) -> None:
+        """Initialize with the given values."""
+        self.path = path
+        self.content_type = content_type
+
+
+class AssetKind(enum.Enum):
+    """
+    Enumeration for denoting whether an asset is a type asset or an instance asset.
+    """
+
+    #: Type asset
+    TYPE = "Type"
+
+    #: Instance asset
+    INSTANCE = "Instance"
+
+    #: Neither a type asset nor an instance asset
+    NOT_APPLICABLE = "NotApplicable"
+
+
+class SpecificAssetID(HasSemantics):
+    """
+    A specific asset ID describes a generic supplementary identifying attribute of the
+    asset.
+
+    The specific asset ID is not necessarily globally unique.
+
+    :constraint AASd-133:
+        .. _constraint_AASd-133:
+
+        :py:attr:`external_subject_id` shall be an external reference,
+        i.e. :py:attr:`Reference.type` = :py:attr:`ReferenceTypes.EXTERNAL_REFERENCE`.
+    """
+
+    #: Name of the identifier
+    name: str
+
+    #: The value of the specific asset identifier with the corresponding name.
+    value: str
+
+    #: The (external) subject the key belongs to or has meaning to.
+    #:
+    #: .. note::
+    #:
+    #:     This is a global reference.
+    external_subject_id: Optional["Reference"]
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.external_subject_id is not None:
+            yield self.external_subject_id
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for an_item in self.supplemental_semantic_ids:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.external_subject_id is not None:
+            yield self.external_subject_id
+
+            yield from self.external_subject_id.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_specific_asset_id(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_specific_asset_id_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_specific_asset_id(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_specific_asset_id_with_context(self, context)
+
+    def __init__(
+        self,
+        name: str,
+        value: str,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        external_subject_id: Optional["Reference"] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        HasSemantics.__init__(self, semantic_id, supplemental_semantic_ids)
+        self.name = name
+        self.value = value
+        self.external_subject_id = external_subject_id
+
+
+class Submodel(Identifiable, HasKind, HasSemantics, Qualifiable, HasDataSpecification):
+    """
+    A submodel defines a specific aspect of the asset represented by the AAS.
+
+    A submodel is used to structure the digital representation and technical
+    functionality of an Administration Shell into distinguishable parts. Each submodel
+    refers to a well-defined domain or subject matter. Submodels can become
+    standardized and, thus, become submodels templates.
+    """
+
+    #: A submodel consists of zero or more submodel elements.
+    submodel_elements: Optional[List["SubmodelElement"]]
+
+    def over_submodel_elements_or_empty(self) -> Iterator["SubmodelElement"]:
+        """Yield from :py:attr:`.submodel_elements` if set."""
+        if self.submodel_elements is not None:
+            yield from self.submodel_elements
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.administration is not None:
+            yield self.administration
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        if self.submodel_elements is not None:
+            yield from self.submodel_elements
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.administration is not None:
+            yield self.administration
+
+            yield from self.administration.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+        if self.submodel_elements is not None:
+            for yet_yet_yet_yet_yet_another_item in self.submodel_elements:
+                yield yet_yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_submodel(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_submodel_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_submodel(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_submodel_with_context(self, context)
+
+    def __init__(
+        self,
+        id: str,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        administration: Optional["AdministrativeInformation"] = None,
+        kind: Optional["ModellingKind"] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        submodel_elements: Optional[List["SubmodelElement"]] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        Identifiable.__init__(
+            self,
+            id,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            administration,
+        )
+        HasKind.__init__(self, kind)
+        HasSemantics.__init__(self, semantic_id, supplemental_semantic_ids)
+        Qualifiable.__init__(self, qualifiers)
+        HasDataSpecification.__init__(self, embedded_data_specifications)
+        self.submodel_elements = submodel_elements
+
+
+class SubmodelElement(Referable, HasSemantics, Qualifiable, HasDataSpecification):
+    """
+    A submodel element is an element suitable for the description and differentiation of
+    assets.
+
+    It is recommended to add a :py:attr:`HasSemantics.semantic_id` to a submodel element.
+
+    :constraint AASd-129:
+        .. _constraint_AASd-129:
+
+        If any :py:attr:`Qualifier.kind` value of :py:attr:`qualifiers` (attribute qualifier
+        inherited via Qualifiable) is equal to :py:attr:`QualifierKind.TEMPLATE_QUALIFIER`
+        then the submodel element shall be part of a submodel template, i.e.
+        a Submodel with :py:attr:`Submodel.kind` (attribute kind inherited via
+        :py:class:`HasKind`) value is equal to :py:attr:`ModellingKind.TEMPLATE`.
+    """
+
+    def __init__(
+        self,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        Referable.__init__(
+            self, extensions, category, id_short, display_name, description
+        )
+        HasSemantics.__init__(self, semantic_id, supplemental_semantic_ids)
+        Qualifiable.__init__(self, qualifiers)
+        HasDataSpecification.__init__(self, embedded_data_specifications)
+
+
+class RelationshipElement(SubmodelElement):
+    """
+    A relationship element is used to define a relationship between two elements
+    being either referable (model reference) or external (global reference).
+    """
+
+    #: Reference to the first element in the relationship taking the role of the subject.
+    first: "Reference"
+
+    #: Reference to the second element in the relationship taking the role of the object.
+    second: "Reference"
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        yield self.first
+
+        yield self.second
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+        yield self.first
+
+        yield from self.first.descend()
+
+        yield self.second
+
+        yield from self.second.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_relationship_element(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_relationship_element_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_relationship_element(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_relationship_element_with_context(self, context)
+
+    def __init__(
+        self,
+        first: "Reference",
+        second: "Reference",
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        SubmodelElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.first = first
+        self.second = second
+
+
+class AASSubmodelElements(enum.Enum):
+    """
+    Enumeration of all possible elements of a :py:class:`SubmodelElementList`.
+    """
+
+    ANNOTATED_RELATIONSHIP_ELEMENT = "AnnotatedRelationshipElement"
+
+    BASIC_EVENT_ELEMENT = "BasicEventElement"
+
+    BLOB = "Blob"
+
+    CAPABILITY = "Capability"
+
+    DATA_ELEMENT = "DataElement"
+
+    ENTITY = "Entity"
+
+    EVENT_ELEMENT = "EventElement"
+
+    FILE = "File"
+
+    MULTI_LANGUAGE_PROPERTY = "MultiLanguageProperty"
+
+    OPERATION = "Operation"
+
+    PROPERTY = "Property"
+
+    RANGE = "Range"
+
+    REFERENCE_ELEMENT = "ReferenceElement"
+
+    RELATIONSHIP_ELEMENT = "RelationshipElement"
+
+    SUBMODEL_ELEMENT = "SubmodelElement"
+
+    SUBMODEL_ELEMENT_LIST = "SubmodelElementList"
+
+    SUBMODEL_ELEMENT_COLLECTION = "SubmodelElementCollection"
+
+
+class SubmodelElementList(SubmodelElement):
+    """
+    A submodel element list is an ordered list of submodel elements.
+
+    The numbering starts with zero (0).
+
+    :constraint AASd-107:
+        .. _constraint_AASd-107:
+
+        If a first level child element in a :py:class:`SubmodelElementList` has
+        a :py:attr:`HasSemantics.semantic_id` it
+        shall be identical to :py:attr:`semantic_id_list_element`.
+
+    :constraint AASd-114:
+        .. _constraint_AASd-114:
+
+        If two first level child elements in a :py:class:`SubmodelElementList` have
+        a :py:attr:`HasSemantics.semantic_id` then they shall be identical.
+
+    :constraint AASd-115:
+        .. _constraint_AASd-115:
+
+        If a first level child element in a :py:class:`SubmodelElementList` does not
+        specify a :py:attr:`HasSemantics.semantic_id` then the value is assumed to be
+        identical to :py:attr:`semantic_id_list_element`.
+
+    :constraint AASd-108:
+        .. _constraint_AASd-108:
+
+        All first level child elements in a :py:class:`SubmodelElementList` shall have
+        the same submodel element type as specified in :py:attr:`type_value_list_element`.
+
+    :constraint AASd-109:
+        .. _constraint_AASd-109:
+
+        If :py:attr:`type_value_list_element` is equal to
+        :py:attr:`AASSubmodelElements.PROPERTY` or
+        :py:attr:`AASSubmodelElements.RANGE`
+        :py:attr:`value_type_list_element` shall be set and all first
+        level child elements in the :py:class:`SubmodelElementList` shall have
+        the value type as specified in :py:attr:`value_type_list_element`.
+    """
+
+    #: Defines whether order in list is relevant. If :py:attr:`order_relevant` = ``False``
+    #: then the list is representing a set or a bag.
+    #:
+    #: Default: ``True``
+    order_relevant: Optional[bool]
+
+    #: Semantic ID the submodel elements contained in the list match to.
+    #:
+    #: .. note::
+    #:
+    #:     It is recommended to use a global reference.
+    semantic_id_list_element: Optional["Reference"]
+
+    #: The submodel element type of the submodel elements contained in the list.
+    type_value_list_element: "AASSubmodelElements"
+
+    #: The value type of the submodel element contained in the list.
+    value_type_list_element: Optional["DataTypeDefXSD"]
+
+    #: Submodel element contained in the list.
+    #:
+    #: The list is ordered.
+    value: Optional[List["SubmodelElement"]]
+
+    def over_value_or_empty(self) -> Iterator["SubmodelElement"]:
+        """Yield from :py:attr:`.value` if set."""
+        if self.value is not None:
+            yield from self.value
+
+    def order_relevant_or_default(self) -> bool:
+        """Return :py:attr:`order_relevant` if set, and the default otherwise."""
+        return self.order_relevant if self.order_relevant is not None else True
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        if self.semantic_id_list_element is not None:
+            yield self.semantic_id_list_element
+
+        if self.value is not None:
+            yield from self.value
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+        if self.semantic_id_list_element is not None:
+            yield self.semantic_id_list_element
+
+            yield from self.semantic_id_list_element.descend()
+
+        if self.value is not None:
+            for yet_yet_yet_yet_yet_another_item in self.value:
+                yield yet_yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_submodel_element_list(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_submodel_element_list_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_submodel_element_list(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_submodel_element_list_with_context(self, context)
+
+    def __init__(
+        self,
+        type_value_list_element: "AASSubmodelElements",
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        order_relevant: Optional[bool] = None,
+        semantic_id_list_element: Optional["Reference"] = None,
+        value_type_list_element: Optional["DataTypeDefXSD"] = None,
+        value: Optional[List["SubmodelElement"]] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        SubmodelElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.type_value_list_element = type_value_list_element
+        self.order_relevant = order_relevant
+        self.semantic_id_list_element = semantic_id_list_element
+        self.value_type_list_element = value_type_list_element
+        self.value = value
+
+
+class SubmodelElementCollection(SubmodelElement):
+    """
+    A submodel element collection is a kind of struct, i.e. a a logical encapsulation
+    of multiple named values. It has a fixed number of submodel elements.
+    """
+
+    #: Submodel element contained in the collection.
+    value: Optional[List["SubmodelElement"]]
+
+    def over_value_or_empty(self) -> Iterator["SubmodelElement"]:
+        """Yield from :py:attr:`.value` if set."""
+        if self.value is not None:
+            yield from self.value
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        if self.value is not None:
+            yield from self.value
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+        if self.value is not None:
+            for yet_yet_yet_yet_yet_another_item in self.value:
+                yield yet_yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_submodel_element_collection(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_submodel_element_collection_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_submodel_element_collection(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_submodel_element_collection_with_context(
+            self, context
+        )
+
+    def __init__(
+        self,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        value: Optional[List["SubmodelElement"]] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        SubmodelElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.value = value
+
+
+class DataElement(SubmodelElement):
+    """
+    A data element is a submodel element that is not further composed out of
+    other submodel elements.
+
+    A data element is a submodel element that has a value. The type of value differs
+    for different subtypes of data elements.
+
+    :constraint AASd-090:
+        .. _constraint_AASd-090:
+
+        For data elements :py:attr:`category` shall be one of the following
+        values: ``CONSTANT``, ``PARAMETER`` or ``VARIABLE``.
+
+        Default: ``VARIABLE``
+    """
+
+    def category_or_default(self) -> str:
+        """Return the :py:attr:`category` if set or the default value otherwise."""
+        return self.category if self.category else "VARIABLE"
+
+    def __init__(
+        self,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        SubmodelElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+
+
+class Property(DataElement):
+    """
+    A property is a data element that has a single value.
+
+    :constraint AASd-007:
+        .. _constraint_AASd-007:
+
+        If both, the :py:attr:`value` and the :py:attr:`value_id` are
+        present then the value of :py:attr:`value` needs to be identical to
+        the value of the referenced coded value in :py:attr:`value_id`.
+    """
+
+    #: Data type of the value
+    value_type: "DataTypeDefXSD"
+
+    #: The value of the property instance.
+    value: Optional[str]
+
+    #: Reference to the global unique ID of a coded value.
+    #:
+    #: .. note::
+    #:
+    #:     It is recommended to use a global reference.
+    value_id: Optional["Reference"]
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        if self.value_id is not None:
+            yield self.value_id
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+        if self.value_id is not None:
+            yield self.value_id
+
+            yield from self.value_id.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_property(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_property_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_property(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_property_with_context(self, context)
+
+    def __init__(
+        self,
+        value_type: "DataTypeDefXSD",
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        value: Optional[str] = None,
+        value_id: Optional["Reference"] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        DataElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.value_type = value_type
+        self.value = value
+        self.value_id = value_id
+
+
+class MultiLanguageProperty(DataElement):
+    """
+    A property is a data element that has a multi-language value.
+
+    :constraint AASd-012:
+        .. _constraint_AASd-012:
+
+        If both the :py:attr:`value` and the :py:attr:`value_id` are present then for each
+        string in a specific language the meaning must be the same as specified in
+        :py:attr:`value_id`.
+    """
+
+    #: The value of the property instance.
+    value: Optional[List["LangStringTextType"]]
+
+    #: Reference to the global unique ID of a coded value.
+    #:
+    #: .. note::
+    #:
+    #:     It is recommended to use a global reference.
+    value_id: Optional["Reference"]
+
+    def over_value_or_empty(self) -> Iterator["LangStringTextType"]:
+        """Yield from :py:attr:`.value` if set."""
+        if self.value is not None:
+            yield from self.value
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        if self.value is not None:
+            yield from self.value
+
+        if self.value_id is not None:
+            yield self.value_id
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+        if self.value is not None:
+            for yet_yet_yet_yet_yet_another_item in self.value:
+                yield yet_yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_yet_another_item.descend()
+
+        if self.value_id is not None:
+            yield self.value_id
+
+            yield from self.value_id.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_multi_language_property(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_multi_language_property_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_multi_language_property(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_multi_language_property_with_context(self, context)
+
+    def __init__(
+        self,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        value: Optional[List["LangStringTextType"]] = None,
+        value_id: Optional["Reference"] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        DataElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.value = value
+        self.value_id = value_id
+
+
+class Range(DataElement):
+    """
+    A range data element is a data element that defines a range with min and max.
+    """
+
+    #: Data type of the min und max
+    value_type: "DataTypeDefXSD"
+
+    #: The minimum value of the range.
+    #:
+    #: If the min value is missing, then the value is assumed to be negative infinite.
+    min: Optional[str]
+
+    #: The maximum value of the range.
+    #:
+    #: If the max value is missing, then the value is assumed to be positive infinite.
+    max: Optional[str]
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_range(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_range_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_range(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_range_with_context(self, context)
+
+    def __init__(
+        self,
+        value_type: "DataTypeDefXSD",
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        min: Optional[str] = None,
+        max: Optional[str] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        DataElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.value_type = value_type
+        self.min = min
+        self.max = max
+
+
+class ReferenceElement(DataElement):
+    """
+    A reference element is a data element that defines a logical reference to another
+    element within the same or another AAS or a reference to an external object or
+    entity.
+    """
+
+    #: Global reference to an external object or entity or a logical reference to
+    #: another element within the same or another AAS (i.e. a model reference to
+    #: a Referable).
+    value: Optional["Reference"]
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        if self.value is not None:
+            yield self.value
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+        if self.value is not None:
+            yield self.value
+
+            yield from self.value.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_reference_element(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_reference_element_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_reference_element(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_reference_element_with_context(self, context)
+
+    def __init__(
+        self,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        value: Optional["Reference"] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        DataElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.value = value
+
+
+class Blob(DataElement):
+    """
+    A :py:class:`Blob` is a data element that represents a file that is contained with its
+    source code in the value attribute.
+    """
+
+    #: The value of the :py:class:`Blob` instance of a blob data element.
+    #:
+    #: .. note::
+    #:
+    #:     In contrast to the file property the file content is stored directly as value
+    #:     in the :py:class:`Blob` data element.
+    value: Optional[bytes]
+
+    #: Content type of the content of the :py:class:`Blob`.
+    #:
+    #: The content type (MIME type) states which file extensions the file can have.
+    #:
+    #: Valid values are content types like e.g. ``application/json``, ``application/xls``,
+    #: ``image/jpg``.
+    #:
+    #: The allowed values are defined as in RFC2046.
+    content_type: str
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_blob(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_blob_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_blob(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_blob_with_context(self, context)
+
+    def __init__(
+        self,
+        content_type: str,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        value: Optional[bytes] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        DataElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.content_type = content_type
+        self.value = value
+
+
+class File(DataElement):
+    """
+    A File is a data element that represents an address to a file (a locator).
+
+    The value is an URI that can represent an absolute or relative path.
+    """
+
+    #: Path and name of the referenced file (with file extension).
+    #:
+    #: The path can be absolute or relative.
+    value: Optional[str]
+
+    #: Content type of the content of the file.
+    #:
+    #: The content type states which file extensions the file can have.
+    content_type: str
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_file(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_file_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_file(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_file_with_context(self, context)
+
+    def __init__(
+        self,
+        content_type: str,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        value: Optional[str] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        DataElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.content_type = content_type
+        self.value = value
+
+
+class AnnotatedRelationshipElement(RelationshipElement):
+    """
+    An annotated relationship element is a relationship element that can be annotated
+    with additional data elements.
+    """
+
+    #: A data element that represents an annotation that holds for the relationship
+    #: between the two elements
+    annotations: Optional[List["DataElement"]]
+
+    def over_annotations_or_empty(self) -> Iterator["DataElement"]:
+        """Yield from :py:attr:`.annotations` if set."""
+        if self.annotations is not None:
+            yield from self.annotations
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        yield self.first
+
+        yield self.second
+
+        if self.annotations is not None:
+            yield from self.annotations
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+        yield self.first
+
+        yield from self.first.descend()
+
+        yield self.second
+
+        yield from self.second.descend()
+
+        if self.annotations is not None:
+            for yet_yet_yet_yet_yet_another_item in self.annotations:
+                yield yet_yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_annotated_relationship_element(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_annotated_relationship_element_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_annotated_relationship_element(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_annotated_relationship_element_with_context(
+            self, context
+        )
+
+    def __init__(
+        self,
+        first: "Reference",
+        second: "Reference",
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        annotations: Optional[List["DataElement"]] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        RelationshipElement.__init__(
+            self,
+            first,
+            second,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.annotations = annotations
+
+
+class Entity(SubmodelElement):
+    """
+    An entity is a submodel element that is used to model entities.
+
+    :constraint AASd-014:
+        .. _constraint_AASd-014:
+
+        Either the attribute :py:attr:`global_asset_id` or :py:attr:`specific_asset_ids`
+        of an :py:class:`Entity` must be set if :py:attr:`entity_type` is set to
+        :py:attr:`EntityType.SELF_MANAGED_ENTITY`. They are not existing otherwise.
+    """
+
+    #: Describes statements applicable to the entity by a set of submodel elements,
+    #: typically with a qualified value.
+    statements: Optional[List["SubmodelElement"]]
+
+    #: Describes whether the entity is a co-managed entity or a self-managed entity.
+    entity_type: "EntityType"
+
+    #: Global identifier of the asset the entity is representing.
+    #:
+    #: .. note::
+    #:
+    #:     This is a global reference.
+    global_asset_id: Optional[str]
+
+    #: Reference to a specific asset ID representing a supplementary identifier
+    #: of the asset represented by the Asset Administration Shell.
+    specific_asset_ids: Optional[List["SpecificAssetID"]]
+
+    def over_statements_or_empty(self) -> Iterator["SubmodelElement"]:
+        """Yield from :py:attr:`.statements` if set."""
+        if self.statements is not None:
+            yield from self.statements
+
+    def over_specific_asset_ids_or_empty(self) -> Iterator["SpecificAssetID"]:
+        """Yield from :py:attr:`.specific_asset_ids` if set."""
+        if self.specific_asset_ids is not None:
+            yield from self.specific_asset_ids
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        if self.statements is not None:
+            yield from self.statements
+
+        if self.specific_asset_ids is not None:
+            yield from self.specific_asset_ids
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+        if self.statements is not None:
+            for yet_yet_yet_yet_yet_another_item in self.statements:
+                yield yet_yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_yet_another_item.descend()
+
+        if self.specific_asset_ids is not None:
+            for yet_yet_yet_yet_yet_yet_another_item in self.specific_asset_ids:
+                yield yet_yet_yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_yet_yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_entity(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_entity_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_entity(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_entity_with_context(self, context)
+
+    def __init__(
+        self,
+        entity_type: "EntityType",
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        statements: Optional[List["SubmodelElement"]] = None,
+        global_asset_id: Optional[str] = None,
+        specific_asset_ids: Optional[List["SpecificAssetID"]] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        SubmodelElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.statements = statements
+        self.entity_type = entity_type
+        self.global_asset_id = global_asset_id
+        self.specific_asset_ids = specific_asset_ids
+
+
+class EntityType(enum.Enum):
+    """
+    Enumeration for denoting whether an entity is a self-managed entity or a co-managed
+    entity.
+    """
+
+    #: For co-managed entities there is no separate AAS. Co-managed entities need to be
+    #: part of a self-managed entity.
+    CO_MANAGED_ENTITY = "CoManagedEntity"
+
+    #: Self-Managed Entities have their own AAS but can be part of the bill of material of
+    #: a composite self-managed entity.
+    #:
+    #: The asset of an I4.0 Component is a self-managed entity per definition.
+    SELF_MANAGED_ENTITY = "SelfManagedEntity"
+
+
+class Direction(enum.Enum):
+    """
+    Direction
+
+    .. note::
+
+        This element is experimental and therefore may be subject to change or may be
+        removed completely in future versions of the meta-model.
+    """
+
+    #: Input direction.
+    INPUT = "input"
+
+    #: Output direction
+    OUTPUT = "output"
+
+
+class StateOfEvent(enum.Enum):
+    """
+    State of an event
+
+    .. note::
+
+        This element is experimental and therefore may be subject to change or may be
+        removed completely in future versions of the meta-model.
+    """
+
+    #: Event is on
+    ON = "on"
+
+    #: Event is off.
+    OFF = "off"
+
+
+class EventPayload(Class):
+    """
+    Defines the necessary information of an event instance sent out or received.
+
+    .. note::
+
+        This element is experimental and therefore may be subject to change or may be
+        removed completely in future versions of the meta-model.
+    """
+
+    #: Reference to the source event element, including identification of
+    #: :py:class:`AssetAdministrationShell`, :py:class:`Submodel`,
+    #: :py:class:`SubmodelElement`'s.
+    source: "Reference"
+
+    #: :py:attr:`HasSemantics.semantic_id` of the source event element, if available
+    #:
+    #: .. note::
+    #:
+    #:     It is recommended to use a global reference.
+    source_semantic_id: Optional["Reference"]
+
+    #: Reference to the referable, which defines the scope of the event.
+    #:
+    #: Can be :py:class:`AssetAdministrationShell`, :py:class:`Submodel` or
+    #: :py:class:`SubmodelElement`.
+    observable_reference: "Reference"
+
+    #: :py:attr:`HasSemantics.semantic_id` of the referable which defines the scope of
+    #: the event, if available.
+    #:
+    #: .. note::
+    #:
+    #:     It is recommended to use a global reference.
+    observable_semantic_id: Optional["Reference"]
+
+    #: Information for the outer message infrastructure for scheduling the event to
+    #: the respective communication channel.
+    topic: Optional[str]
+
+    #: Subject, who/which initiated the creation.
+    #:
+    #: .. note::
+    #:
+    #:     This is an external reference.
+    subject_id: Optional["Reference"]
+
+    #: Timestamp in UTC, when this event was triggered.
+    time_stamp: str
+
+    #: Event specific payload.
+    payload: Optional[bytes]
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        yield self.source
+
+        if self.source_semantic_id is not None:
+            yield self.source_semantic_id
+
+        yield self.observable_reference
+
+        if self.observable_semantic_id is not None:
+            yield self.observable_semantic_id
+
+        if self.subject_id is not None:
+            yield self.subject_id
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        yield self.source
+
+        yield from self.source.descend()
+
+        if self.source_semantic_id is not None:
+            yield self.source_semantic_id
+
+            yield from self.source_semantic_id.descend()
+
+        yield self.observable_reference
+
+        yield from self.observable_reference.descend()
+
+        if self.observable_semantic_id is not None:
+            yield self.observable_semantic_id
+
+            yield from self.observable_semantic_id.descend()
+
+        if self.subject_id is not None:
+            yield self.subject_id
+
+            yield from self.subject_id.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_event_payload(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_event_payload_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_event_payload(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_event_payload_with_context(self, context)
+
+    def __init__(
+        self,
+        source: "Reference",
+        observable_reference: "Reference",
+        time_stamp: str,
+        source_semantic_id: Optional["Reference"] = None,
+        observable_semantic_id: Optional["Reference"] = None,
+        topic: Optional[str] = None,
+        subject_id: Optional["Reference"] = None,
+        payload: Optional[bytes] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        self.source = source
+        self.observable_reference = observable_reference
+        self.time_stamp = time_stamp
+        self.source_semantic_id = source_semantic_id
+        self.observable_semantic_id = observable_semantic_id
+        self.topic = topic
+        self.subject_id = subject_id
+        self.payload = payload
+
+
+class EventElement(SubmodelElement):
+    """
+    An event element.
+
+    .. note::
+
+        This element is experimental and therefore may be subject to change or may be
+        removed completely in future versions of the meta-model.
+    """
+
+    def __init__(
+        self,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        SubmodelElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+
+
+class BasicEventElement(EventElement):
+    """
+    A basic event element.
+
+    .. note::
+
+        This element is experimental and therefore may be subject to change or may be
+        removed completely in future versions of the meta-model.
+    """
+
+    #: Reference to the :py:class:`Referable`, which defines the scope of the event.
+    #: Can be :py:class:`AssetAdministrationShell`, :py:class:`Submodel`, or
+    #: :py:class:`SubmodelElement`.
+    #:
+    #: Reference to a referable, e.g., a data element or
+    #: a submodel, that is being observed.
+    observed: "Reference"
+
+    #: Direction of event.
+    #:
+    #: Can be ``{ Input, Output }``.
+    direction: "Direction"
+
+    #: State of event.
+    #:
+    #: Can be ``{ On, Off }``.
+    state: "StateOfEvent"
+
+    #: Information for the outer message infrastructure for scheduling the event to the
+    #: respective communication channel.
+    message_topic: Optional[str]
+
+    #: Information, which outer message infrastructure shall handle messages for
+    #: the :py:class:`EventElement`. Refers to a :py:class:`Submodel`,
+    #: :py:class:`SubmodelElementList`, :py:class:`SubmodelElementCollection` or
+    #: :py:class:`Entity`, which contains :py:class:`DataElement`'s describing
+    #: the proprietary specification for the message broker.
+    #:
+    #: .. note::
+    #:
+    #:     For different message infrastructure, e.g., OPC UA or MQTT or AMQP, this
+    #:     proprietary specification could be standardized by having respective Submodels.
+    message_broker: Optional["Reference"]
+
+    #: Timestamp in UTC, when the last event was received (input direction) or sent
+    #: (output direction).
+    last_update: Optional[str]
+
+    #: For input direction, reports on the maximum frequency, the software entity behind
+    #: the respective Referable can handle input events.
+    #:
+    #: For output events, specifies the maximum frequency of outputting this event to
+    #: an outer infrastructure.
+    #:
+    #: Might be not specified, that is, there is no minimum interval.
+    min_interval: Optional[str]
+
+    #: For input direction: not applicable.
+    #:
+    #: For output direction: maximum interval in time, the respective Referable shall send
+    #: an update of the status of the event, even if no other trigger condition for
+    #: the event was not met.
+    #:
+    #: Might be not specified, that is, there is no maximum interval
+    max_interval: Optional[str]
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        yield self.observed
+
+        if self.message_broker is not None:
+            yield self.message_broker
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+        yield self.observed
+
+        yield from self.observed.descend()
+
+        if self.message_broker is not None:
+            yield self.message_broker
+
+            yield from self.message_broker.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_basic_event_element(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_basic_event_element_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_basic_event_element(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_basic_event_element_with_context(self, context)
+
+    def __init__(
+        self,
+        observed: "Reference",
+        direction: "Direction",
+        state: "StateOfEvent",
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        message_topic: Optional[str] = None,
+        message_broker: Optional["Reference"] = None,
+        last_update: Optional[str] = None,
+        min_interval: Optional[str] = None,
+        max_interval: Optional[str] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        EventElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.observed = observed
+        self.direction = direction
+        self.state = state
+        self.message_topic = message_topic
+        self.message_broker = message_broker
+        self.last_update = last_update
+        self.min_interval = min_interval
+        self.max_interval = max_interval
+
+
+class Operation(SubmodelElement):
+    """
+    An operation is a submodel element with input and output variables.
+
+    :constraint AASd-134:
+        .. _constraint_AASd-134:
+
+        For an :py:class:`Operation` the :py:attr:`Referable.id_short` of all
+        :py:attr:`OperationVariable.value`'s in
+        :py:attr:`input_variables`, :py:attr:`output_variables`
+        and :py:attr:`inoutput_variables` shall be unique.
+    """
+
+    #: Input parameter of the operation.
+    input_variables: Optional[List["OperationVariable"]]
+
+    #: Output parameter of the operation.
+    output_variables: Optional[List["OperationVariable"]]
+
+    #: Parameter that is input and output of the operation.
+    inoutput_variables: Optional[List["OperationVariable"]]
+
+    def over_input_variables_or_empty(self) -> Iterator["OperationVariable"]:
+        """Yield from :py:attr:`.input_variables` if set."""
+        if self.input_variables is not None:
+            yield from self.input_variables
+
+    def over_output_variables_or_empty(self) -> Iterator["OperationVariable"]:
+        """Yield from :py:attr:`.output_variables` if set."""
+        if self.output_variables is not None:
+            yield from self.output_variables
+
+    def over_inoutput_variables_or_empty(self) -> Iterator["OperationVariable"]:
+        """Yield from :py:attr:`.inoutput_variables` if set."""
+        if self.inoutput_variables is not None:
+            yield from self.inoutput_variables
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        if self.input_variables is not None:
+            yield from self.input_variables
+
+        if self.output_variables is not None:
+            yield from self.output_variables
+
+        if self.inoutput_variables is not None:
+            yield from self.inoutput_variables
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+        if self.input_variables is not None:
+            for yet_yet_yet_yet_yet_another_item in self.input_variables:
+                yield yet_yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_yet_another_item.descend()
+
+        if self.output_variables is not None:
+            for yet_yet_yet_yet_yet_yet_another_item in self.output_variables:
+                yield yet_yet_yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_yet_yet_another_item.descend()
+
+        if self.inoutput_variables is not None:
+            for yet_yet_yet_yet_yet_yet_yet_another_item in self.inoutput_variables:
+                yield yet_yet_yet_yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_yet_yet_yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_operation(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_operation_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_operation(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_operation_with_context(self, context)
+
+    def __init__(
+        self,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        input_variables: Optional[List["OperationVariable"]] = None,
+        output_variables: Optional[List["OperationVariable"]] = None,
+        inoutput_variables: Optional[List["OperationVariable"]] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        SubmodelElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+        self.input_variables = input_variables
+        self.output_variables = output_variables
+        self.inoutput_variables = inoutput_variables
+
+
+class OperationVariable(Class):
+    """
+    The value of an operation variable is a submodel element that is used as input
+    and/or output variable of an operation.
+    """
+
+    #: Describes an argument or result of an operation via a submodel element
+    value: "SubmodelElement"
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        yield self.value
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        yield self.value
+
+        yield from self.value.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_operation_variable(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_operation_variable_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_operation_variable(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_operation_variable_with_context(self, context)
+
+    def __init__(self, value: "SubmodelElement") -> None:
+        """Initialize with the given values."""
+        self.value = value
+
+
+class Capability(SubmodelElement):
+    """
+    A capability is the implementation-independent description of the potential of an
+    asset to achieve a certain effect in the physical or virtual world.
+
+    .. note::
+
+        The :py:attr:`semantic_id` of a capability is typically an ontology.
+        Thus, reasoning on capabilities is enabled.
+    """
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+        if self.supplemental_semantic_ids is not None:
+            yield from self.supplemental_semantic_ids
+
+        if self.qualifiers is not None:
+            yield from self.qualifiers
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.semantic_id is not None:
+            yield self.semantic_id
+
+            yield from self.semantic_id.descend()
+
+        if self.supplemental_semantic_ids is not None:
+            for yet_yet_another_item in self.supplemental_semantic_ids:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.qualifiers is not None:
+            for yet_yet_yet_another_item in self.qualifiers:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_yet_yet_another_item
+
+                yield from yet_yet_yet_yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_capability(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_capability_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_capability(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_capability_with_context(self, context)
+
+    def __init__(
+        self,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        semantic_id: Optional["Reference"] = None,
+        supplemental_semantic_ids: Optional[List["Reference"]] = None,
+        qualifiers: Optional[List["Qualifier"]] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        SubmodelElement.__init__(
+            self,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            semantic_id,
+            supplemental_semantic_ids,
+            qualifiers,
+            embedded_data_specifications,
+        )
+
+
+class ConceptDescription(Identifiable, HasDataSpecification):
+    """
+    The semantics of a property or other elements that may have a semantic description
+    is defined by a concept description.
+
+    The description of the concept should follow a standardized schema (realized as
+    data specification template).
+
+    :constraint AASc-3a-004:
+        .. _constraint_AASc-3a-004:
+
+        For a :py:class:`ConceptDescription` with :py:attr:`category` ``PROPERTY`` or
+        ``VALUE`` using data specification IEC61360,
+        the :py:attr:`DataSpecificationIEC61360.data_type` is mandatory and shall be
+        one of: ``DATE``, ``STRING``, ``STRING_TRANSLATABLE``, ``INTEGER_MEASURE``,
+        ``INTEGER_COUNT``, ``INTEGER_CURRENCY``, ``REAL_MEASURE``, ``REAL_COUNT``,
+        ``REAL_CURRENCY``, ``BOOLEAN``, ``RATIONAL``, ``RATIONAL_MEASURE``,
+        ``TIME``, ``TIMESTAMP``.
+
+        .. note::
+
+            Note: categories are deprecated since V3.0 of Part 1a of the document series
+            "Details of the Asset Administration Shell".
+
+    :constraint AASc-3a-005:
+        .. _constraint_AASc-3a-005:
+
+        For a :py:class:`ConceptDescription` with :py:attr:`category` ``REFERENCE``
+        using data specification template IEC61360,
+        the :py:attr:`DataSpecificationIEC61360.data_type` shall be
+        one of: ``STRING``, ``IRI``, ``IRDI``.
+
+        .. note::
+
+            Note: categories are deprecated since V3.0 of Part 1a of the document series
+            "Details of the Asset Administration Shell".
+
+    :constraint AASc-3a-006:
+        .. _constraint_AASc-3a-006:
+
+        For a :py:class:`ConceptDescription` with :py:attr:`category` ``DOCUMENT``
+        using data specification IEC61360,
+        the :py:attr:`DataSpecificationIEC61360.data_type` shall be one of ``FILE``,
+        ``BLOB``, ``HTML``
+
+        .. note::
+
+            Categories are deprecated since V3.0 of Part 1a of the document series
+            "Details of the Asset Administration Shell".
+
+    :constraint AASc-3a-007:
+        .. _constraint_AASc-3a-007:
+
+        For a :py:class:`ConceptDescription` with :py:attr:`category` ``QUALIFIER_TYPE``
+        using data specification IEC61360,
+        the :py:attr:`DataSpecificationIEC61360.data_type` is mandatory and shall be
+        defined.
+
+        .. note::
+
+            Categories are deprecated since V3.0 of Part 1a of the document series
+            "Details of the Asset Administration Shell".
+
+    :constraint AASc-3a-008:
+        .. _constraint_AASc-3a-008:
+
+        For a :py:class:`ConceptDescription` using data specification template IEC61360,
+        :py:attr:`DataSpecificationIEC61360.definition` is mandatory and shall be
+        defined at least in English.
+
+        Exception: The concept description describes a value, i.e.
+        :py:attr:`DataSpecificationIEC61360.value` is defined.
+
+    :constraint AASc-3a-003:
+        .. _constraint_AASc-3a-003:
+
+        For a :py:class:`ConceptDescription` using data specification template IEC61360,
+        referenced via :py:attr:`DataSpecificationIEC61360.value_list`
+        :py:attr:`ValueReferencePair.value_id`
+        the :py:attr:`DataSpecificationIEC61360.value` shall be set.
+    """
+
+    #: Reference to an external definition the concept is compatible to or was derived
+    #: from.
+    #:
+    #: .. note::
+    #:
+    #:     It is recommended to use a global reference.
+    #:
+    #: .. note::
+    #:
+    #:     Compare to is-case-of relationship in ISO 13584-32 & IEC EN 61360
+    is_case_of: Optional[List["Reference"]]
+
+    def over_is_case_of_or_empty(self) -> Iterator["Reference"]:
+        """Yield from :py:attr:`.is_case_of` if set."""
+        if self.is_case_of is not None:
+            yield from self.is_case_of
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.extensions is not None:
+            yield from self.extensions
+
+        if self.display_name is not None:
+            yield from self.display_name
+
+        if self.description is not None:
+            yield from self.description
+
+        if self.administration is not None:
+            yield self.administration
+
+        if self.embedded_data_specifications is not None:
+            yield from self.embedded_data_specifications
+
+        if self.is_case_of is not None:
+            yield from self.is_case_of
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.extensions is not None:
+            for an_item in self.extensions:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.display_name is not None:
+            for another_item in self.display_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.description is not None:
+            for yet_another_item in self.description:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.administration is not None:
+            yield self.administration
+
+            yield from self.administration.descend()
+
+        if self.embedded_data_specifications is not None:
+            for yet_yet_another_item in self.embedded_data_specifications:
+                yield yet_yet_another_item
+
+                yield from yet_yet_another_item.descend()
+
+        if self.is_case_of is not None:
+            for yet_yet_yet_another_item in self.is_case_of:
+                yield yet_yet_yet_another_item
+
+                yield from yet_yet_yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_concept_description(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_concept_description_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_concept_description(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_concept_description_with_context(self, context)
+
+    def __init__(
+        self,
+        id: str,
+        extensions: Optional[List["Extension"]] = None,
+        category: Optional[str] = None,
+        id_short: Optional[str] = None,
+        display_name: Optional[List["LangStringNameType"]] = None,
+        description: Optional[List["LangStringTextType"]] = None,
+        administration: Optional["AdministrativeInformation"] = None,
+        embedded_data_specifications: Optional[
+            List["EmbeddedDataSpecification"]
+        ] = None,
+        is_case_of: Optional[List["Reference"]] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        Identifiable.__init__(
+            self,
+            id,
+            extensions,
+            category,
+            id_short,
+            display_name,
+            description,
+            administration,
+        )
+        HasDataSpecification.__init__(self, embedded_data_specifications)
+        self.is_case_of = is_case_of
+
+
+class ReferenceTypes(enum.Enum):
+    """Reference types"""
+
+    #: External reference.
+    EXTERNAL_REFERENCE = "ExternalReference"
+
+    #: Model reference.
+    MODEL_REFERENCE = "ModelReference"
+
+
+class Reference(Class):
+    """
+    Reference to either a model element of the same or another AAS or to an external
+    entity.
+
+    A reference is an ordered list of keys.
+
+    A model reference is an ordered list of keys, each key referencing an element. The
+    complete list of keys may for example be concatenated to a path that then gives
+    unique access to an element.
+
+    An external reference is a reference to an external entity.
+
+    :constraint AASd-121:
+        .. _constraint_AASd-121:
+
+        For :py:class:`Reference`'s the value of :py:attr:`Key.type` of the first key of "
+        :py:attr:`keys` shall be one of :py:attr:`.constants.GLOBALLY_IDENTIFIABLES`.
+
+    :constraint AASd-122:
+        .. _constraint_AASd-122:
+
+        For external references, i.e. :py:class:`Reference`'s with
+        :py:attr:`type` = :py:attr:`ReferenceTypes.EXTERNAL_REFERENCE`, the value
+        of :py:attr:`Key.type` of the first key of :py:attr:`keys` shall be one of
+        :py:attr:`.constants.GENERIC_GLOBALLY_IDENTIFIABLES`.
+
+    :constraint AASd-123:
+        .. _constraint_AASd-123:
+
+        For model references, i.e. :py:class:`Reference`'s with
+        :py:attr:`type` = :py:attr:`ReferenceTypes.MODEL_REFERENCE`, the value
+        of :py:attr:`Key.type` of the first key of :py:attr:`keys` shall be one of
+        :py:attr:`.constants.AAS_IDENTIFIABLES`.
+
+    :constraint AASd-124:
+        .. _constraint_AASd-124:
+
+        For external references, i.e. :py:class:`Reference`'s with
+        :py:attr:`type` = :py:attr:`ReferenceTypes.EXTERNAL_REFERENCE`, the last
+        key of :py:attr:`keys` shall be either one of
+        :py:attr:`.constants.GENERIC_GLOBALLY_IDENTIFIABLES` or one of
+        :py:attr:`.constants.GENERIC_FRAGMENT_KEYS`.
+
+    :constraint AASd-125:
+        .. _constraint_AASd-125:
+
+        For model references, i.e. :py:class:`Reference`'s with
+        :py:attr:`type` = :py:attr:`ReferenceTypes.MODEL_REFERENCE`, with more
+        than one key in :py:attr:`keys` the value of :py:attr:`Key.type`
+        of each of the keys following the first
+        key of :py:attr:`keys` shall be one of :py:attr:`.constants.FRAGMENT_KEYS`.
+
+        .. note::
+
+            :ref:`Constraint AASd-125 <constraint_AASd-125>` ensures that the shortest path is used.
+
+    :constraint AASd-126:
+        .. _constraint_AASd-126:
+
+        For model references, i.e. :py:class:`Reference`'s with
+        :py:attr:`type` = :py:attr:`ReferenceTypes.MODEL_REFERENCE`, with more
+        than one key in :py:attr:`keys` the value of :py:attr:`Key.type`
+        of the last key in the reference key chain may be
+        one of :py:attr:`.constants.GENERIC_FRAGMENT_KEYS` or no key at all
+        shall have a value out of :py:attr:`.constants.GENERIC_FRAGMENT_KEYS`.
+
+    :constraint AASd-127:
+        .. _constraint_AASd-127:
+
+        For model references, i.e. :py:class:`Reference`'s with
+        :py:attr:`type` = :py:attr:`ReferenceTypes.MODEL_REFERENCE`, with more
+        than one key in :py:attr:`keys` a key with :py:attr:`Key.type`
+        :py:attr:`KeyTypes.FRAGMENT_REFERENCE` shall be preceded by a key with
+        :py:attr:`Key.type` :py:attr:`KeyTypes.FILE` or :py:attr:`KeyTypes.BLOB`. All other
+        AAS fragments, i.e. :py:attr:`Key.type` values
+        out of :py:attr:`.constants.AAS_SUBMODEL_ELEMENTS_AS_KEYS`, do not support fragments.
+
+        .. note::
+
+            Which kind of fragments are supported depends on the content type and the
+            specification of allowed fragment identifiers for the corresponding resource
+            being referenced via the reference.
+
+    :constraint AASd-128:
+        .. _constraint_AASd-128:
+
+        For model references, i.e. :py:class:`Reference`'s with
+        :py:attr:`type` = :py:attr:`ReferenceTypes.MODEL_REFERENCE`, the
+        :py:attr:`Key.value` of a :py:class:`Key` preceded by a :py:class:`Key` with
+        :py:attr:`Key.type` = :py:attr:`KeyTypes.SUBMODEL_ELEMENT_LIST` is an integer
+        number denoting the position in the array of the submodel element list.
+    """
+
+    #: Type of the reference.
+    #:
+    #: Denotes, whether reference is an external reference or a model reference.
+    type: "ReferenceTypes"
+
+    #: :py:attr:`HasSemantics.semantic_id` of the referenced model element
+    #: (:py:attr:`type` = :py:attr:`ReferenceTypes.MODEL_REFERENCE`).
+    #:
+    #: For external references there typically is no semantic ID.
+    #:
+    #: .. note::
+    #:
+    #:     It is recommended to use a external reference.
+    referred_semantic_id: Optional["Reference"]
+
+    #: Unique references in their name space.
+    keys: List["Key"]
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.referred_semantic_id is not None:
+            yield self.referred_semantic_id
+
+        yield from self.keys
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.referred_semantic_id is not None:
+            yield self.referred_semantic_id
+
+            yield from self.referred_semantic_id.descend()
+
+        for an_item in self.keys:
+            yield an_item
+
+            yield from an_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_reference(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_reference_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_reference(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_reference_with_context(self, context)
+
+    def __init__(
+        self,
+        type: "ReferenceTypes",
+        keys: List["Key"],
+        referred_semantic_id: Optional["Reference"] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        self.type = type
+        self.keys = keys
+        self.referred_semantic_id = referred_semantic_id
+
+
+class Key(Class):
+    """A key is a reference to an element by its ID."""
+
+    #: Denotes which kind of entity is referenced.
+    #:
+    #: In case :py:attr:`type` = :py:attr:`KeyTypes.GLOBAL_REFERENCE`,
+    #: the key represents a reference to a source that can be globally identified.
+    #:
+    #: In case :py:attr:`type` = :py:attr:`KeyTypes.FRAGMENT_REFERENCE` the key represents
+    #: a bookmark or a similar local identifier within its parent element as specified
+    #: by the key that precedes this key.
+    #:
+    #: In all other cases the key references a model element of the same or of another AAS.
+    #: The name of the model element is explicitly listed.
+    type: "KeyTypes"
+
+    #: The key value, for example an IRDI or an URI
+    value: str
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_key(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_key_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_key(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_key_with_context(self, context)
+
+    def __init__(self, type: "KeyTypes", value: str) -> None:
+        """Initialize with the given values."""
+        self.type = type
+        self.value = value
+
+
+class KeyTypes(enum.Enum):
+    """Enumeration of different key value types within a key."""
+
+    ANNOTATED_RELATIONSHIP_ELEMENT = "AnnotatedRelationshipElement"
+
+    ASSET_ADMINISTRATION_SHELL = "AssetAdministrationShell"
+
+    BASIC_EVENT_ELEMENT = "BasicEventElement"
+
+    BLOB = "Blob"
+
+    CAPABILITY = "Capability"
+
+    CONCEPT_DESCRIPTION = "ConceptDescription"
+
+    #: Data element.
+    #:
+    #: .. note::
+    #:
+    #:     Data Element is abstract, *i.e.* if a key uses :py:attr:`DATA_ELEMENT`
+    #:     the reference may be a Property, a File etc.
+    DATA_ELEMENT = "DataElement"
+
+    ENTITY = "Entity"
+
+    #: Event.
+    #:
+    #: .. note::
+    #:
+    #:     :py:class:`EventElement` is abstract.
+    EVENT_ELEMENT = "EventElement"
+
+    FILE = "File"
+
+    #: Bookmark or a similar local identifier of a subordinate part of
+    #: a primary resource
+    FRAGMENT_REFERENCE = "FragmentReference"
+
+    GLOBAL_REFERENCE = "GlobalReference"
+
+    #: Identifiable.
+    #:
+    #: .. note::
+    #:
+    #:     Identifiable is abstract, i.e. if a key uses Identifiable the reference
+    #:     may be an Asset Administration Shell, a Submodel or a Concept Description.
+    IDENTIFIABLE = "Identifiable"
+
+    #: Property with a value that can be provided in multiple languages
+    MULTI_LANGUAGE_PROPERTY = "MultiLanguageProperty"
+
+    OPERATION = "Operation"
+
+    PROPERTY = "Property"
+
+    #: Range with min and max
+    RANGE = "Range"
+
+    REFERABLE = "Referable"
+
+    #: Reference
+    REFERENCE_ELEMENT = "ReferenceElement"
+
+    #: Relationship
+    RELATIONSHIP_ELEMENT = "RelationshipElement"
+
+    SUBMODEL = "Submodel"
+
+    #: Submodel Element
+    #:
+    #: .. note::
+    #:
+    #:     Submodel Element is abstract, *i.e.* if a key uses :py:attr:`SUBMODEL_ELEMENT`
+    #:     the reference may be a :py:class:`Property`, an :py:class:`Operation` etc.
+    SUBMODEL_ELEMENT = "SubmodelElement"
+
+    #: Struct of Submodel Elements
+    SUBMODEL_ELEMENT_COLLECTION = "SubmodelElementCollection"
+
+    #: List of Submodel Elements
+    SUBMODEL_ELEMENT_LIST = "SubmodelElementList"
+
+
+class DataTypeDefXSD(enum.Enum):
+    """Enumeration listing all XSD anySimpleTypes"""
+
+    ANY_URI = "xs:anyURI"
+
+    BASE_64_BINARY = "xs:base64Binary"
+
+    BOOLEAN = "xs:boolean"
+
+    BYTE = "xs:byte"
+
+    DATE = "xs:date"
+
+    DATE_TIME = "xs:dateTime"
+
+    DECIMAL = "xs:decimal"
+
+    DOUBLE = "xs:double"
+
+    DURATION = "xs:duration"
+
+    FLOAT = "xs:float"
+
+    G_DAY = "xs:gDay"
+
+    G_MONTH = "xs:gMonth"
+
+    G_MONTH_DAY = "xs:gMonthDay"
+
+    G_YEAR = "xs:gYear"
+
+    G_YEAR_MONTH = "xs:gYearMonth"
+
+    HEX_BINARY = "xs:hexBinary"
+
+    INT = "xs:int"
+
+    INTEGER = "xs:integer"
+
+    LONG = "xs:long"
+
+    NEGATIVE_INTEGER = "xs:negativeInteger"
+
+    NON_NEGATIVE_INTEGER = "xs:nonNegativeInteger"
+
+    NON_POSITIVE_INTEGER = "xs:nonPositiveInteger"
+
+    POSITIVE_INTEGER = "xs:positiveInteger"
+
+    SHORT = "xs:short"
+
+    STRING = "xs:string"
+
+    TIME = "xs:time"
+
+    UNSIGNED_BYTE = "xs:unsignedByte"
+
+    UNSIGNED_INT = "xs:unsignedInt"
+
+    UNSIGNED_LONG = "xs:unsignedLong"
+
+    UNSIGNED_SHORT = "xs:unsignedShort"
+
+
+class AbstractLangString(Class):
+    """Strings with language tags"""
+
+    #: Language tag conforming to BCP 47
+    language: str
+
+    #: Text in the :py:attr:`language`
+    text: str
+
+    def __init__(self, language: str, text: str) -> None:
+        """Initialize with the given values."""
+        self.language = language
+        self.text = text
+
+
+class LangStringNameType(AbstractLangString):
+    """
+    String with length 128 maximum and minimum 1 characters and with language tags
+    """
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_lang_string_name_type(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_lang_string_name_type_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_lang_string_name_type(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_lang_string_name_type_with_context(self, context)
+
+    def __init__(self, language: str, text: str) -> None:
+        """Initialize with the given values."""
+        AbstractLangString.__init__(self, language, text)
+
+
+class LangStringTextType(AbstractLangString):
+    """
+    String with length 1023 maximum and minimum 1 characters and with language tags
+    """
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_lang_string_text_type(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_lang_string_text_type_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_lang_string_text_type(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_lang_string_text_type_with_context(self, context)
+
+    def __init__(self, language: str, text: str) -> None:
+        """Initialize with the given values."""
+        AbstractLangString.__init__(self, language, text)
+
+
+class Environment(Class):
+    """
+    Container for the sets of different identifiables.
+
+    .. note::
+
+        w.r.t. file exchange: There is exactly one environment independent on how many
+        files the contained elements are split. If the file is split then there
+        shall be no element with the same identifier in two different files.
+    """
+
+    #: Asset administration shell
+    asset_administration_shells: Optional[List["AssetAdministrationShell"]]
+
+    #: Submodel
+    submodels: Optional[List["Submodel"]]
+
+    #: Concept description
+    concept_descriptions: Optional[List["ConceptDescription"]]
+
+    def over_asset_administration_shells_or_empty(
+        self,
+    ) -> Iterator["AssetAdministrationShell"]:
+        """Yield from :py:attr:`.asset_administration_shells` if set."""
+        if self.asset_administration_shells is not None:
+            yield from self.asset_administration_shells
+
+    def over_submodels_or_empty(self) -> Iterator["Submodel"]:
+        """Yield from :py:attr:`.submodels` if set."""
+        if self.submodels is not None:
+            yield from self.submodels
+
+    def over_concept_descriptions_or_empty(self) -> Iterator["ConceptDescription"]:
+        """Yield from :py:attr:`.concept_descriptions` if set."""
+        if self.concept_descriptions is not None:
+            yield from self.concept_descriptions
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        if self.asset_administration_shells is not None:
+            yield from self.asset_administration_shells
+
+        if self.submodels is not None:
+            yield from self.submodels
+
+        if self.concept_descriptions is not None:
+            yield from self.concept_descriptions
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        if self.asset_administration_shells is not None:
+            for an_item in self.asset_administration_shells:
+                yield an_item
+
+                yield from an_item.descend()
+
+        if self.submodels is not None:
+            for another_item in self.submodels:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.concept_descriptions is not None:
+            for yet_another_item in self.concept_descriptions:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_environment(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_environment_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_environment(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_environment_with_context(self, context)
+
+    def __init__(
+        self,
+        asset_administration_shells: Optional[List["AssetAdministrationShell"]] = None,
+        submodels: Optional[List["Submodel"]] = None,
+        concept_descriptions: Optional[List["ConceptDescription"]] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        self.asset_administration_shells = asset_administration_shells
+        self.submodels = submodels
+        self.concept_descriptions = concept_descriptions
+
+
+class DataSpecificationContent(Class):
+    """
+    Data specification content is part of a data specification template and defines
+    which additional attributes shall be added to the element instance that references
+    the data specification template and meta information about the template itself.
+
+    :constraint AASc-3a-050:
+        .. _constraint_AASc-3a-050:
+
+        If the :py:class:`DataSpecificationIEC61360` is used
+        for an element, the value of
+        :py:attr:`HasDataSpecification.embedded_data_specifications`
+        shall contain the global reference to the IRI of the corresponding
+        data specification template
+        https://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/3/0
+    """
+
+
+class EmbeddedDataSpecification(Class):
+    """Embed the content of a data specification."""
+
+    #: Reference to the data specification
+    data_specification: "Reference"
+
+    #: Actual content of the data specification
+    data_specification_content: "DataSpecificationContent"
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        yield self.data_specification
+
+        yield self.data_specification_content
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        yield self.data_specification
+
+        yield from self.data_specification.descend()
+
+        yield self.data_specification_content
+
+        yield from self.data_specification_content.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_embedded_data_specification(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_embedded_data_specification_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_embedded_data_specification(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_embedded_data_specification_with_context(
+            self, context
+        )
+
+    def __init__(
+        self,
+        data_specification: "Reference",
+        data_specification_content: "DataSpecificationContent",
+    ) -> None:
+        """Initialize with the given values."""
+        self.data_specification = data_specification
+        self.data_specification_content = data_specification_content
+
+
+class DataTypeIEC61360(enum.Enum):
+    # pylint: disable=missing-class-docstring
+
+    #: values containing a calendar date, conformant to ISO 8601:2004 Format yyyy-mm-dd
+    #: Example from IEC 61360-1:2017: "1999-05-31" is the [DATE] representation of:
+    #: "31 May 1999".
+    DATE = "DATE"
+
+    #: values consisting of sequence of characters but cannot be translated into other
+    #: languages
+    STRING = "STRING"
+
+    #: values containing string but shall be represented as different string in different
+    #: languages
+    STRING_TRANSLATABLE = "STRING_TRANSLATABLE"
+
+    #: values containing values that are measure of type INTEGER. In addition such a value
+    #: comes with a physical unit.
+    INTEGER_MEASURE = "INTEGER_MEASURE"
+
+    #: values containing values of type INTEGER but are no currencies or measures
+    INTEGER_COUNT = "INTEGER_COUNT"
+
+    #: values containing values of type INTEGER that are currencies
+    INTEGER_CURRENCY = "INTEGER_CURRENCY"
+
+    #: values containing values that are measures of type REAL. In addition such a value
+    #: comes with a physical unit.
+    REAL_MEASURE = "REAL_MEASURE"
+
+    #: values containing numbers that can be written as a terminating or non-terminating
+    #: decimal; a rational or irrational number but are no currencies or measures
+    REAL_COUNT = "REAL_COUNT"
+
+    #: values containing values of type REAL that are currencies
+    REAL_CURRENCY = "REAL_CURRENCY"
+
+    #: values representing truth of logic or Boolean algebra (TRUE, FALSE)
+    BOOLEAN = "BOOLEAN"
+
+    #: values containing values of type STRING conformant to Rfc 3987
+    #:
+    #: .. note::
+    #:
+    #:     In IEC61360-1 (2017) only URI is supported.
+    #:     An IRI type allows in particular to express an URL or an URI.
+    IRI = "IRI"
+
+    #: values conforming to ISO/IEC 11179 series global identifier sequences
+    #:
+    #: IRDI can be used instead of the more specific data types ICID or ISO29002_IRDI.
+    #:
+    #: ICID values are value conformant to an IRDI, where the delimiter between RAI and ID
+    #: is # while the delimiter between DI and VI is confined to ##
+    #:
+    #: ISO29002_IRDI values are values containing a global identifier that identifies an
+    #: administrated item in a registry. The structure of this identifier complies with
+    #: identifier syntax defined in ISO/TS 29002-5. The identifier shall fulfil the
+    #: requirements specified in ISO/TS 29002-5 for an "international registration data
+    #: identifier" (IRDI).
+    IRDI = "IRDI"
+
+    #: values containing values of type rational
+    RATIONAL = "RATIONAL"
+
+    #: values containing values of type rational. In addition such a value comes with a
+    #: physical unit.
+    RATIONAL_MEASURE = "RATIONAL_MEASURE"
+
+    #: values containing a time, conformant to ISO 8601:2004 but restricted to what is
+    #: allowed in the corresponding type in xml.
+    #:
+    #: Format hh:mm (ECLASS)
+    #:
+    #: Example from IEC 61360-1:2017: "13:20:00-05:00" is the [TIME] representation of:
+    #: 1.20 p.m. for Eastern Standard Time, which is 5 hours behind Coordinated
+    #: Universal Time (UTC).
+    TIME = "TIME"
+
+    #: values containing a time, conformant to ISO 8601:2004 but restricted to what is
+    #: allowed in the corresponding type in xml.
+    #:
+    #: Format yyyy-mm-dd hh:mm (ECLASS)
+    TIMESTAMP = "TIMESTAMP"
+
+    #: values containing an address to a file. The values are of type URI and can represent
+    #: an absolute or relative path.
+    #:
+    #: .. note::
+    #:
+    #:     IEC61360 does not support the file type.
+    FILE = "FILE"
+
+    #: Values containing string with any sequence of characters, using the syntax of HTML5
+    #: (see W3C Recommendation 28:2014)
+    HTML = "HTML"
+
+    #: values containing the content of a file. Values may be binaries.
+    #:
+    #: HTML conformant to HTML5 is a special blob.
+    #:
+    #: In IEC61360 binary is for a sequence of bits, each bit being represented by 0 and
+    #: 1 only. A binary is a blob but a blob may also contain other source code.
+    BLOB = "BLOB"
+
+
+class LevelType(Class):
+    """
+    Value represented by up to four variants of a numeric value in a specific role:
+    ``MIN``, ``NOM``, ``TYP`` and ``MAX``. True means that the value is available,
+    false means the value is not available.
+
+    EXAMPLE from [IEC61360-1]: In the case of having a property which is
+    of the LEVEL_TYPE min/max  expressing a range  only those two values
+    need to be provided.
+
+    .. note::
+
+        This is how AAS deals with the following combinations of level types:
+
+        * Either all attributes are false. In this case the concept is mapped
+          to a :py:class:`Property` and level type is ignored.
+        * At most one of the attributes is set to true. In this case
+          the concept is mapped to a :py:class:`Property`.
+        * Min and max are set to true. In this case the concept is mapped
+          to a :py:class:`Range`.
+        * More than one attribute is set to true but not min and max only
+          (see second case). In this case the concept is mapped
+          to a :py:class:`SubmodelElementCollection` with the corresponding
+          number of Properties.
+          Example: If attribute :py:attr:`min` and :py:attr:`nom` are set to true
+          then the concept is mapped to a :py:class:`SubmodelElementCollection`
+          with two Properties within: min and nom.
+          The data type of both Properties is the same.
+
+    .. note::
+
+        In the cases 2. and 4. the :py:attr:`Property.semantic_id` of the Property
+        or Properties within the :py:class:`SubmodelElementCollection` needs to include
+        information about the level type. Otherwise, the semantics is not described
+        in a unique way. Please refer to the specification.
+    """
+
+    #: Minimum of the value
+    min: bool
+
+    #: Nominal value (value as designated)
+    nom: bool
+
+    #: Value as typically present
+    typ: bool
+
+    #: Maximum of the value
+    max: bool
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_level_type(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_level_type_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_level_type(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_level_type_with_context(self, context)
+
+    def __init__(self, min: bool, nom: bool, typ: bool, max: bool) -> None:
+        """Initialize with the given values."""
+        self.min = min
+        self.nom = nom
+        self.typ = typ
+        self.max = max
+
+
+class ValueReferencePair(Class):
+    """
+    A value reference pair within a value list. Each value has a global unique id
+    defining its semantic.
+    """
+
+    #: The value of the referenced concept definition of the value in :py:attr:`value_id`.
+    value: str
+
+    #: Global unique id of the value.
+    #:
+    #: .. note::
+    #:
+    #:     It is recommended to use a global reference.
+    value_id: "Reference"
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        yield self.value_id
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        yield self.value_id
+
+        yield from self.value_id.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_value_reference_pair(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_value_reference_pair_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_value_reference_pair(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_value_reference_pair_with_context(self, context)
+
+    def __init__(self, value: str, value_id: "Reference") -> None:
+        """Initialize with the given values."""
+        self.value = value
+        self.value_id = value_id
+
+
+class ValueList(Class):
+    """A set of value reference pairs."""
+
+    #: A pair of a value together with its global unique id.
+    value_reference_pairs: List["ValueReferencePair"]
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        yield from self.value_reference_pairs
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        for an_item in self.value_reference_pairs:
+            yield an_item
+
+            yield from an_item.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_value_list(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_value_list_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_value_list(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_value_list_with_context(self, context)
+
+    def __init__(self, value_reference_pairs: List["ValueReferencePair"]) -> None:
+        """Initialize with the given values."""
+        self.value_reference_pairs = value_reference_pairs
+
+
+class LangStringPreferredNameTypeIEC61360(AbstractLangString):
+    """
+    String with length 255 maximum and minimum 1 characters and with language tags
+
+    .. note::
+
+        It is advised to keep the length of the name limited to 35 characters.
+    """
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_lang_string_preferred_name_type_iec_61360(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_lang_string_preferred_name_type_iec_61360_with_context(
+            self, context
+        )
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_lang_string_preferred_name_type_iec_61360(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_lang_string_preferred_name_type_iec_61360_with_context(
+            self, context
+        )
+
+    def __init__(self, language: str, text: str) -> None:
+        """Initialize with the given values."""
+        AbstractLangString.__init__(self, language, text)
+
+
+class LangStringShortNameTypeIEC61360(AbstractLangString):
+    """
+    String with length 18 maximum and minimum 1 characters and with language tags
+    """
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_lang_string_short_name_type_iec_61360(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_lang_string_short_name_type_iec_61360_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_lang_string_short_name_type_iec_61360(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_lang_string_short_name_type_iec_61360_with_context(
+            self, context
+        )
+
+    def __init__(self, language: str, text: str) -> None:
+        """Initialize with the given values."""
+        AbstractLangString.__init__(self, language, text)
+
+
+class LangStringDefinitionTypeIEC61360(AbstractLangString):
+    """
+    String with length 1023 maximum and minimum 1 characters and with language tags
+    """
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        # No descendable properties
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_lang_string_definition_type_iec_61360(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_lang_string_definition_type_iec_61360_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_lang_string_definition_type_iec_61360(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_lang_string_definition_type_iec_61360_with_context(
+            self, context
+        )
+
+    def __init__(self, language: str, text: str) -> None:
+        """Initialize with the given values."""
+        AbstractLangString.__init__(self, language, text)
+
+
+class DataSpecificationIEC61360(DataSpecificationContent):
+    """
+    Content of data specification template for concept descriptions for properties,
+    values and value lists conformant to IEC 61360.
+
+    .. note::
+
+        IEC61360 requires also a globally unique identifier for a concept
+        description. This ID is not part of the data specification template.
+        Instead the :py:attr:`ConceptDescription.id` as inherited via
+        :py:class:`Identifiable` is used. Same holds for administrative
+        information like the version and revision.
+
+    .. note::
+
+        :py:attr:`ConceptDescription.id_short` and :py:attr:`short_name` are very
+        similar. However, in this case the decision was to add
+        :py:attr:`short_name` explicitly to the data specification. Same holds for
+        :py:attr:`ConceptDescription.display_name` and
+        :py:attr:`preferred_name`. Same holds for
+        :py:attr:`ConceptDescription.description` and :py:attr:`definition`.
+
+    :constraint AASc-3a-010:
+        .. _constraint_AASc-3a-010:
+
+        If :py:attr:`value` is not empty then :py:attr:`value_list` shall be empty
+        and vice versa.
+
+        .. note::
+
+            It is also possible that both :py:attr:`value` and :py:attr:`value_list` are
+            empty. This is the case for concept descriptions that define the semantics
+            of a property but do not have an enumeration (:py:attr:`value_list`) as
+            data type.
+
+        .. note::
+
+            Although it is possible to define a :py:class:`ConceptDescription` for a
+            :attr:value_list`,
+            it is not possible to reuse this :py:attr:`value_list`.
+            It is only possible to directly add a :py:attr:`value_list` as data type
+            to a specific semantic definition of a property.
+
+    :constraint AASc-3a-009:
+        .. _constraint_AASc-3a-009:
+
+        If :py:attr:`data_type` one of:
+        :py:attr:`DataTypeIEC61360.INTEGER_MEASURE`,
+        :py:attr:`DataTypeIEC61360.REAL_MEASURE`,
+        :py:attr:`DataTypeIEC61360.RATIONAL_MEASURE`,
+        :py:attr:`DataTypeIEC61360.INTEGER_CURRENCY`,
+        :py:attr:`DataTypeIEC61360.REAL_CURRENCY`, then :py:attr:`unit` or
+        :py:attr:`unit_id` shall be defined.
+    """
+
+    #: Preferred name
+    #:
+    #: .. note::
+    #:
+    #:     It is advised to keep the length of the name limited to 35 characters.
+    #:
+    #: :constraint AASc-3a-002:
+    #:     .. _constraint_AASc-3a-002:
+    #:
+    #:     :py:attr:`preferred_name` shall be provided at least in English.
+    preferred_name: List["LangStringPreferredNameTypeIEC61360"]
+
+    #: Short name
+    short_name: Optional[List["LangStringShortNameTypeIEC61360"]]
+
+    #: Unit
+    unit: Optional[str]
+
+    #: Unique unit id
+    #:
+    #: :py:attr:`unit` and :py:attr:`unit_id` need to be consistent if both attributes
+    #: are set
+    #:
+    #: .. note::
+    #:
+    #:     It is recommended to use an external reference ID.
+    unit_id: Optional["Reference"]
+
+    #: Source of definition
+    source_of_definition: Optional[str]
+
+    #: Symbol
+    symbol: Optional[str]
+
+    #: Data Type
+    data_type: Optional["DataTypeIEC61360"]
+
+    #: Definition in different languages
+    definition: Optional[List["LangStringDefinitionTypeIEC61360"]]
+
+    #: Value Format
+    #:
+    #: .. note::
+    #:
+    #:     The value format is based on ISO 13584-42 and IEC 61360-2.
+    value_format: Optional[str]
+
+    #: List of allowed values
+    value_list: Optional["ValueList"]
+
+    #: Value
+    value: Optional[str]
+
+    #: Set of levels.
+    level_type: Optional["LevelType"]
+
+    def over_short_name_or_empty(self) -> Iterator["LangStringShortNameTypeIEC61360"]:
+        """Yield from :py:attr:`.short_name` if set."""
+        if self.short_name is not None:
+            yield from self.short_name
+
+    def over_definition_or_empty(self) -> Iterator["LangStringDefinitionTypeIEC61360"]:
+        """Yield from :py:attr:`.definition` if set."""
+        if self.definition is not None:
+            yield from self.definition
+
+    def descend_once(self) -> Iterator[Class]:
+        """
+        Iterate over the instances referenced from this instance.
+
+        We do not recurse into the referenced instance.
+
+        :yield: instances directly referenced from this instance
+        """
+        yield from self.preferred_name
+
+        if self.short_name is not None:
+            yield from self.short_name
+
+        if self.unit_id is not None:
+            yield self.unit_id
+
+        if self.definition is not None:
+            yield from self.definition
+
+        if self.value_list is not None:
+            yield self.value_list
+
+        if self.level_type is not None:
+            yield self.level_type
+
+    def descend(self) -> Iterator[Class]:
+        """
+        Iterate recursively over the instances referenced from this one.
+
+        :yield: instances recursively referenced from this instance
+        """
+        for an_item in self.preferred_name:
+            yield an_item
+
+            yield from an_item.descend()
+
+        if self.short_name is not None:
+            for another_item in self.short_name:
+                yield another_item
+
+                yield from another_item.descend()
+
+        if self.unit_id is not None:
+            yield self.unit_id
+
+            yield from self.unit_id.descend()
+
+        if self.definition is not None:
+            for yet_another_item in self.definition:
+                yield yet_another_item
+
+                yield from yet_another_item.descend()
+
+        if self.value_list is not None:
+            yield self.value_list
+
+            yield from self.value_list.descend()
+
+        if self.level_type is not None:
+            yield self.level_type
+
+            yield from self.level_type.descend()
+
+    def accept(self, visitor: "AbstractVisitor") -> None:
+        """Dispatch the :paramref:`visitor` on this instance."""
+        visitor.visit_data_specification_iec_61360(self)
+
+    def accept_with_context(
+        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
+    ) -> None:
+        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
+        visitor.visit_data_specification_iec_61360_with_context(self, context)
+
+    def transform(self, transformer: "AbstractTransformer[T]") -> T:
+        """Dispatch the :paramref:`transformer` on this instance."""
+        return transformer.transform_data_specification_iec_61360(self)
+
+    def transform_with_context(
+        self,
+        transformer: "AbstractTransformerWithContext[ContextT, T]",
+        context: ContextT,
+    ) -> T:
+        """
+        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
+        """
+        return transformer.transform_data_specification_iec_61360_with_context(
+            self, context
+        )
+
+    def __init__(
+        self,
+        preferred_name: List["LangStringPreferredNameTypeIEC61360"],
+        short_name: Optional[List["LangStringShortNameTypeIEC61360"]] = None,
+        unit: Optional[str] = None,
+        unit_id: Optional["Reference"] = None,
+        source_of_definition: Optional[str] = None,
+        symbol: Optional[str] = None,
+        data_type: Optional["DataTypeIEC61360"] = None,
+        definition: Optional[List["LangStringDefinitionTypeIEC61360"]] = None,
+        value_format: Optional[str] = None,
+        value_list: Optional["ValueList"] = None,
+        value: Optional[str] = None,
+        level_type: Optional["LevelType"] = None,
+    ) -> None:
+        """Initialize with the given values."""
+        self.preferred_name = preferred_name
+        self.short_name = short_name
+        self.unit = unit
+        self.unit_id = unit_id
+        self.source_of_definition = source_of_definition
+        self.symbol = symbol
+        self.data_type = data_type
+        self.definition = definition
+        self.value_format = value_format
+        self.value_list = value_list
+        self.value = value
+        self.level_type = level_type
+
+
+class AbstractVisitor:
+    """Visit the instances of the model."""
+
+    def visit(self, that: Class) -> None:
+        """Double-dispatch on :paramref:`that`."""
+        that.accept(self)
+
+    @abc.abstractmethod
+    def visit_extension(self, that: Extension) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_administrative_information(self, that: AdministrativeInformation) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_qualifier(self, that: Qualifier) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_asset_administration_shell(self, that: AssetAdministrationShell) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_asset_information(self, that: AssetInformation) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_resource(self, that: Resource) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_specific_asset_id(self, that: SpecificAssetID) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_submodel(self, that: Submodel) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_relationship_element(self, that: RelationshipElement) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_submodel_element_list(self, that: SubmodelElementList) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_submodel_element_collection(
+        self, that: SubmodelElementCollection
+    ) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_property(self, that: Property) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_multi_language_property(self, that: MultiLanguageProperty) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_range(self, that: Range) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_reference_element(self, that: ReferenceElement) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_blob(self, that: Blob) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_file(self, that: File) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_annotated_relationship_element(
+        self, that: AnnotatedRelationshipElement
+    ) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_entity(self, that: Entity) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_event_payload(self, that: EventPayload) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_basic_event_element(self, that: BasicEventElement) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_operation(self, that: Operation) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_operation_variable(self, that: OperationVariable) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_capability(self, that: Capability) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_concept_description(self, that: ConceptDescription) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_reference(self, that: Reference) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_key(self, that: Key) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_lang_string_name_type(self, that: LangStringNameType) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_lang_string_text_type(self, that: LangStringTextType) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_environment(self, that: Environment) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_embedded_data_specification(
+        self, that: EmbeddedDataSpecification
+    ) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_level_type(self, that: LevelType) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_value_reference_pair(self, that: ValueReferencePair) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_value_list(self, that: ValueList) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_lang_string_preferred_name_type_iec_61360(
+        self, that: LangStringPreferredNameTypeIEC61360
+    ) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_lang_string_short_name_type_iec_61360(
+        self, that: LangStringShortNameTypeIEC61360
+    ) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_lang_string_definition_type_iec_61360(
+        self, that: LangStringDefinitionTypeIEC61360
+    ) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_data_specification_iec_61360(
+        self, that: DataSpecificationIEC61360
+    ) -> None:
+        """Visit :paramref:`that`."""
+        raise NotImplementedError()
+
+
+class AbstractVisitorWithContext(Generic[ContextT]):
+    """Visit the instances of the model with context."""
+
+    def visit_with_context(self, that: Class, context: ContextT) -> None:
+        """Double-dispatch on :paramref:`that`."""
+        that.accept_with_context(self, context)
+
+    @abc.abstractmethod
+    def visit_extension_with_context(self, that: Extension, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_administrative_information_with_context(
+        self, that: AdministrativeInformation, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_qualifier_with_context(self, that: Qualifier, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_asset_administration_shell_with_context(
+        self, that: AssetAdministrationShell, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_asset_information_with_context(
+        self, that: AssetInformation, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_resource_with_context(self, that: Resource, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_specific_asset_id_with_context(
+        self, that: SpecificAssetID, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_submodel_with_context(self, that: Submodel, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_relationship_element_with_context(
+        self, that: RelationshipElement, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_submodel_element_list_with_context(
+        self, that: SubmodelElementList, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_submodel_element_collection_with_context(
+        self, that: SubmodelElementCollection, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_property_with_context(self, that: Property, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_multi_language_property_with_context(
+        self, that: MultiLanguageProperty, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_range_with_context(self, that: Range, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_reference_element_with_context(
+        self, that: ReferenceElement, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_blob_with_context(self, that: Blob, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_file_with_context(self, that: File, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_annotated_relationship_element_with_context(
+        self, that: AnnotatedRelationshipElement, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_entity_with_context(self, that: Entity, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_event_payload_with_context(
+        self, that: EventPayload, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_basic_event_element_with_context(
+        self, that: BasicEventElement, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_operation_with_context(self, that: Operation, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_operation_variable_with_context(
+        self, that: OperationVariable, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_capability_with_context(
+        self, that: Capability, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_concept_description_with_context(
+        self, that: ConceptDescription, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_reference_with_context(self, that: Reference, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_key_with_context(self, that: Key, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_lang_string_name_type_with_context(
+        self, that: LangStringNameType, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_lang_string_text_type_with_context(
+        self, that: LangStringTextType, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_environment_with_context(
+        self, that: Environment, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_embedded_data_specification_with_context(
+        self, that: EmbeddedDataSpecification, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_level_type_with_context(self, that: LevelType, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_value_reference_pair_with_context(
+        self, that: ValueReferencePair, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_value_list_with_context(self, that: ValueList, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_lang_string_preferred_name_type_iec_61360_with_context(
+        self, that: LangStringPreferredNameTypeIEC61360, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_lang_string_short_name_type_iec_61360_with_context(
+        self, that: LangStringShortNameTypeIEC61360, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_lang_string_definition_type_iec_61360_with_context(
+        self, that: LangStringDefinitionTypeIEC61360, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def visit_data_specification_iec_61360_with_context(
+        self, that: DataSpecificationIEC61360, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+
+class PassThroughVisitor(AbstractVisitor):
+    """
+    Visit the instances of the model without action.
+
+    This visitor is not meant to be directly used. Instead, you usually
+    inherit from it, and implement only the relevant visit methods.
+    """
+
+    def visit(self, that: Class) -> None:
+        """Double-dispatch on :paramref:`that`."""
+        that.accept(self)
+
+    def visit_extension(self, that: Extension) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_administrative_information(self, that: AdministrativeInformation) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_qualifier(self, that: Qualifier) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_asset_administration_shell(self, that: AssetAdministrationShell) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_asset_information(self, that: AssetInformation) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_resource(self, that: Resource) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_specific_asset_id(self, that: SpecificAssetID) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_submodel(self, that: Submodel) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_relationship_element(self, that: RelationshipElement) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_submodel_element_list(self, that: SubmodelElementList) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_submodel_element_collection(
+        self, that: SubmodelElementCollection
+    ) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_property(self, that: Property) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_multi_language_property(self, that: MultiLanguageProperty) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_range(self, that: Range) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_reference_element(self, that: ReferenceElement) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_blob(self, that: Blob) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_file(self, that: File) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_annotated_relationship_element(
+        self, that: AnnotatedRelationshipElement
+    ) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_entity(self, that: Entity) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_event_payload(self, that: EventPayload) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_basic_event_element(self, that: BasicEventElement) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_operation(self, that: Operation) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_operation_variable(self, that: OperationVariable) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_capability(self, that: Capability) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_concept_description(self, that: ConceptDescription) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_reference(self, that: Reference) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_key(self, that: Key) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_lang_string_name_type(self, that: LangStringNameType) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_lang_string_text_type(self, that: LangStringTextType) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_environment(self, that: Environment) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_embedded_data_specification(
+        self, that: EmbeddedDataSpecification
+    ) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_level_type(self, that: LevelType) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_value_reference_pair(self, that: ValueReferencePair) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_value_list(self, that: ValueList) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_lang_string_preferred_name_type_iec_61360(
+        self, that: LangStringPreferredNameTypeIEC61360
+    ) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_lang_string_short_name_type_iec_61360(
+        self, that: LangStringShortNameTypeIEC61360
+    ) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_lang_string_definition_type_iec_61360(
+        self, that: LangStringDefinitionTypeIEC61360
+    ) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+    def visit_data_specification_iec_61360(
+        self, that: DataSpecificationIEC61360
+    ) -> None:
+        """Visit :paramref:`that`."""
+        for another in that.descend_once():
+            self.visit(another)
+
+
+class PassThroughVisitorWithContext(AbstractVisitorWithContext[ContextT]):
+    """
+    Visit the instances of the model without action and in context.
+
+    This visitor is not meant to be directly used. Instead, you usually
+    inherit from it, and implement only the relevant visit methods.
+    """
+
+    def visit_with_context(self, that: Class, context: ContextT) -> None:
+        """Double-dispatch on :paramref:`that`."""
+        that.accept_with_context(self, context)
+
+    def visit_extension_with_context(self, that: Extension, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_administrative_information_with_context(
+        self, that: AdministrativeInformation, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_qualifier_with_context(self, that: Qualifier, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_asset_administration_shell_with_context(
+        self, that: AssetAdministrationShell, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_asset_information_with_context(
+        self, that: AssetInformation, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_resource_with_context(self, that: Resource, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_specific_asset_id_with_context(
+        self, that: SpecificAssetID, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_submodel_with_context(self, that: Submodel, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_relationship_element_with_context(
+        self, that: RelationshipElement, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_submodel_element_list_with_context(
+        self, that: SubmodelElementList, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_submodel_element_collection_with_context(
+        self, that: SubmodelElementCollection, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_property_with_context(self, that: Property, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_multi_language_property_with_context(
+        self, that: MultiLanguageProperty, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_range_with_context(self, that: Range, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_reference_element_with_context(
+        self, that: ReferenceElement, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_blob_with_context(self, that: Blob, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_file_with_context(self, that: File, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_annotated_relationship_element_with_context(
+        self, that: AnnotatedRelationshipElement, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_entity_with_context(self, that: Entity, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_event_payload_with_context(
+        self, that: EventPayload, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_basic_event_element_with_context(
+        self, that: BasicEventElement, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_operation_with_context(self, that: Operation, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_operation_variable_with_context(
+        self, that: OperationVariable, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_capability_with_context(
+        self, that: Capability, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_concept_description_with_context(
+        self, that: ConceptDescription, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_reference_with_context(self, that: Reference, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_key_with_context(self, that: Key, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_lang_string_name_type_with_context(
+        self, that: LangStringNameType, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_lang_string_text_type_with_context(
+        self, that: LangStringTextType, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_environment_with_context(
+        self, that: Environment, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_embedded_data_specification_with_context(
+        self, that: EmbeddedDataSpecification, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_level_type_with_context(self, that: LevelType, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_value_reference_pair_with_context(
+        self, that: ValueReferencePair, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_value_list_with_context(self, that: ValueList, context: ContextT) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_lang_string_preferred_name_type_iec_61360_with_context(
+        self, that: LangStringPreferredNameTypeIEC61360, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_lang_string_short_name_type_iec_61360_with_context(
+        self, that: LangStringShortNameTypeIEC61360, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_lang_string_definition_type_iec_61360_with_context(
+        self, that: LangStringDefinitionTypeIEC61360, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+    def visit_data_specification_iec_61360_with_context(
+        self, that: DataSpecificationIEC61360, context: ContextT
+    ) -> None:
+        """Visit :paramref:`that` in :paramref:`context`."""
+        for another in that.descend_once():
+            self.visit_with_context(another, context)
+
+
+class AbstractTransformer(Generic[T]):
+    """Transform the instances of the model."""
+
+    def transform(self, that: Class) -> T:
+        """Double-dispatch on :paramref:`that`."""
+        return that.transform(self)
+
+    @abc.abstractmethod
+    def transform_extension(self, that: Extension) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_administrative_information(
+        self, that: AdministrativeInformation
+    ) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_qualifier(self, that: Qualifier) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_asset_administration_shell(self, that: AssetAdministrationShell) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_asset_information(self, that: AssetInformation) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_resource(self, that: Resource) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_specific_asset_id(self, that: SpecificAssetID) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_submodel(self, that: Submodel) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_relationship_element(self, that: RelationshipElement) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_submodel_element_list(self, that: SubmodelElementList) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_submodel_element_collection(
+        self, that: SubmodelElementCollection
+    ) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_property(self, that: Property) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_multi_language_property(self, that: MultiLanguageProperty) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_range(self, that: Range) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_reference_element(self, that: ReferenceElement) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_blob(self, that: Blob) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_file(self, that: File) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_annotated_relationship_element(
+        self, that: AnnotatedRelationshipElement
+    ) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_entity(self, that: Entity) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_event_payload(self, that: EventPayload) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_basic_event_element(self, that: BasicEventElement) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_operation(self, that: Operation) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_operation_variable(self, that: OperationVariable) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_capability(self, that: Capability) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_concept_description(self, that: ConceptDescription) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_reference(self, that: Reference) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_key(self, that: Key) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_lang_string_name_type(self, that: LangStringNameType) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_lang_string_text_type(self, that: LangStringTextType) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_environment(self, that: Environment) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_embedded_data_specification(
+        self, that: EmbeddedDataSpecification
+    ) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_level_type(self, that: LevelType) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_value_reference_pair(self, that: ValueReferencePair) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_value_list(self, that: ValueList) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_lang_string_preferred_name_type_iec_61360(
+        self, that: LangStringPreferredNameTypeIEC61360
+    ) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_lang_string_short_name_type_iec_61360(
+        self, that: LangStringShortNameTypeIEC61360
+    ) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_lang_string_definition_type_iec_61360(
+        self, that: LangStringDefinitionTypeIEC61360
+    ) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_data_specification_iec_61360(
+        self, that: DataSpecificationIEC61360
+    ) -> T:
+        """Transform :paramref:`that`."""
+        raise NotImplementedError()
+
+
+class AbstractTransformerWithContext(Generic[ContextT, T]):
+    """Transform the instances of the model in context."""
+
+    def transform_with_context(self, that: Class, context: ContextT) -> T:
+        """Double-dispatch on :paramref:`that`."""
+        return that.transform_with_context(self, context)
+
+    @abc.abstractmethod
+    def transform_extension_with_context(self, that: Extension, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_administrative_information_with_context(
+        self, that: AdministrativeInformation, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_qualifier_with_context(self, that: Qualifier, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_asset_administration_shell_with_context(
+        self, that: AssetAdministrationShell, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_asset_information_with_context(
+        self, that: AssetInformation, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_resource_with_context(self, that: Resource, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_specific_asset_id_with_context(
+        self, that: SpecificAssetID, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_submodel_with_context(self, that: Submodel, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_relationship_element_with_context(
+        self, that: RelationshipElement, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_submodel_element_list_with_context(
+        self, that: SubmodelElementList, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_submodel_element_collection_with_context(
+        self, that: SubmodelElementCollection, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_property_with_context(self, that: Property, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_multi_language_property_with_context(
+        self, that: MultiLanguageProperty, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_range_with_context(self, that: Range, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_reference_element_with_context(
+        self, that: ReferenceElement, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_blob_with_context(self, that: Blob, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_file_with_context(self, that: File, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_annotated_relationship_element_with_context(
+        self, that: AnnotatedRelationshipElement, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_entity_with_context(self, that: Entity, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_event_payload_with_context(
+        self, that: EventPayload, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_basic_event_element_with_context(
+        self, that: BasicEventElement, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_operation_with_context(self, that: Operation, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_operation_variable_with_context(
+        self, that: OperationVariable, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_capability_with_context(
+        self, that: Capability, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_concept_description_with_context(
+        self, that: ConceptDescription, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_reference_with_context(self, that: Reference, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_key_with_context(self, that: Key, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_lang_string_name_type_with_context(
+        self, that: LangStringNameType, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_lang_string_text_type_with_context(
+        self, that: LangStringTextType, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_environment_with_context(
+        self, that: Environment, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_embedded_data_specification_with_context(
+        self, that: EmbeddedDataSpecification, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_level_type_with_context(
+        self, that: LevelType, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_value_reference_pair_with_context(
+        self, that: ValueReferencePair, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_value_list_with_context(
+        self, that: ValueList, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_lang_string_preferred_name_type_iec_61360_with_context(
+        self, that: LangStringPreferredNameTypeIEC61360, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_lang_string_short_name_type_iec_61360_with_context(
+        self, that: LangStringShortNameTypeIEC61360, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_lang_string_definition_type_iec_61360_with_context(
+        self, that: LangStringDefinitionTypeIEC61360, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+    @abc.abstractmethod
+    def transform_data_specification_iec_61360_with_context(
+        self, that: DataSpecificationIEC61360, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        raise NotImplementedError()
+
+
+class TransformerWithDefault(AbstractTransformer[T]):
+    """
+    Transform the instances of the model.
+
+    If you do not override the transformation methods, they simply
+    return :py:attr:`.default`.
+    """
+
+    #: Default value which is returned if no override of the transformation
+    default: T
+
+    def __init__(self, default: T) -> None:
+        """Initialize with the given :paramref:`default` value."""
+        self.default = default
+
+    def transform(self, that: Class) -> T:
+        """Double-dispatch on :paramref:`that`."""
+        return that.transform(self)
+
+    def transform_extension(self, that: Extension) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_administrative_information(
+        self, that: AdministrativeInformation
+    ) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_qualifier(self, that: Qualifier) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_asset_administration_shell(self, that: AssetAdministrationShell) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_asset_information(self, that: AssetInformation) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_resource(self, that: Resource) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_specific_asset_id(self, that: SpecificAssetID) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_submodel(self, that: Submodel) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_relationship_element(self, that: RelationshipElement) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_submodel_element_list(self, that: SubmodelElementList) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_submodel_element_collection(
+        self, that: SubmodelElementCollection
+    ) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_property(self, that: Property) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_multi_language_property(self, that: MultiLanguageProperty) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_range(self, that: Range) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_reference_element(self, that: ReferenceElement) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_blob(self, that: Blob) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_file(self, that: File) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_annotated_relationship_element(
+        self, that: AnnotatedRelationshipElement
+    ) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_entity(self, that: Entity) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_event_payload(self, that: EventPayload) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_basic_event_element(self, that: BasicEventElement) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_operation(self, that: Operation) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_operation_variable(self, that: OperationVariable) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_capability(self, that: Capability) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_concept_description(self, that: ConceptDescription) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_reference(self, that: Reference) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_key(self, that: Key) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_lang_string_name_type(self, that: LangStringNameType) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_lang_string_text_type(self, that: LangStringTextType) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_environment(self, that: Environment) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_embedded_data_specification(
+        self, that: EmbeddedDataSpecification
+    ) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_level_type(self, that: LevelType) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_value_reference_pair(self, that: ValueReferencePair) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_value_list(self, that: ValueList) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_lang_string_preferred_name_type_iec_61360(
+        self, that: LangStringPreferredNameTypeIEC61360
+    ) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_lang_string_short_name_type_iec_61360(
+        self, that: LangStringShortNameTypeIEC61360
+    ) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_lang_string_definition_type_iec_61360(
+        self, that: LangStringDefinitionTypeIEC61360
+    ) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+    def transform_data_specification_iec_61360(
+        self, that: DataSpecificationIEC61360
+    ) -> T:
+        """Transform :paramref:`that`."""
+        return self.default
+
+
+class TransformerWithDefaultAndContext(AbstractTransformerWithContext[ContextT, T]):
+    """
+    Transform the instances of the model in context.
+
+    If you do not override the transformation methods, they simply
+    return :py:attr:`.default`.
+    """
+
+    #: Default value which is returned if no override of the transformation
+    default: T
+
+    def __init__(self, default: T) -> None:
+        """Initialize with the given :paramref:`default` value."""
+        self.default = default
+
+    def transform_with_context(self, that: Class, context: ContextT) -> T:
+        """Double-dispatch on :paramref:`that`."""
+        return that.transform_with_context(self, context)
+
+    def transform_extension_with_context(self, that: Extension, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_administrative_information_with_context(
+        self, that: AdministrativeInformation, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_qualifier_with_context(self, that: Qualifier, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_asset_administration_shell_with_context(
+        self, that: AssetAdministrationShell, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_asset_information_with_context(
+        self, that: AssetInformation, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_resource_with_context(self, that: Resource, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_specific_asset_id_with_context(
+        self, that: SpecificAssetID, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_submodel_with_context(self, that: Submodel, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_relationship_element_with_context(
+        self, that: RelationshipElement, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_submodel_element_list_with_context(
+        self, that: SubmodelElementList, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_submodel_element_collection_with_context(
+        self, that: SubmodelElementCollection, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_property_with_context(self, that: Property, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_multi_language_property_with_context(
+        self, that: MultiLanguageProperty, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_range_with_context(self, that: Range, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_reference_element_with_context(
+        self, that: ReferenceElement, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_blob_with_context(self, that: Blob, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_file_with_context(self, that: File, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_annotated_relationship_element_with_context(
+        self, that: AnnotatedRelationshipElement, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_entity_with_context(self, that: Entity, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_event_payload_with_context(
+        self, that: EventPayload, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_basic_event_element_with_context(
+        self, that: BasicEventElement, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_operation_with_context(self, that: Operation, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_operation_variable_with_context(
+        self, that: OperationVariable, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_capability_with_context(
+        self, that: Capability, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_concept_description_with_context(
+        self, that: ConceptDescription, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_reference_with_context(self, that: Reference, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_key_with_context(self, that: Key, context: ContextT) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_lang_string_name_type_with_context(
+        self, that: LangStringNameType, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_lang_string_text_type_with_context(
+        self, that: LangStringTextType, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_environment_with_context(
+        self, that: Environment, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_embedded_data_specification_with_context(
+        self, that: EmbeddedDataSpecification, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_level_type_with_context(
+        self, that: LevelType, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_value_reference_pair_with_context(
+        self, that: ValueReferencePair, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_value_list_with_context(
+        self, that: ValueList, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_lang_string_preferred_name_type_iec_61360_with_context(
+        self, that: LangStringPreferredNameTypeIEC61360, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_lang_string_short_name_type_iec_61360_with_context(
+        self, that: LangStringShortNameTypeIEC61360, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_lang_string_definition_type_iec_61360_with_context(
+        self, that: LangStringDefinitionTypeIEC61360, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+    def transform_data_specification_iec_61360_with_context(
+        self, that: DataSpecificationIEC61360, context: ContextT
+    ) -> T:
+        """Transform :paramref:`that` in :paramref:`context`."""
+        return self.default
+
+
+# This code has been automatically generated by aas-core-codegen.
+# Do NOT edit or append.
```

### Comparing `aas-core3.0-1.0.0rc1/aas_core3/verification.py` & `aas-core3.0-1.0.0rc2/aas_core3/verification.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,6134 +1,6094 @@
-"""
-Verify that the instances of the meta-model satisfy the invariants.
-
-Here is an example how to verify an instance of :py:class:`aas_core3.types.Extension`:
-
-.. code-block::
-
-    import aas_core3.types as aas_types
-    import aas_core3.verification as aas_verification
-
-    an_instance = aas_types.Extension(
-        # ... some constructor arguments ...
-    )
-
-    for error in aas_verification.verify(an_instance):
-        print(f"{error.cause} at: {error.path}")
-"""
-
-
-# This code has been automatically generated by aas-core-codegen.
-# Do NOT edit or append.
-
-
-import math
-import re
-import struct
-import sys
-from typing import (
-    Callable,
-    Iterable,
-    Iterator,
-    List,
-    Mapping,
-    Optional,
-    Pattern,
-    Sequence,
-    Set,
-    Union,
-)
-
-if sys.version_info >= (3, 8):
-    from typing import Final
-else:
-    from typing_extensions import Final
-
-from aas_core3 import (
-    constants as aas_constants,
-    types as aas_types,
-)
-
-
-class PropertySegment:
-    """Represent a property access on a path to an erroneous value."""
-
-    #: Instance containing the property
-    instance: Final[aas_types.Class]
-
-    #: Name of the property
-    name: Final[str]
-
-    def __init__(self, instance: aas_types.Class, name: str) -> None:
-        """Initialize with the given values."""
-        self.instance = instance
-        self.name = name
-
-    def __str__(self) -> str:
-        return f".{self.name}"
-
-
-class IndexSegment:
-    """Represent an index access on a path to an erroneous value."""
-
-    #: Sequence containing the item at :py:attr:`~index`
-    sequence: Final[Sequence[aas_types.Class]]
-
-    #: Index of the item
-    index: Final[int]
-
-    def __init__(self, sequence: Sequence[aas_types.Class], index: int) -> None:
-        """Initialize with the given values."""
-        self.sequence = sequence
-        self.index = index
-
-    def __str__(self) -> str:
-        return f"[{self.index}]"
-
-
-Segment = Union[PropertySegment, IndexSegment]
-
-
-class Path:
-    """Represent the relative path to the erroneous value."""
-
-    def __init__(self) -> None:
-        """Initialize as an empty path."""
-        self._segments = []  # type: List[Segment]
-
-    @property
-    def segments(self) -> Sequence[Segment]:
-        """Get the segments of the path."""
-        return self._segments
-
-    def _prepend(self, segment: Segment) -> None:
-        """Insert the :paramref:`segment` in front of other segments."""
-        self._segments.insert(0, segment)
-
-    def __str__(self) -> str:
-        return "".join(str(segment) for segment in self._segments)
-
-
-class Error:
-    """Represent a verification error in the data."""
-
-    #: Human-readable description of the error
-    cause: Final[str]
-
-    #: Path to the erroneous value
-    path: Final[Path]
-
-    def __init__(self, cause: str) -> None:
-        """Initialize as an error with an empty path."""
-        self.cause = cause
-        self.path = Path()
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_id_short() -> Pattern[str]:
-    pattern = "^[a-zA-Z][a-zA-Z0-9_]*$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_ID_SHORT = _construct_matches_id_short()
-
-
-def matches_id_short(text: str) -> bool:
-    """Check that :paramref:`text` is a valid short ID."""
-    return _REGEX_MATCHES_ID_SHORT.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_version_type() -> Pattern[str]:
-    pattern = "^(0|[1-9][0-9]*)$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_VERSION_TYPE = _construct_matches_version_type()
-
-
-def matches_version_type(text: str) -> bool:
-    """Check that :paramref:`text` is a valid version string."""
-    return _REGEX_MATCHES_VERSION_TYPE.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_revision_type() -> Pattern[str]:
-    pattern = "^(0|[1-9][0-9]*)$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_REVISION_TYPE = _construct_matches_revision_type()
-
-
-def matches_revision_type(text: str) -> bool:
-    """Check that :paramref:`text` is a valid revision string."""
-    return _REGEX_MATCHES_REVISION_TYPE.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_date_time_utc() -> Pattern[str]:
-    digit = "[0-9]"
-    year_frag = f"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))"
-    month_frag = "((0[1-9])|(1[0-2]))"
-    day_frag = f"((0[1-9])|([12]{digit})|(3[01]))"
-    hour_frag = f"(([01]{digit})|(2[0-3]))"
-    minute_frag = f"[0-5]{digit}"
-    second_frag = f"([0-5]{digit})(\\.{digit}+)?"
-    end_of_day_frag = "24:00:00(\\.0+)?"
-    timezone_frag = "(Z|\\+00:00|-00:00)"
-    date_time_lexical_rep = f"{year_frag}-{month_frag}-{day_frag}T(({hour_frag}:{minute_frag}:{second_frag})|{end_of_day_frag}){timezone_frag}"
-    pattern = f"^{date_time_lexical_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_DATE_TIME_UTC = _construct_matches_xs_date_time_utc()
-
-
-def matches_xs_date_time_utc(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:dateTime``.
-
-    The time zone must be fixed to UTC. We verify only that the ``text`` matches
-    a pre-defined pattern. We *do not* verify that the day of month is
-    correct nor do we check for leap seconds.
-
-    See: https://www.w3.org/TR/xmlschema-2/#dateTime
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_DATE_TIME_UTC.match(text) is not None
-
-
-def is_xs_date_time_utc(value: str) -> bool:
-    """
-    Check that :paramref:`value` is a ``xs:dateTime`` with
-    the time zone set to UTC.
-    """
-    if not matches_xs_date_time_utc(value):
-        return False
-
-    date, _ = value.split("T")
-    return is_xs_date(date)
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_mime_type() -> Pattern[str]:
-    tchar = "[!#$%&'*+\\-.^_`|~0-9a-zA-Z]"
-    token = f"({tchar})+"
-    type = f"{token}"
-    subtype = f"{token}"
-    ows = "[ \\t]*"
-    obs_text = "[\\x80-\\xff]"
-    qd_text = f"([\\t !#-\\[\\]-~]|{obs_text})"
-    quoted_pair = f"\\\\([\\t !-~]|{obs_text})"
-    quoted_string = f'"({qd_text}|{quoted_pair})*"'
-    parameter = f"{token}=({token}|{quoted_string})"
-    media_type = f"^{type}/{subtype}({ows};{ows}{parameter})*$"
-
-    return re.compile(media_type)
-
-
-_REGEX_MATCHES_MIME_TYPE = _construct_matches_mime_type()
-
-
-def matches_mime_type(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of MIME type.
-
-    The definition has been taken from:
-    https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1,
-    https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3 and
-    https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6.
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_MIME_TYPE.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_rfc_8089_path() -> Pattern[str]:
-    h16 = "[0-9A-Fa-f]{1,4}"
-    dec_octet = "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
-    ipv4address = f"{dec_octet}\\.{dec_octet}\\.{dec_octet}\\.{dec_octet}"
-    ls32 = f"({h16}:{h16}|{ipv4address})"
-    ipv6address = f"(({h16}:){{6}}{ls32}|::({h16}:){{5}}{ls32}|({h16})?::({h16}:){{4}}{ls32}|(({h16}:)?{h16})?::({h16}:){{3}}{ls32}|(({h16}:){{2}}{h16})?::({h16}:){{2}}{ls32}|(({h16}:){{3}}{h16})?::{h16}:{ls32}|(({h16}:){{4}}{h16})?::{ls32}|(({h16}:){{5}}{h16})?::{h16}|(({h16}:){{6}}{h16})?::)"
-    unreserved = "[a-zA-Z0-9\\-._~]"
-    sub_delims = "[!$&'()*+,;=]"
-    ipvfuture = f"[vV][0-9A-Fa-f]+\\.({unreserved}|{sub_delims}|:)+"
-    ip_literal = f"\\[({ipv6address}|{ipvfuture})\\]"
-    pct_encoded = "%[0-9A-Fa-f][0-9A-Fa-f]"
-    reg_name = f"({unreserved}|{pct_encoded}|{sub_delims})*"
-    host = f"({ip_literal}|{ipv4address}|{reg_name})"
-    file_auth = f"(localhost|{host})"
-    pchar = f"({unreserved}|{pct_encoded}|{sub_delims}|[:@])"
-    segment_nz = f"({pchar})+"
-    segment = f"({pchar})*"
-    path_absolute = f"/({segment_nz}(/{segment})*)?"
-    auth_path = f"({file_auth})?{path_absolute}"
-    local_path = f"{path_absolute}"
-    file_hier_part = f"(//{auth_path}|{local_path})"
-    file_scheme = "file"
-    file_uri = f"{file_scheme}:{file_hier_part}"
-    pattern = f"^{file_uri}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_RFC_8089_PATH = _construct_matches_rfc_8089_path()
-
-
-def matches_rfc_8089_path(text: str) -> bool:
-    """
-    Check that :paramref:`text` is a path conforming to the pattern of RFC 8089.
-
-    The definition has been taken from:
-    https://datatracker.ietf.org/doc/html/rfc8089
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_RFC_8089_PATH.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_bcp_47() -> Pattern[str]:
-    alphanum = "[a-zA-Z0-9]"
-    singleton = "[0-9A-WY-Za-wy-z]"
-    extension = f"{singleton}(-({alphanum}){{2,8}})+"
-    extlang = "[a-zA-Z]{3}(-[a-zA-Z]{3}){2}"
-    irregular = "(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)"
-    regular = "(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)"
-    grandfathered = f"({irregular}|{regular})"
-    language = f"([a-zA-Z]{{2,3}}(-{extlang})?|[a-zA-Z]{{4}}|[a-zA-Z]{{5,8}})"
-    script = "[a-zA-Z]{4}"
-    region = "([a-zA-Z]{2}|[0-9]{3})"
-    variant = f"(({alphanum}){{5,8}}|[0-9]({alphanum}){{3}})"
-    privateuse = f"[xX](-({alphanum}){{1,8}})+"
-    langtag = f"{language}(-{script})?(-{region})?(-{variant})*(-{extension})*(-{privateuse})?"
-    language_tag = f"({langtag}|{privateuse}|{grandfathered})"
-    pattern = f"^{language_tag}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_BCP_47 = _construct_matches_bcp_47()
-
-
-def matches_bcp_47(text: str) -> bool:
-    """
-    Check that :paramref:`text` is a valid BCP 47 language tag.
-
-    See: https://en.wikipedia.org/wiki/IETF_language_tag
-    """
-    return _REGEX_MATCHES_BCP_47.match(text) is not None
-
-
-def lang_strings_have_unique_languages(
-    lang_strings: Iterable[aas_types.AbstractLangString],
-) -> bool:
-    """
-    Check that :paramref:`lang_strings` are specified each for a unique
-    language.
-    """
-    language_set = set()  # type: Set[str]
-    for lang_string in lang_strings:
-        if lang_string.language in language_set:
-            return False
-
-        language_set.add(lang_string.language)
-
-    return True
-
-
-def qualifier_types_are_unique(qualifiers: Iterable[aas_types.Qualifier]) -> bool:
-    """
-    Check that there are no duplicate
-    :py:attr:`.types.Qualifier.type`'s
-    in the :paramref:`qualifiers`.
-    """
-    type_set = set()  # type: Set[str]
-    for qualifier in qualifiers:
-        if qualifier.type in type_set:
-            return False
-
-        type_set.add(qualifier.type)
-
-    return True
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xml_serializable_string() -> Pattern[str]:
-    pattern = "^[\\x09\\x0a\\x0d\\x20-\\ud7ff\\ue000-\\ufffd\\U00010000-\\U0010ffff]*$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XML_SERIALIZABLE_STRING = _construct_matches_xml_serializable_string()
-
-
-def matches_xml_serializable_string(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of the Constraint AASd-130.
-
-    Ensures that encoding is possible and interoperability between different
-    serializations is possible.
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XML_SERIALIZABLE_STRING.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_any_uri() -> Pattern[str]:
-    scheme = "[a-zA-Z][a-zA-Z0-9+\\-.]*"
-    ucschar = "[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd]"
-    iunreserved = f"([a-zA-Z0-9\\-._~]|{ucschar})"
-    pct_encoded = "%[0-9A-Fa-f][0-9A-Fa-f]"
-    sub_delims = "[!$&'()*+,;=]"
-    iuserinfo = f"({iunreserved}|{pct_encoded}|{sub_delims}|:)*"
-    h16 = "[0-9A-Fa-f]{1,4}"
-    dec_octet = "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
-    ipv4address = f"{dec_octet}\\.{dec_octet}\\.{dec_octet}\\.{dec_octet}"
-    ls32 = f"({h16}:{h16}|{ipv4address})"
-    ipv6address = f"(({h16}:){{6}}{ls32}|::({h16}:){{5}}{ls32}|({h16})?::({h16}:){{4}}{ls32}|(({h16}:)?{h16})?::({h16}:){{3}}{ls32}|(({h16}:){{2}}{h16})?::({h16}:){{2}}{ls32}|(({h16}:){{3}}{h16})?::{h16}:{ls32}|(({h16}:){{4}}{h16})?::{ls32}|(({h16}:){{5}}{h16})?::{h16}|(({h16}:){{6}}{h16})?::)"
-    unreserved = "[a-zA-Z0-9\\-._~]"
-    ipvfuture = f"[vV][0-9A-Fa-f]+\\.({unreserved}|{sub_delims}|:)+"
-    ip_literal = f"\\[({ipv6address}|{ipvfuture})\\]"
-    ireg_name = f"({iunreserved}|{pct_encoded}|{sub_delims})*"
-    ihost = f"({ip_literal}|{ipv4address}|{ireg_name})"
-    port = "[0-9]*"
-    iauthority = f"({iuserinfo}@)?{ihost}(:{port})?"
-    ipchar = f"({iunreserved}|{pct_encoded}|{sub_delims}|[:@])"
-    isegment = f"({ipchar})*"
-    ipath_abempty = f"(/{isegment})*"
-    isegment_nz = f"({ipchar})+"
-    ipath_absolute = f"/({isegment_nz}(/{isegment})*)?"
-    ipath_rootless = f"{isegment_nz}(/{isegment})*"
-    ipath_empty = f"({ipchar}){{0}}"
-    ihier_part = f"(//{iauthority}{ipath_abempty}|{ipath_absolute}|{ipath_rootless}|{ipath_empty})"
-    iprivate = "[\\ue000-\\uf8ff\\U000f0000-\\U000ffffd\\U00100000-\\U0010fffd]"
-    iquery = f"({ipchar}|{iprivate}|[/?])*"
-    ifragment = f"({ipchar}|[/?])*"
-    isegment_nz_nc = f"({iunreserved}|{pct_encoded}|{sub_delims}|@)+"
-    ipath_noscheme = f"{isegment_nz_nc}(/{isegment})*"
-    irelative_part = f"(//{iauthority}{ipath_abempty}|{ipath_absolute}|{ipath_noscheme}|{ipath_empty})"
-    irelative_ref = f"{irelative_part}(\\?{iquery})?(#{ifragment})?"
-    iri = f"{scheme}:{ihier_part}(\\?{iquery})?(#{ifragment})?"
-    iri_reference = f"({iri}|{irelative_ref})"
-    pattern = f"^{iri_reference}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_ANY_URI = _construct_matches_xs_any_uri()
-
-
-def matches_xs_any_uri(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:anyURI``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#anyURI and
-    https://datatracker.ietf.org/doc/html/rfc3987
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_ANY_URI.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_base_64_binary() -> Pattern[str]:
-    b04_char = "[AQgw]"
-    b04 = f"{b04_char}\\x20?"
-    b16_char = "[AEIMQUYcgkosw048]"
-    b16 = f"{b16_char}\\x20?"
-    b64_char = "[A-Za-z0-9+/]"
-    b64 = f"{b64_char}\\x20?"
-    b64quad = f"({b64}{b64}{b64}{b64})"
-    b64_final_quad = f"({b64}{b64}{b64}{b64_char})"
-    padded_8 = f"{b64}{b04}= ?="
-    padded_16 = f"{b64}{b64}{b16}="
-    b64final = f"({b64_final_quad}|{padded_16}|{padded_8})"
-    base64_binary = f"({b64quad}*{b64final})?"
-    pattern = f"^{base64_binary}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_BASE_64_BINARY = _construct_matches_xs_base_64_binary()
-
-
-def matches_xs_base_64_binary(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:base64Binary``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#base64Binary
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_BASE_64_BINARY.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_boolean() -> Pattern[str]:
-    pattern = "^(true|false|1|0)$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_BOOLEAN = _construct_matches_xs_boolean()
-
-
-def matches_xs_boolean(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:boolean``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#boolean
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_BOOLEAN.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_date() -> Pattern[str]:
-    digit = "[0-9]"
-    year_frag = f"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))"
-    month_frag = "((0[1-9])|(1[0-2]))"
-    day_frag = f"((0[1-9])|([12]{digit})|(3[01]))"
-    minute_frag = f"[0-5]{digit}"
-    timezone_frag = f"(Z|(\\+|-)(0{digit}|1[0-3]):{minute_frag}|14:00)"
-    date_lexical_rep = f"{year_frag}-{month_frag}-{day_frag}{timezone_frag}?"
-    pattern = f"^{date_lexical_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_DATE = _construct_matches_xs_date()
-
-
-def matches_xs_date(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:date``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#date
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_DATE.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_date_time() -> Pattern[str]:
-    digit = "[0-9]"
-    year_frag = f"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))"
-    month_frag = "((0[1-9])|(1[0-2]))"
-    day_frag = f"((0[1-9])|([12]{digit})|(3[01]))"
-    hour_frag = f"(([01]{digit})|(2[0-3]))"
-    minute_frag = f"[0-5]{digit}"
-    second_frag = f"([0-5]{digit})(\\.{digit}+)?"
-    end_of_day_frag = "24:00:00(\\.0+)?"
-    timezone_frag = f"(Z|(\\+|-)(0{digit}|1[0-3]):{minute_frag}|14:00)"
-    date_time_lexical_rep = f"{year_frag}-{month_frag}-{day_frag}T(({hour_frag}:{minute_frag}:{second_frag})|{end_of_day_frag}){timezone_frag}?"
-    pattern = f"^{date_time_lexical_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_DATE_TIME = _construct_matches_xs_date_time()
-
-
-def matches_xs_date_time(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:dateTime``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#dateTime
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_DATE_TIME.match(text) is not None
-
-
-def is_xs_date_time(value: str) -> bool:
-    """
-    Check that :paramref:`value` is a ``xs:dateTime`` with
-    the time zone set to UTC.
-    """
-    if not matches_xs_date_time(value):
-        return False
-
-    date, _ = value.split("T")
-    return is_xs_date(date)
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_decimal() -> Pattern[str]:
-    digit = "[0-9]"
-    unsigned_no_decimal_pt_numeral = f"{digit}+"
-    no_decimal_pt_numeral = f"(\\+|-)?{unsigned_no_decimal_pt_numeral}"
-    frac_frag = f"{digit}+"
-    unsigned_decimal_pt_numeral = (
-        f"({unsigned_no_decimal_pt_numeral}\\.{frac_frag}|\\.{frac_frag})"
-    )
-    decimal_pt_numeral = f"(\\+|-)?{unsigned_decimal_pt_numeral}"
-    decimal_lexical_rep = f"({decimal_pt_numeral}|{no_decimal_pt_numeral})"
-    pattern = f"^{decimal_lexical_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_DECIMAL = _construct_matches_xs_decimal()
-
-
-def matches_xs_decimal(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:decimal``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#decimal
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_DECIMAL.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_double() -> Pattern[str]:
-    double_rep = (
-        "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)"
-    )
-    pattern = f"^{double_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_DOUBLE = _construct_matches_xs_double()
-
-
-def matches_xs_double(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:double``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#double
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_DOUBLE.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_duration() -> Pattern[str]:
-    duration_rep = "-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))"
-    pattern = f"^{duration_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_DURATION = _construct_matches_xs_duration()
-
-
-def matches_xs_duration(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:duration``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#duration
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_DURATION.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_float() -> Pattern[str]:
-    float_rep = (
-        "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)"
-    )
-    pattern = f"^{float_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_FLOAT = _construct_matches_xs_float()
-
-
-def matches_xs_float(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:float``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#float
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_FLOAT.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_g_day() -> Pattern[str]:
-    g_day_lexical_rep = (
-        "---(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
-    )
-    pattern = f"^{g_day_lexical_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_G_DAY = _construct_matches_xs_g_day()
-
-
-def matches_xs_g_day(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:gDay``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#gDay
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_G_DAY.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_g_month() -> Pattern[str]:
-    g_month_lexical_rep = (
-        "--(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
-    )
-    pattern = f"^{g_month_lexical_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_G_MONTH = _construct_matches_xs_g_month()
-
-
-def matches_xs_g_month(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:gMonth``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#gMonth
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_G_MONTH.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_g_month_day() -> Pattern[str]:
-    g_month_day_rep = "--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
-    pattern = f"^{g_month_day_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_G_MONTH_DAY = _construct_matches_xs_g_month_day()
-
-
-def matches_xs_g_month_day(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:gMonthDay``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#gMonthDay
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_G_MONTH_DAY.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_g_year() -> Pattern[str]:
-    g_year_rep = (
-        "-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
-    )
-    pattern = f"^{g_year_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_G_YEAR = _construct_matches_xs_g_year()
-
-
-def matches_xs_g_year(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:gYear``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#gYear
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_G_YEAR.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_g_year_month() -> Pattern[str]:
-    g_year_month_rep = "-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
-    pattern = f"^{g_year_month_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_G_YEAR_MONTH = _construct_matches_xs_g_year_month()
-
-
-def matches_xs_g_year_month(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:gYearMonth``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#gYearMonth
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_G_YEAR_MONTH.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_hex_binary() -> Pattern[str]:
-    hex_binary = "([0-9a-fA-F]{2})*"
-    pattern = f"^{hex_binary}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_HEX_BINARY = _construct_matches_xs_hex_binary()
-
-
-def matches_xs_hex_binary(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:hexBinary``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#hexBinary
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_HEX_BINARY.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_time() -> Pattern[str]:
-    time_rep = "(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?|(24:00:00(\\.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
-    pattern = f"^{time_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_TIME = _construct_matches_xs_time()
-
-
-def matches_xs_time(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:time``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#time
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_TIME.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_integer() -> Pattern[str]:
-    integer_rep = "[-+]?[0-9]+"
-    pattern = f"^{integer_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_INTEGER = _construct_matches_xs_integer()
-
-
-def matches_xs_integer(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:integer``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#integer
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_INTEGER.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_long() -> Pattern[str]:
-    long_rep = "[-+]?0*[0-9]{1,20}"
-    pattern = f"^{long_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_LONG = _construct_matches_xs_long()
-
-
-def matches_xs_long(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:long``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#long
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_LONG.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_int() -> Pattern[str]:
-    int_rep = "[-+]?0*[0-9]{1,10}"
-    pattern = f"^{int_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_INT = _construct_matches_xs_int()
-
-
-def matches_xs_int(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:int``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#int
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_INT.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_short() -> Pattern[str]:
-    short_rep = "[-+]?0*[0-9]{1,5}"
-    pattern = f"^{short_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_SHORT = _construct_matches_xs_short()
-
-
-def matches_xs_short(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:short``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#short
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_SHORT.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_byte() -> Pattern[str]:
-    byte_rep = "[-+]?0*[0-9]{1,3}"
-    pattern = f"^{byte_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_BYTE = _construct_matches_xs_byte()
-
-
-def matches_xs_byte(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:byte``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#byte
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_BYTE.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_non_negative_integer() -> Pattern[str]:
-    non_negative_integer_rep = "(-0|\\+?[0-9]+)"
-    pattern = f"^{non_negative_integer_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_NON_NEGATIVE_INTEGER = _construct_matches_xs_non_negative_integer()
-
-
-def matches_xs_non_negative_integer(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:nonNegativeInteger``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#nonNegativeInteger
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_NON_NEGATIVE_INTEGER.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_positive_integer() -> Pattern[str]:
-    positive_integer_rep = "\\+?0*[1-9][0-9]*"
-    pattern = f"^{positive_integer_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_POSITIVE_INTEGER = _construct_matches_xs_positive_integer()
-
-
-def matches_xs_positive_integer(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:positiveInteger``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#positiveInteger
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_POSITIVE_INTEGER.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_unsigned_long() -> Pattern[str]:
-    unsigned_long_rep = "(-0|\\+?0*[0-9]{1,20})"
-    pattern = f"^{unsigned_long_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_UNSIGNED_LONG = _construct_matches_xs_unsigned_long()
-
-
-def matches_xs_unsigned_long(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:unsignedLong``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#unsignedLong
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_UNSIGNED_LONG.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_unsigned_int() -> Pattern[str]:
-    unsigned_int_rep = "(-0|\\+?0*[0-9]{1,10})"
-    pattern = f"^{unsigned_int_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_UNSIGNED_INT = _construct_matches_xs_unsigned_int()
-
-
-def matches_xs_unsigned_int(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:unsignedInt``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#unsignedInt
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_UNSIGNED_INT.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_unsigned_short() -> Pattern[str]:
-    unsigned_short_rep = "(-0|\\+?0*[0-9]{1,5})"
-    pattern = f"^{unsigned_short_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_UNSIGNED_SHORT = _construct_matches_xs_unsigned_short()
-
-
-def matches_xs_unsigned_short(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:unsignedShort``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#unsignedShort
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_UNSIGNED_SHORT.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_unsigned_byte() -> Pattern[str]:
-    unsigned_byte_rep = "(-0|\\+?0*[0-9]{1,3})"
-    pattern = f"^{unsigned_byte_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_UNSIGNED_BYTE = _construct_matches_xs_unsigned_byte()
-
-
-def matches_xs_unsigned_byte(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:unsignedByte``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#unsignedByte
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_UNSIGNED_BYTE.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_non_positive_integer() -> Pattern[str]:
-    non_positive_integer_rep = "(\\+0|0|-[0-9]+)"
-    pattern = f"^{non_positive_integer_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_NON_POSITIVE_INTEGER = _construct_matches_xs_non_positive_integer()
-
-
-def matches_xs_non_positive_integer(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:nonPositiveInteger``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#nonPositiveInteger
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_NON_POSITIVE_INTEGER.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_negative_integer() -> Pattern[str]:
-    negative_integer_rep = "(-0*[1-9][0-9]*)"
-    pattern = f"^{negative_integer_rep}$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_NEGATIVE_INTEGER = _construct_matches_xs_negative_integer()
-
-
-def matches_xs_negative_integer(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:negativeInteger``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#negativeInteger
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_NEGATIVE_INTEGER.match(text) is not None
-
-
-# noinspection SpellCheckingInspection
-def _construct_matches_xs_string() -> Pattern[str]:
-    pattern = "^[\\x09\\x0a\\x0d\\x20-\\ud7ff\\ue000-\\ufffd\\U00010000-\\U0010ffff]*$"
-
-    return re.compile(pattern)
-
-
-_REGEX_MATCHES_XS_STRING = _construct_matches_xs_string()
-
-
-def matches_xs_string(text: str) -> bool:
-    """
-    Check that :paramref:`text` conforms to the pattern of an ``xs:string``.
-
-    See: https://www.w3.org/TR/xmlschema-2/#string
-
-    :param text: Text to be checked
-    :return:
-        True if the :paramref:`text` conforms to the pattern
-    """
-    return _REGEX_MATCHES_XS_STRING.match(text) is not None
-
-
-def _is_leap_year(year: int) -> bool:
-    """
-    Check if :paramref:`year` is a leap year.
-
-    >>> _is_leap_year(2016)
-    True
-
-    >>> _is_leap_year(1700)
-    False
-
-    >>> _is_leap_year(1600)
-    True
-
-    >>> _is_leap_year(2000)
-    True
-    """
-    # We consider the years B.C. to be one-off.
-    #
-    # See the note at: https://www.w3.org/TR/xmlschema-2/#dateTime:
-    # "'-0001' is the lexical representation of the year 1 Before Common Era
-    # (1 BCE, sometimes written "1 BC")."
-    #
-    # Hence, -1 year in XML is 1 BCE, which is 0 year in astronomical years.
-    if year < 0:
-        year = abs(year) - 1
-
-    # See: https://en.wikipedia.org/wiki/Leap_year#Algorithm
-    if year % 4 > 0:
-        return False
-
-    if year % 100 > 0:
-        return True
-
-    if year % 400 > 0:
-        return False
-
-    return True
-
-
-_DAYS_IN_MONTH: Mapping[int, int] = {
-    1: 31,
-    # Please use _is_leap_year if you need to check
-    # whether a concrete February has 28 or 29 days.
-    2: 29,
-    3: 31,
-    4: 30,
-    5: 31,
-    6: 30,
-    7: 31,
-    8: 31,
-    9: 30,
-    10: 31,
-    11: 30,
-    12: 31,
-}
-
-
-_DATE_PREFIX_RE = re.compile(r"^(-?[0-9]+)-([0-9]{2})-([0-9]{2})")
-
-
-def is_xs_date(value: str) -> bool:
-    """Check that :paramref:`value` is a valid ``xs:date``."""
-    if not matches_xs_date(value):
-        return False
-
-    # NOTE (mristin, 2022-11-23):
-    # We can not use :py:func:`datetime.datetime.strptime` as it does not
-    # handle years below 1000 correctly on Windows (*e.g.*, ``-999-01-01``).
-
-    # NOTE (mristin, 2022-10-30):
-    # We need to match the prefix as zone offsets are allowed in the dates. Optimally,
-    # we would re-use the pattern matching from :py:func`matches_xs_date`, but this
-    # would make the code generation and constraint inference for schemas much more
-    # difficult. Hence, we sacrifice the efficiency a bit for the clearer code & code
-    # generation.
-    match = _DATE_PREFIX_RE.match(value)
-    assert match is not None
-
-    year = int(match.group(1))
-    month = int(match.group(2))
-    day = int(match.group(3))
-
-    # We do not accept year zero,
-    # see the note at: https://www.w3.org/TR/xmlschema-2/#dateTime
-    if year == 0:
-        return False
-
-    if day <= 0:
-        return False
-
-    if month <= 0 or month >= 13:
-        return False
-
-    if month == 2:
-        max_days = 29 if _is_leap_year(year) else 28
-    else:
-        max_days = _DAYS_IN_MONTH[month]
-
-    if day > max_days:
-        return False
-
-    return True
-
-
-def is_xs_double(value: str) -> bool:
-    """Check that :paramref:`value` is a valid ``xs:double``."""
-    # We need to check explicitly for the regular expression since
-    # ``float(.)`` is too permissive. For example,
-    # it accepts "nan" although only "NaN" is valid.
-    # See: https://www.w3.org/TR/xmlschema-2/#double
-    if not matches_xs_double(value):
-        return False
-
-    converted = float(value)
-
-    # Check that the value is either "INF" or "-INF".
-    # Otherwise, the value is a decimal which is too big
-    # to be represented as a double-precision floating point
-    # number.
-    #
-    # Python simply rounds up/down to ``INF`` and ``-INF``,
-    # respectively, if the number is too large.
-    # For example: ``float("1e400") == math.inf``
-    if math.isinf(converted) and value != "INF" and value != "-INF":
-        return False
-
-    return True
-
-
-def is_xs_float(value: str) -> bool:
-    """Check that :paramref:`value` is a valid ``xs:float``."""
-    # We need to check explicitly for the regular expression since
-    # ``float(.)`` is too permissive. For example,
-    # it accepts "nan" although only "NaN" is valid.
-    # See: https://www.w3.org/TR/xmlschema-2/#double
-    if not matches_xs_float(value):
-        return False
-
-    converted = float(value)
-
-    # Check that the value is either "INF" or "-INF".
-    # Otherwise, the value is a decimal which is too big
-    # to be represented as a single-precision floating point
-    # number.
-    #
-    # Python simply rounds up/down to ``INF`` and ``-INF``,
-    # respectively, if the number is too large.
-    # For example: ``float("1e400") == math.inf``
-    if math.isinf(converted) and value != "INF" and value != "-INF":
-        return False
-
-    # Python uses double-precision floating point numbers. Since
-    # we check for a single-precision one, we have to explicitly
-    # see if the number is within a range of a single-precision
-    # floating point numbers.
-    try:
-        _ = struct.pack(">f", converted)
-    except OverflowError:
-        return False
-
-    return True
-
-
-def is_xs_g_month_day(value: str) -> bool:
-    """Check that :paramref:`value` is a valid ``xs:gMonthDay``."""
-    if not matches_xs_g_month_day(value):
-        return False
-
-    month = int(value[2:4])
-    day = int(value[5:7])
-
-    max_days = _DAYS_IN_MONTH[month]
-    return day <= max_days
-
-
-def is_xs_long(value: str) -> bool:
-    """Check that :paramref:`value` is a valid ``xs:long``."""
-    if not matches_xs_long(value):
-        return False
-
-    converted = int(value)
-    return -9223372036854775808 <= converted <= 9223372036854775807
-
-
-def is_xs_int(value: str) -> bool:
-    """Check that :paramref:`value` is a valid ``xs:int``."""
-    if not matches_xs_int(value):
-        return False
-
-    converted = int(value)
-    return -2147483648 <= converted <= 2147483647
-
-
-def is_xs_short(value: str) -> bool:
-    """Check that :paramref:`value` is a valid ``xs:short``."""
-    if not matches_xs_short(value):
-        return False
-
-    converted = int(value)
-    return -32768 <= converted <= 32767
-
-
-def is_xs_byte(value: str) -> bool:
-    """Check that :paramref:`value` is a valid ``xs:byte``."""
-    if not matches_xs_byte(value):
-        return False
-
-    converted = int(value)
-    return -128 <= converted <= 127
-
-
-def is_xs_unsigned_long(value: str) -> bool:
-    """Check that :paramref:`value` is a valid ``xs:unsignedLong``."""
-    if not matches_xs_unsigned_long(value):
-        return False
-
-    converted = int(value)
-    return 0 <= converted <= 18446744073709551615
-
-
-def is_xs_unsigned_int(value: str) -> bool:
-    """Check that :paramref:`value` is a valid ``xs:unsignedInt``."""
-    if not matches_xs_unsigned_int(value):
-        return False
-
-    converted = int(value)
-    return 0 <= converted <= 4294967295
-
-
-def is_xs_unsigned_short(value: str) -> bool:
-    """Check that :paramref:`value` is a valid ``xs:unsignedShort``."""
-    if not matches_xs_unsigned_short(value):
-        return False
-
-    converted = int(value)
-    return 0 <= converted <= 65535
-
-
-def is_xs_unsigned_byte(value: str) -> bool:
-    """Check that :paramref:`value` is a valid ``xs:unsignedByte``."""
-    if not matches_xs_unsigned_byte(value):
-        return False
-
-    converted = int(value)
-    return 0 <= converted <= 255
-
-
-_DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY: Mapping[
-    aas_types.DataTypeDefXSD, Callable[[str], bool]
-] = {
-    aas_types.DataTypeDefXSD.ANY_URI: matches_xs_any_uri,
-    aas_types.DataTypeDefXSD.BASE_64_BINARY: matches_xs_base_64_binary,
-    aas_types.DataTypeDefXSD.BOOLEAN: matches_xs_boolean,
-    aas_types.DataTypeDefXSD.BYTE: is_xs_byte,
-    aas_types.DataTypeDefXSD.DATE: is_xs_date,
-    aas_types.DataTypeDefXSD.DATE_TIME: is_xs_date_time,
-    aas_types.DataTypeDefXSD.DECIMAL: matches_xs_decimal,
-    aas_types.DataTypeDefXSD.DOUBLE: is_xs_double,
-    aas_types.DataTypeDefXSD.DURATION: matches_xs_duration,
-    aas_types.DataTypeDefXSD.FLOAT: is_xs_float,
-    aas_types.DataTypeDefXSD.G_DAY: matches_xs_g_day,
-    aas_types.DataTypeDefXSD.G_MONTH: matches_xs_g_month,
-    aas_types.DataTypeDefXSD.G_MONTH_DAY: is_xs_g_month_day,
-    aas_types.DataTypeDefXSD.G_YEAR: matches_xs_g_year,
-    aas_types.DataTypeDefXSD.G_YEAR_MONTH: matches_xs_g_year_month,
-    aas_types.DataTypeDefXSD.HEX_BINARY: matches_xs_hex_binary,
-    aas_types.DataTypeDefXSD.INT: is_xs_int,
-    aas_types.DataTypeDefXSD.INTEGER: matches_xs_integer,
-    aas_types.DataTypeDefXSD.LONG: is_xs_long,
-    aas_types.DataTypeDefXSD.NEGATIVE_INTEGER: matches_xs_negative_integer,
-    aas_types.DataTypeDefXSD.NON_NEGATIVE_INTEGER: matches_xs_non_negative_integer,
-    aas_types.DataTypeDefXSD.NON_POSITIVE_INTEGER: matches_xs_non_positive_integer,
-    aas_types.DataTypeDefXSD.POSITIVE_INTEGER: matches_xs_positive_integer,
-    aas_types.DataTypeDefXSD.SHORT: is_xs_short,
-    aas_types.DataTypeDefXSD.STRING: matches_xs_string,
-    aas_types.DataTypeDefXSD.TIME: matches_xs_time,
-    aas_types.DataTypeDefXSD.UNSIGNED_BYTE: is_xs_unsigned_byte,
-    aas_types.DataTypeDefXSD.UNSIGNED_INT: is_xs_unsigned_int,
-    aas_types.DataTypeDefXSD.UNSIGNED_LONG: is_xs_unsigned_long,
-    aas_types.DataTypeDefXSD.UNSIGNED_SHORT: is_xs_unsigned_short,
-}
-assert all(
-    data_type_def_xsd in _DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY
-    for data_type_def_xsd in aas_types.DataTypeDefXSD
-)
-
-
-def value_consistent_with_xsd_type(
-    value: str, value_type: aas_types.DataTypeDefXSD
-) -> bool:
-    """
-    Check that :paramref:`value` is consistent with the given
-    :paramref:`value_type`.
-    """
-    return _DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY[value_type](value)
-
-
-def is_model_reference_to(
-    reference: aas_types.Reference, expected_type: aas_types.KeyTypes
-) -> bool:
-    """
-    Check that the target of the model reference matches the :paramref:`expected_type`.
-    """
-    # pylint: disable=all
-    return (
-        reference.type == aas_types.ReferenceTypes.MODEL_REFERENCE
-        and len(reference.keys) != 0
-        and reference.keys[-1].type == expected_type
-    )
-
-
-def is_model_reference_to_referable(reference: aas_types.Reference) -> bool:
-    """
-    Check that the target of the reference matches a :py:attr:`.constants.AAS_REFERABLES`.
-    """
-    # pylint: disable=all
-    return (
-        reference.type == aas_types.ReferenceTypes.MODEL_REFERENCE
-        and len(reference.keys) != 0
-        and (reference.keys[-1].type in aas_constants.AAS_REFERABLES)
-    )
-
-
-def id_shorts_are_unique(referables: Iterable[aas_types.Referable]) -> bool:
-    """
-    Check that all :py:attr:`.types.Referable.id_short` are unique
-    among :paramref:`referables`.
-    """
-    id_short_set = set()  # type: Set[str]
-    for referable in referables:
-        if referable.id_short in id_short_set:
-            return False
-
-        if referable.id_short is not None:
-            id_short_set.add(referable.id_short)
-
-    return True
-
-
-def id_shorts_of_variables_are_unique(
-    input_variables: Optional[List[aas_types.OperationVariable]],
-    output_variables: Optional[List[aas_types.OperationVariable]],
-    inoutput_variables: Optional[List[aas_types.OperationVariable]],
-) -> bool:
-    """
-    Check that the :py:attr:`.types.Referable.id_short`'s among all the
-    :paramref:`input_variables`, :paramref:`output_variables`
-    and :paramref:`inoutput_variables` are unique.
-    """
-    id_short_set = set()
-    if input_variables is not None:
-        for variable in input_variables:
-            if variable.value.id_short is not None:
-                if variable.value.id_short in id_short_set:
-                    return False
-
-                id_short_set.add(variable.value.id_short)
-    if output_variables is not None:
-        for variable in output_variables:
-            if variable.value.id_short is not None:
-                if variable.value.id_short in id_short_set:
-                    return False
-
-                id_short_set.add(variable.value.id_short)
-    if inoutput_variables is not None:
-        for variable in inoutput_variables:
-            if variable.value.id_short is not None:
-                if variable.value.id_short in id_short_set:
-                    return False
-
-                id_short_set.add(variable.value.id_short)
-    return True
-
-
-def extension_names_are_unique(extensions: Iterable[aas_types.Extension]) -> bool:
-    """
-    Check that all :py:attr:`.types.Extension.name` are unique
-    among :paramref:`extensions`.
-    """
-    name_set = set()  # type: Set[str]
-    for extension in extensions:
-        if extension.name in name_set:
-            return False
-
-        name_set.add(extension.name)
-
-    return True
-
-
-def submodel_elements_have_identical_semantic_ids(
-    elements: Iterable[aas_types.SubmodelElement],
-) -> bool:
-    """
-    Check that all :paramref:`elements` have the identical
-    :py:attr:`.types.HasSemantics.semantic_id`.
-    """
-    that_semantic_id = None  # type: Optional[aas_types.Reference]
-
-    for element in elements:
-        if element.semantic_id is None:
-            continue
-
-        if that_semantic_id is None:
-            that_semantic_id = element.semantic_id
-            continue
-
-        this_semantic_id = element.semantic_id
-
-        if len(that_semantic_id.keys) != len(this_semantic_id.keys):
-            return False
-
-        for this_key, that_key in zip(this_semantic_id.keys, that_semantic_id.keys):
-            if this_key.value != that_key.value:
-                return False
-
-    return True
-
-
-# fmt: off
-_AAS_SUBMODEL_ELEMENTS_TO_TYPE: Mapping[
-    aas_types.AASSubmodelElements,
-    type
-] = {
-    aas_types.AASSubmodelElements.ANNOTATED_RELATIONSHIP_ELEMENT:
-        aas_types.AnnotatedRelationshipElement,
-
-    aas_types.AASSubmodelElements.BASIC_EVENT_ELEMENT:
-        aas_types.BasicEventElement,
-
-    aas_types.AASSubmodelElements.BLOB:
-        aas_types.Blob,
-
-    aas_types.AASSubmodelElements.CAPABILITY:
-        aas_types.Capability,
-
-    aas_types.AASSubmodelElements.DATA_ELEMENT:
-        aas_types.DataElement,
-
-    aas_types.AASSubmodelElements.ENTITY:
-        aas_types.Entity,
-
-    aas_types.AASSubmodelElements.EVENT_ELEMENT:
-        aas_types.EventElement,
-
-    aas_types.AASSubmodelElements.FILE:
-        aas_types.File,
-
-    aas_types.AASSubmodelElements.MULTI_LANGUAGE_PROPERTY:
-        aas_types.MultiLanguageProperty,
-
-    aas_types.AASSubmodelElements.OPERATION:
-        aas_types.Operation,
-
-    aas_types.AASSubmodelElements.PROPERTY:
-        aas_types.Property,
-
-    aas_types.AASSubmodelElements.RANGE:
-        aas_types.Range,
-
-    aas_types.AASSubmodelElements.REFERENCE_ELEMENT:
-        aas_types.ReferenceElement,
-
-    aas_types.AASSubmodelElements.RELATIONSHIP_ELEMENT:
-        aas_types.RelationshipElement,
-
-    aas_types.AASSubmodelElements.SUBMODEL_ELEMENT:
-        aas_types.SubmodelElement,
-
-    aas_types.AASSubmodelElements.SUBMODEL_ELEMENT_LIST:
-        aas_types.SubmodelElementList,
-
-    aas_types.AASSubmodelElements.SUBMODEL_ELEMENT_COLLECTION:
-        aas_types.SubmodelElementCollection,
-}
-# fmt: on
-
-
-def _assert_all_types_covered_in_aas_submodel_elements_to_type() -> None:
-    """
-    Assert that we did not miss a type in :py:attr:`_AAS_SUBMODEL_ELEMENTS_TO_TYPE`.
-    """
-    missing_literals = [
-        literal
-        for literal in aas_types.AASSubmodelElements
-        if literal not in _AAS_SUBMODEL_ELEMENTS_TO_TYPE
-    ]
-
-    assert len(missing_literals) == 0, (
-        f"Some literals were missed in "
-        f"_AAS_SUBMODEL_ELEMENTS_TO_TYPE: {missing_literals!r}"
-    )
-
-
-_assert_all_types_covered_in_aas_submodel_elements_to_type()
-
-
-def submodel_element_is_of_type(
-    element: aas_types.SubmodelElement, expected_type: aas_types.AASSubmodelElements
-) -> bool:
-    """
-    Check that :paramref:`element` is an instance of class corresponding
-    to :paramref:`expected_type`.
-    """
-    # noinspection PyTypeHints
-    return isinstance(element, _AAS_SUBMODEL_ELEMENTS_TO_TYPE[expected_type])
-
-
-def properties_or_ranges_have_value_type(
-    elements: Iterable[aas_types.SubmodelElement], value_type: aas_types.DataTypeDefXSD
-) -> bool:
-    """
-    Check that :paramref:`elements` which are
-    :py:class:`.types.Property` or :py:class:`.types.Range`
-    have the given :paramref:`value_type`.
-    """
-    range_or_property = (aas_types.Property, aas_types.Range)
-    for element in elements:
-        if isinstance(element, range_or_property):
-            if element.value_type is not value_type:
-                return False
-
-    return True
-
-
-def reference_key_values_equal(
-    that: aas_types.Reference, other: aas_types.Reference
-) -> bool:
-    """
-    Check that the two references, :paramref:`that` and :paramref:`other`,
-    are equal by comparing their :py:attr:`.types.Reference.keys`
-    by :py:attr:`.types.Key.value`'s.
-    """
-    if len(that.keys) != len(other.keys):
-        return False
-
-    for that_key, other_key in zip(that.keys, other.keys):
-        if that_key.value != other_key.value:
-            return False
-
-    return True
-
-
-def data_specification_iec_61360s_for_property_or_value_have_appropriate_data_type(
-    embedded_data_specifications: Iterable[aas_types.EmbeddedDataSpecification],
-) -> bool:
-    """
-    Check that :py:attr:`.types.DataSpecificationIEC61360.data_type`
-    is defined appropriately for all data specifications whose content is given
-    as IEC 61360.
-    """
-    for embedded_data_specification in embedded_data_specifications:
-        if isinstance(
-            embedded_data_specification.data_specification_content,
-            aas_types.DataSpecificationIEC61360,
-        ):
-            iec61360 = embedded_data_specification.data_specification_content
-            if (
-                iec61360.data_type is None
-                or iec61360.data_type
-                not in aas_constants.DATA_TYPE_IEC_61360_FOR_PROPERTY_OR_VALUE
-            ):
-                return False
-
-    return True
-
-
-def data_specification_iec_61360s_for_reference_have_appropriate_data_type(
-    embedded_data_specifications: Iterable[aas_types.EmbeddedDataSpecification],
-) -> bool:
-    """
-    Check that :py:attr:`.types.DataSpecificationIEC61360.data_type`
-    is defined appropriately for all data specifications whose content is given
-    as IEC 61360.
-    """
-    for embedded_data_specification in embedded_data_specifications:
-        if isinstance(
-            embedded_data_specification.data_specification_content,
-            aas_types.DataSpecificationIEC61360,
-        ):
-            iec61360 = embedded_data_specification.data_specification_content
-            if (
-                iec61360.data_type is None
-                or iec61360.data_type
-                not in aas_constants.DATA_TYPE_IEC_61360_FOR_REFERENCE
-            ):
-                return False
-
-    return True
-
-
-def data_specification_iec_61360s_for_document_have_appropriate_data_type(
-    embedded_data_specifications: Iterable[aas_types.EmbeddedDataSpecification],
-) -> bool:
-    """
-    Check that :py:attr:`.types.DataSpecificationIEC61360.data_type`
-    is defined appropriately for all data specifications whose content is given as
-    IEC 61360.
-    """
-    for embedded_data_specification in embedded_data_specifications:
-        if isinstance(
-            embedded_data_specification.data_specification_content,
-            aas_types.DataSpecificationIEC61360,
-        ):
-            iec61360 = embedded_data_specification.data_specification_content
-            if (
-                iec61360.data_type is None
-                or iec61360.data_type
-                not in aas_constants.DATA_TYPE_IEC_61360_FOR_DOCUMENT
-            ):
-                return False
-
-    return True
-
-
-def data_specification_iec_61360s_have_data_type(
-    embedded_data_specifications: Iterable[aas_types.EmbeddedDataSpecification],
-) -> bool:
-    """
-    Check that :py:attr:`.types.DataSpecificationIEC61360.data_type`
-    is defined for all data specifications whose content is given as IEC 61360.
-    """
-    for embedded_data_specification in embedded_data_specifications:
-        if isinstance(
-            embedded_data_specification.data_specification_content,
-            aas_types.DataSpecificationIEC61360,
-        ):
-            iec61360 = embedded_data_specification.data_specification_content
-            if iec61360.data_type is None:
-                return False
-
-    return True
-
-
-def data_specification_iec_61360s_have_value(
-    embedded_data_specifications: Iterable[aas_types.EmbeddedDataSpecification],
-) -> bool:
-    """
-    Check that :py:attr:`.types.DataSpecificationIEC61360.value`
-    is defined for all data specifications whose content is given as IEC 61360.
-    """
-    for embedded_data_specification in embedded_data_specifications:
-        if isinstance(
-            embedded_data_specification.data_specification_content,
-            aas_types.DataSpecificationIEC61360,
-        ):
-            iec61360 = embedded_data_specification.data_specification_content
-            if iec61360.value is None:
-                return False
-
-    return True
-
-
-def data_specification_iec_61360s_have_definition_at_least_in_english(
-    embedded_data_specifications: Iterable[aas_types.EmbeddedDataSpecification],
-) -> bool:
-    """
-    Check that :py:attr:`.types.DataSpecificationIEC61360.definition`
-    is defined for all data specifications whose content is given as IEC 61360
-    at least in English.
-    """
-    for embedded_data_specification in embedded_data_specifications:
-        if isinstance(
-            embedded_data_specification.data_specification_content,
-            aas_types.DataSpecificationIEC61360,
-        ):
-            iec61360 = embedded_data_specification.data_specification_content
-            if iec61360.definition is None:
-                return False
-
-            no_definition_in_english = True
-            for lang_string in iec61360.definition:
-                if is_bcp_47_for_english(lang_string.language):
-                    no_definition_in_english = False
-                    break
-
-            if no_definition_in_english:
-                return False
-
-    return True
-
-
-# noinspection SpellCheckingInspection
-def _construct_is_bcp_47_for_english() -> Pattern[str]:
-    pattern = "^(en|EN)(-.*)?$"
-
-    return re.compile(pattern)
-
-
-_REGEX_IS_BCP_47_FOR_ENGLISH = _construct_is_bcp_47_for_english()
-
-
-def is_bcp_47_for_english(text: str) -> bool:
-    """
-    Check that the :paramref:`text` corresponds to a BCP47 code for english.
-    """
-    return _REGEX_IS_BCP_47_FOR_ENGLISH.match(text) is not None
-
-
-class _Transformer(aas_types.AbstractTransformer[Iterator[Error]]):
-    # noinspection PyMethodMayBeStatic
-    def transform_extension(self, that: aas_types.Extension) -> Iterator[Error]:
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.refers_to is not None) or (len(that.refers_to) >= 1)):
-            yield Error("Refers-to must be either not set or have at least one item.")
-
-        if not (
-            not (that.value is not None)
-            or value_consistent_with_xsd_type(that.value, that.value_type_or_default())
-        ):
-            yield Error("The value must match the value type.")
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, an_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        for error in verify_name_type(that.name):
-            error.path._prepend(PropertySegment(that, "name"))
-            yield error
-
-        if that.value is not None:
-            for error in verify_value_data_type(that.value):
-                error.path._prepend(PropertySegment(that, "value"))
-                yield error
-
-        if that.refers_to is not None:
-            for i, another_item in enumerate(that.refers_to):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.refers_to, i))
-                    error.path._prepend(PropertySegment(that, "refers_to"))
-                    yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_administrative_information(
-        self, that: aas_types.AdministrativeInformation
-    ) -> Iterator[Error]:
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (not (that.revision is not None) or (that.version is not None)):
-            yield Error(
-                "Constraint AASd-005: If version is not specified then also "
-                + "revision shall be unspecified. This means, a revision "
-                + "requires a version. If there is no version there is no "
-                + "revision either. Revision is optional."
-            )
-
-        if that.embedded_data_specifications is not None:
-            for i, an_item in enumerate(that.embedded_data_specifications):
-                for error in self.transform(an_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.version is not None:
-            for error in verify_version_type(that.version):
-                error.path._prepend(PropertySegment(that, "version"))
-                yield error
-
-        if that.revision is not None:
-            for error in verify_revision_type(that.revision):
-                error.path._prepend(PropertySegment(that, "revision"))
-                yield error
-
-        if that.creator is not None:
-            for error in self.transform(that.creator):
-                error.path._prepend(PropertySegment(that, "creator"))
-                yield error
-
-        if that.template_id is not None:
-            for error in verify_identifier(that.template_id):
-                error.path._prepend(PropertySegment(that, "template_id"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_qualifier(self, that: aas_types.Qualifier) -> Iterator[Error]:
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (
-            not (that.value is not None)
-            or value_consistent_with_xsd_type(that.value, that.value_type)
-        ):
-            yield Error(
-                "Constraint AASd-020: The value shall be consistent to "
-                + "the data type as defined in value type."
-            )
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, an_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        for error in verify_qualifier_type(that.type):
-            error.path._prepend(PropertySegment(that, "type"))
-            yield error
-
-        if that.value is not None:
-            for error in verify_value_data_type(that.value):
-                error.path._prepend(PropertySegment(that, "value"))
-                yield error
-
-        if that.value_id is not None:
-            for error in self.transform(that.value_id):
-                error.path._prepend(PropertySegment(that, "value_id"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_asset_administration_shell(
-        self, that: aas_types.AssetAdministrationShell
-    ) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (that.id_short is not None):
-            yield Error(
-                "Constraint AASd-117: ID-short of Referables not being "
-                + "a direct child of a Submodel element list shall be "
-                + "specified."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (not (that.submodels is not None) or (len(that.submodels) >= 1)):
-            yield Error("Submodels must be either not set or have at least one item.")
-
-        if not (
-            not (that.derived_from is not None)
-            or is_model_reference_to(
-                that.derived_from, aas_types.KeyTypes.ASSET_ADMINISTRATION_SHELL
-            )
-        ):
-            yield Error(
-                "Derived-from must be a model reference to an asset "
-                + "administration shell."
-            )
-
-        if not (
-            not (that.submodels is not None)
-            or (
-                all(
-                    is_model_reference_to(reference, aas_types.KeyTypes.SUBMODEL)
-                    for reference in that.submodels
-                )
-            )
-        ):
-            yield Error("All submodels must be model references to a submodel.")
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.administration is not None:
-            for error in self.transform(that.administration):
-                error.path._prepend(PropertySegment(that, "administration"))
-                yield error
-
-        for error in verify_identifier(that.id):
-            error.path._prepend(PropertySegment(that, "id"))
-            yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_another_item in enumerate(that.embedded_data_specifications):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.derived_from is not None:
-            for error in self.transform(that.derived_from):
-                error.path._prepend(PropertySegment(that, "derived_from"))
-                yield error
-
-        for error in self.transform(that.asset_information):
-            error.path._prepend(PropertySegment(that, "asset_information"))
-            yield error
-
-        if that.submodels is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.submodels):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.submodels, i))
-                    error.path._prepend(PropertySegment(that, "submodels"))
-                    yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_asset_information(
-        self, that: aas_types.AssetInformation
-    ) -> Iterator[Error]:
-        if not (
-            not (that.specific_asset_ids is not None)
-            or (
-                all(
-                    (
-                        specific_asset_id.name != "globalAssetId"
-                        or (
-                            (
-                                specific_asset_id.name == "globalAssetId"
-                                and specific_asset_id.value == that.global_asset_id
-                            )
-                        )
-                    )
-                    for specific_asset_id in that.specific_asset_ids
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASd-116: ``globalAssetId`` is a reserved key. "
-                + "If used as value for the name of specific asset ID then "
-                + "the value of specific asset ID shall be identical to "
-                + "the global asset ID."
-            )
-
-        if not (
-            (
-                (
-                    (
-                        (that.global_asset_id is not None)
-                        and (that.specific_asset_ids is None)
-                    )
-                )
-                or (
-                    (
-                        (that.global_asset_id is None)
-                        and (that.specific_asset_ids is not None)
-                        and len(that.specific_asset_ids) >= 1
-                    )
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASd-131: Either the global asset ID shall be "
-                + "defined or at least one specific asset ID."
-            )
-
-        if not (
-            not (that.specific_asset_ids is not None)
-            or (len(that.specific_asset_ids) >= 1)
-        ):
-            yield Error(
-                "Specific asset IDs must be either not set or have at least "
-                + "one item."
-            )
-
-        if that.global_asset_id is not None:
-            for error in verify_identifier(that.global_asset_id):
-                error.path._prepend(PropertySegment(that, "global_asset_id"))
-                yield error
-
-        if that.specific_asset_ids is not None:
-            for i, an_item in enumerate(that.specific_asset_ids):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.specific_asset_ids, i))
-                    error.path._prepend(PropertySegment(that, "specific_asset_ids"))
-                    yield error
-
-        if that.asset_type is not None:
-            for error in verify_identifier(that.asset_type):
-                error.path._prepend(PropertySegment(that, "asset_type"))
-                yield error
-
-        if that.default_thumbnail is not None:
-            for error in self.transform(that.default_thumbnail):
-                error.path._prepend(PropertySegment(that, "default_thumbnail"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_resource(self, that: aas_types.Resource) -> Iterator[Error]:
-        for error in verify_path_type(that.path):
-            error.path._prepend(PropertySegment(that, "path"))
-            yield error
-
-        if that.content_type is not None:
-            for error in verify_content_type(that.content_type):
-                error.path._prepend(PropertySegment(that, "content_type"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_specific_asset_id(
-        self, that: aas_types.SpecificAssetID
-    ) -> Iterator[Error]:
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (
-            not (that.external_subject_id is not None)
-            or (
-                that.external_subject_id.type
-                == aas_types.ReferenceTypes.EXTERNAL_REFERENCE
-            )
-        ):
-            yield Error(
-                "Constraint AASd-133: External subject ID shall be "
-                + "an external reference."
-            )
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, an_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        for error in verify_label_type(that.name):
-            error.path._prepend(PropertySegment(that, "name"))
-            yield error
-
-        for error in verify_identifier(that.value):
-            error.path._prepend(PropertySegment(that, "value"))
-            yield error
-
-        if that.external_subject_id is not None:
-            for error in self.transform(that.external_subject_id):
-                error.path._prepend(PropertySegment(that, "external_subject_id"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_submodel(self, that: aas_types.Submodel) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (that.id_short is not None):
-            yield Error(
-                "Constraint AASd-117: ID-short of Referables not being "
-                + "a direct child of a Submodel element list shall be "
-                + "specified."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (
-            not (that.submodel_elements is not None)
-            or (len(that.submodel_elements) >= 1)
-        ):
-            yield Error(
-                "Submodel elements must be either not set or have at least "
-                + "one item."
-            )
-
-        if not (
-            not (that.submodel_elements is not None)
-            or (all(item.id_short is not None for item in that.submodel_elements))
-        ):
-            yield Error(
-                "ID-shorts need to be defined for all the items of submodel "
-                + "elements according to AASd-117 (ID-short of Referables not "
-                + "being a direct child of a Submodel element list shall be "
-                + "specified)."
-            )
-
-        if not (
-            not (that.submodel_elements is not None)
-            or id_shorts_are_unique(that.submodel_elements)
-        ):
-            yield Error(
-                "Constraint AASd-022: ID-short of non-identifiable "
-                + "referables within the same name space shall be unique "
-                + "(case-sensitive)."
-            )
-
-        if not (
-            not (that.submodel_elements is not None)
-            or (
-                not (that.kind != aas_types.ModellingKind.TEMPLATE)
-                or (
-                    all(
-                        not (submodel_element.qualifiers is not None)
-                        or (
-                            all(
-                                qualifier.kind_or_default()
-                                != aas_types.QualifierKind.TEMPLATE_QUALIFIER
-                                for qualifier in submodel_element.qualifiers
-                            )
-                        )
-                        for submodel_element in that.submodel_elements
-                    )
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASd-129: If any qualifier kind value of "
-                + "a Submodel element qualifier (attribute qualifier inherited "
-                + "via Qualifiable) is equal to Template Qualifier then "
-                + "the submodel element shall be part of a submodel template, "
-                + "i.e. a Submodel with submodel kind (attribute kind "
-                + "inherited via Has-Kind) value is equal to Template."
-            )
-
-        if not (
-            not (that.qualifiers is not None)
-            or (
-                not (
-                    any(
-                        qualifier.kind_or_default()
-                        == aas_types.QualifierKind.TEMPLATE_QUALIFIER
-                        for qualifier in that.qualifiers
-                    )
-                )
-                or (that.kind_or_default() == aas_types.ModellingKind.TEMPLATE)
-            )
-        ):
-            yield Error(
-                "Constraint AASd-119: If any qualifier kind value of "
-                + "a qualifiable qualifier is equal to template qualifier and "
-                + "the qualified element has kind then the qualified element "
-                + "shall be of kind template."
-            )
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.administration is not None:
-            for error in self.transform(that.administration):
-                error.path._prepend(PropertySegment(that, "administration"))
-                yield error
-
-        for error in verify_identifier(that.id):
-            error.path._prepend(PropertySegment(that, "id"))
-            yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.submodel_elements is not None:
-            for i, yet_yet_yet_yet_yet_another_item in enumerate(
-                that.submodel_elements
-            ):
-                for error in self.transform(yet_yet_yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.submodel_elements, i))
-                    error.path._prepend(PropertySegment(that, "submodel_elements"))
-                    yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_relationship_element(
-        self, that: aas_types.RelationshipElement
-    ) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (that.id_short is not None):
-            yield Error(
-                "Constraint AASd-117: ID-short of Referables not being "
-                + "a direct child of a Submodel element list shall be "
-                + "specified."
-            )
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        for error in self.transform(that.first):
-            error.path._prepend(PropertySegment(that, "first"))
-            yield error
-
-        for error in self.transform(that.second):
-            error.path._prepend(PropertySegment(that, "second"))
-            yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_submodel_element_list(
-        self, that: aas_types.SubmodelElementList
-    ) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (not (that.value is not None) or (len(that.value) >= 1)):
-            yield Error("Value must be either not set or have at least one item.")
-
-        if not (
-            not (
-                (
-                    (that.value is not None)
-                    and (that.semantic_id_list_element is not None)
-                )
-            )
-            or (
-                all(
-                    not (child.semantic_id is not None)
-                    or reference_key_values_equal(
-                        child.semantic_id, that.semantic_id_list_element
-                    )
-                    for child in that.value
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASd-107: If a first level child element has "
-                + "a semantic ID it shall be identical to semantic ID list "
-                + "element."
-            )
-
-        if not (
-            not (that.value is not None)
-            or submodel_elements_have_identical_semantic_ids(that.value)
-        ):
-            yield Error(
-                "Constraint AASd-114: If two first level child elements have "
-                + "a semantic ID then they shall be identical."
-            )
-
-        if not (
-            not (that.value is not None)
-            or (
-                all(
-                    submodel_element_is_of_type(element, that.type_value_list_element)
-                    for element in that.value
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASd-108: All first level child elements shall "
-                + "have the same submodel element type as specified in type "
-                + "value list element."
-            )
-
-        if not (
-            not (
-                (
-                    (that.value is not None)
-                    and (
-                        (
-                            that.type_value_list_element
-                            == aas_types.AASSubmodelElements.PROPERTY
-                            or that.type_value_list_element
-                            == aas_types.AASSubmodelElements.RANGE
-                        )
-                    )
-                )
-            )
-            or (
-                (
-                    (that.value_type_list_element is not None)
-                    and properties_or_ranges_have_value_type(
-                        that.value, that.value_type_list_element
-                    )
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASd-109: If type value list element is equal to "
-                + "Property or Range value type list element shall be set and "
-                + "all first level child elements shall have the value type as "
-                + "specified in value type list element."
-            )
-
-        if not (
-            not (that.value is not None)
-            or (all(element.id_short is None for element in that.value))
-        ):
-            yield Error(
-                "Constraint AASd-120: ID-short of submodel elements being "
-                + "a direct child of a  Submodel element list shall not be "
-                + "specified."
-            )
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.semantic_id_list_element is not None:
-            for error in self.transform(that.semantic_id_list_element):
-                error.path._prepend(PropertySegment(that, "semantic_id_list_element"))
-                yield error
-
-        if that.value is not None:
-            for i, yet_yet_yet_yet_yet_another_item in enumerate(that.value):
-                for error in self.transform(yet_yet_yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.value, i))
-                    error.path._prepend(PropertySegment(that, "value"))
-                    yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_submodel_element_collection(
-        self, that: aas_types.SubmodelElementCollection
-    ) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (not (that.value is not None) or (len(that.value) >= 1)):
-            yield Error("Value must be either not set or have at least one item.")
-
-        if not (
-            not (that.value is not None)
-            or (all(item.id_short is not None for item in that.value))
-        ):
-            yield Error(
-                "ID-shorts need to be defined for all the items of value "
-                + "according to AASd-117 (ID-short of Referables not being "
-                + "a direct child of a Submodel element list shall be "
-                + "specified)."
-            )
-
-        if not (not (that.value is not None) or id_shorts_are_unique(that.value)):
-            yield Error("ID-shorts of the value must be unique.")
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.value is not None:
-            for i, yet_yet_yet_yet_yet_another_item in enumerate(that.value):
-                for error in self.transform(yet_yet_yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.value, i))
-                    error.path._prepend(PropertySegment(that, "value"))
-                    yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_property(self, that: aas_types.Property) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (
-            not (that.category is not None)
-            or (that.category in aas_constants.VALID_CATEGORIES_FOR_DATA_ELEMENT)
-        ):
-            yield Error(
-                "Constraint AASd-090: For data elements category shall be "
-                + "one of the following values: CONSTANT, PARAMETER or "
-                + "VARIABLE."
-            )
-
-        if not (
-            not (that.value is not None)
-            or value_consistent_with_xsd_type(that.value, that.value_type)
-        ):
-            yield Error("Value must be consistent with the value type.")
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.value is not None:
-            for error in verify_value_data_type(that.value):
-                error.path._prepend(PropertySegment(that, "value"))
-                yield error
-
-        if that.value_id is not None:
-            for error in self.transform(that.value_id):
-                error.path._prepend(PropertySegment(that, "value_id"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_multi_language_property(
-        self, that: aas_types.MultiLanguageProperty
-    ) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (
-            not (that.category is not None)
-            or (that.category in aas_constants.VALID_CATEGORIES_FOR_DATA_ELEMENT)
-        ):
-            yield Error(
-                "Constraint AASd-090: For data elements category shall be "
-                + "one of the following values: CONSTANT, PARAMETER or "
-                + "VARIABLE."
-            )
-
-        if not (
-            not (that.value is not None)
-            or lang_strings_have_unique_languages(that.value)
-        ):
-            yield Error("Value specifies no duplicate languages.")
-
-        if not (not (that.value is not None) or (len(that.value) >= 1)):
-            yield Error("Value must be either not set or have at least one item.")
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.value is not None:
-            for i, yet_yet_yet_yet_yet_another_item in enumerate(that.value):
-                for error in self.transform(yet_yet_yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.value, i))
-                    error.path._prepend(PropertySegment(that, "value"))
-                    yield error
-
-        if that.value_id is not None:
-            for error in self.transform(that.value_id):
-                error.path._prepend(PropertySegment(that, "value_id"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_range(self, that: aas_types.Range) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (
-            not (that.category is not None)
-            or (that.category in aas_constants.VALID_CATEGORIES_FOR_DATA_ELEMENT)
-        ):
-            yield Error(
-                "Constraint AASd-090: For data elements category shall be "
-                + "one of the following values: CONSTANT, PARAMETER or "
-                + "VARIABLE."
-            )
-
-        if not (
-            not (that.max is not None)
-            or value_consistent_with_xsd_type(that.max, that.value_type)
-        ):
-            yield Error("Max must be consistent with the value type.")
-
-        if not (
-            not (that.min is not None)
-            or value_consistent_with_xsd_type(that.min, that.value_type)
-        ):
-            yield Error("Min must be consistent with the value type.")
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.min is not None:
-            for error in verify_value_data_type(that.min):
-                error.path._prepend(PropertySegment(that, "min"))
-                yield error
-
-        if that.max is not None:
-            for error in verify_value_data_type(that.max):
-                error.path._prepend(PropertySegment(that, "max"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_reference_element(
-        self, that: aas_types.ReferenceElement
-    ) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (
-            not (that.category is not None)
-            or (that.category in aas_constants.VALID_CATEGORIES_FOR_DATA_ELEMENT)
-        ):
-            yield Error(
-                "Constraint AASd-090: For data elements category shall be "
-                + "one of the following values: CONSTANT, PARAMETER or "
-                + "VARIABLE."
-            )
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.value is not None:
-            for error in self.transform(that.value):
-                error.path._prepend(PropertySegment(that, "value"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_blob(self, that: aas_types.Blob) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (
-            not (that.category is not None)
-            or (that.category in aas_constants.VALID_CATEGORIES_FOR_DATA_ELEMENT)
-        ):
-            yield Error(
-                "Constraint AASd-090: For data elements category shall be "
-                + "one of the following values: CONSTANT, PARAMETER or "
-                + "VARIABLE."
-            )
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.value is not None:
-            for error in verify_blob_type(that.value):
-                error.path._prepend(PropertySegment(that, "value"))
-                yield error
-
-        for error in verify_content_type(that.content_type):
-            error.path._prepend(PropertySegment(that, "content_type"))
-            yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_file(self, that: aas_types.File) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (
-            not (that.category is not None)
-            or (that.category in aas_constants.VALID_CATEGORIES_FOR_DATA_ELEMENT)
-        ):
-            yield Error(
-                "Constraint AASd-090: For data elements category shall be "
-                + "one of the following values: CONSTANT, PARAMETER or "
-                + "VARIABLE."
-            )
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.value is not None:
-            for error in verify_path_type(that.value):
-                error.path._prepend(PropertySegment(that, "value"))
-                yield error
-
-        for error in verify_content_type(that.content_type):
-            error.path._prepend(PropertySegment(that, "content_type"))
-            yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_annotated_relationship_element(
-        self, that: aas_types.AnnotatedRelationshipElement
-    ) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (that.id_short is not None):
-            yield Error(
-                "Constraint AASd-117: ID-short of Referables not being "
-                + "a direct child of a Submodel element list shall be "
-                + "specified."
-            )
-
-        if not (not (that.annotations is not None) or (len(that.annotations) >= 1)):
-            yield Error(
-                "Annotations must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.annotations is not None)
-            or (all(item.id_short is not None for item in that.annotations))
-        ):
-            yield Error(
-                "ID-shorts need to be defined for all the items of "
-                + "annotations according to AASd-117 (ID-short of Referables "
-                + "not being a direct child of a Submodel element list shall "
-                + "be specified)."
-            )
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        for error in self.transform(that.first):
-            error.path._prepend(PropertySegment(that, "first"))
-            yield error
-
-        for error in self.transform(that.second):
-            error.path._prepend(PropertySegment(that, "second"))
-            yield error
-
-        if that.annotations is not None:
-            for i, yet_yet_yet_yet_yet_another_item in enumerate(that.annotations):
-                for error in self.transform(yet_yet_yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.annotations, i))
-                    error.path._prepend(PropertySegment(that, "annotations"))
-                    yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_entity(self, that: aas_types.Entity) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (not (that.statements is not None) or (len(that.statements) >= 1)):
-            yield Error("Statements must be either not set or have at least one item.")
-
-        if not (
-            not (that.statements is not None)
-            or (all(item.id_short is not None for item in that.statements))
-        ):
-            yield Error(
-                "ID-shorts need to be defined for all the items of "
-                + "statements according to AASd-117 (ID-short of Referables "
-                + "not being a direct child of a Submodel element list shall "
-                + "be specified)."
-            )
-
-        if not (
-            (
-                (
-                    (
-                        that.entity_type == aas_types.EntityType.SELF_MANAGED_ENTITY
-                        and (
-                            (
-                                (
-                                    (
-                                        (that.global_asset_id is not None)
-                                        and (that.specific_asset_ids is None)
-                                    )
-                                )
-                                or (
-                                    (
-                                        (that.global_asset_id is None)
-                                        and (that.specific_asset_ids is not None)
-                                        and len(that.specific_asset_ids) >= 1
-                                    )
-                                )
-                            )
-                        )
-                    )
-                )
-                or (
-                    (
-                        (that.global_asset_id is None)
-                        and (that.specific_asset_ids is None)
-                    )
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASd-014: Either the attribute global asset ID "
-                + "or specific asset ID must be set if entity type is set to "
-                + "self-managed entity. They are not existing otherwise."
-            )
-
-        if not (
-            not (that.specific_asset_ids is not None)
-            or (len(that.specific_asset_ids) >= 1)
-        ):
-            yield Error(
-                "Specific asset IDs must be either not set or have at least "
-                + "one item."
-            )
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.statements is not None:
-            for i, yet_yet_yet_yet_yet_another_item in enumerate(that.statements):
-                for error in self.transform(yet_yet_yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.statements, i))
-                    error.path._prepend(PropertySegment(that, "statements"))
-                    yield error
-
-        if that.global_asset_id is not None:
-            for error in verify_identifier(that.global_asset_id):
-                error.path._prepend(PropertySegment(that, "global_asset_id"))
-                yield error
-
-        if that.specific_asset_ids is not None:
-            for i, yet_yet_yet_yet_yet_yet_another_item in enumerate(
-                that.specific_asset_ids
-            ):
-                for error in self.transform(yet_yet_yet_yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.specific_asset_ids, i))
-                    error.path._prepend(PropertySegment(that, "specific_asset_ids"))
-                    yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_event_payload(self, that: aas_types.EventPayload) -> Iterator[Error]:
-        if not (
-            (
-                is_model_reference_to(that.source, aas_types.KeyTypes.EVENT_ELEMENT)
-                or is_model_reference_to(
-                    that.source, aas_types.KeyTypes.BASIC_EVENT_ELEMENT
-                )
-            )
-        ):
-            yield Error("Source must be a model reference to an Event element.")
-
-        if not (is_model_reference_to_referable(that.observable_reference)):
-            yield Error(
-                "Observable reference must be a model reference to " + "a referable."
-            )
-
-        for error in self.transform(that.source):
-            error.path._prepend(PropertySegment(that, "source"))
-            yield error
-
-        if that.source_semantic_id is not None:
-            for error in self.transform(that.source_semantic_id):
-                error.path._prepend(PropertySegment(that, "source_semantic_id"))
-                yield error
-
-        for error in self.transform(that.observable_reference):
-            error.path._prepend(PropertySegment(that, "observable_reference"))
-            yield error
-
-        if that.observable_semantic_id is not None:
-            for error in self.transform(that.observable_semantic_id):
-                error.path._prepend(PropertySegment(that, "observable_semantic_id"))
-                yield error
-
-        if that.topic is not None:
-            for error in verify_message_topic_type(that.topic):
-                error.path._prepend(PropertySegment(that, "topic"))
-                yield error
-
-        if that.subject_id is not None:
-            for error in self.transform(that.subject_id):
-                error.path._prepend(PropertySegment(that, "subject_id"))
-                yield error
-
-        for error in verify_date_time_utc(that.time_stamp):
-            error.path._prepend(PropertySegment(that, "time_stamp"))
-            yield error
-
-        if that.payload is not None:
-            for error in verify_blob_type(that.payload):
-                error.path._prepend(PropertySegment(that, "payload"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_basic_event_element(
-        self, that: aas_types.BasicEventElement
-    ) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (that.id_short is not None):
-            yield Error(
-                "Constraint AASd-117: ID-short of Referables not being "
-                + "a direct child of a Submodel element list shall be "
-                + "specified."
-            )
-
-        if not (
-            not (that.direction == aas_types.Direction.INPUT)
-            or (that.max_interval is None)
-        ):
-            yield Error("Max. interval is not applicable for input direction.")
-
-        if not is_model_reference_to_referable(that.observed):
-            yield Error("Observed must be a model reference to a referable.")
-
-        if not (
-            not (that.message_broker is not None)
-            or is_model_reference_to_referable(that.message_broker)
-        ):
-            yield Error("Message broker must be a model reference to a referable.")
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        for error in self.transform(that.observed):
-            error.path._prepend(PropertySegment(that, "observed"))
-            yield error
-
-        if that.message_topic is not None:
-            for error in verify_message_topic_type(that.message_topic):
-                error.path._prepend(PropertySegment(that, "message_topic"))
-                yield error
-
-        if that.message_broker is not None:
-            for error in self.transform(that.message_broker):
-                error.path._prepend(PropertySegment(that, "message_broker"))
-                yield error
-
-        if that.last_update is not None:
-            for error in verify_date_time_utc(that.last_update):
-                error.path._prepend(PropertySegment(that, "last_update"))
-                yield error
-
-        if that.min_interval is not None:
-            for error in verify_duration(that.min_interval):
-                error.path._prepend(PropertySegment(that, "min_interval"))
-                yield error
-
-        if that.max_interval is not None:
-            for error in verify_duration(that.max_interval):
-                error.path._prepend(PropertySegment(that, "max_interval"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_operation(self, that: aas_types.Operation) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (
-            id_shorts_of_variables_are_unique(
-                that.input_variables, that.output_variables, that.inoutput_variables
-            )
-        ):
-            yield Error(
-                "Constraint AASd-134: For an Operation the ID-short of all "
-                + "values of input, output and in/output variables."
-            )
-
-        if not (
-            not (that.input_variables is not None) or (len(that.input_variables) >= 1)
-        ):
-            yield Error(
-                "Input variables must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.output_variables is not None) or (len(that.output_variables) >= 1)
-        ):
-            yield Error(
-                "Output variables must be either not set or have at least "
-                + "one item."
-            )
-
-        if not (
-            not (that.inoutput_variables is not None)
-            or (len(that.inoutput_variables) >= 1)
-        ):
-            yield Error(
-                "Inoutput variables must be either not set or have at least "
-                + "one item."
-            )
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.input_variables is not None:
-            for i, yet_yet_yet_yet_yet_another_item in enumerate(that.input_variables):
-                for error in self.transform(yet_yet_yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.input_variables, i))
-                    error.path._prepend(PropertySegment(that, "input_variables"))
-                    yield error
-
-        if that.output_variables is not None:
-            for i, yet_yet_yet_yet_yet_yet_another_item in enumerate(
-                that.output_variables
-            ):
-                for error in self.transform(yet_yet_yet_yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.output_variables, i))
-                    error.path._prepend(PropertySegment(that, "output_variables"))
-                    yield error
-
-        if that.inoutput_variables is not None:
-            for i, yet_yet_yet_yet_yet_yet_yet_another_item in enumerate(
-                that.inoutput_variables
-            ):
-                for error in self.transform(yet_yet_yet_yet_yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.inoutput_variables, i))
-                    error.path._prepend(PropertySegment(that, "inoutput_variables"))
-                    yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_operation_variable(
-        self, that: aas_types.OperationVariable
-    ) -> Iterator[Error]:
-        if not (that.value.id_short is not None):
-            yield Error(
-                "Value must have the ID-short specified according to "
-                + "Constraint AASd-117 (ID-short of Referables not being "
-                + "a direct child of a Submodel element list shall be "
-                + "specified)."
-            )
-
-        for error in self.transform(that.value):
-            error.path._prepend(PropertySegment(that, "value"))
-            yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_capability(self, that: aas_types.Capability) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (len(that.supplemental_semantic_ids) >= 1)
-        ):
-            yield Error(
-                "Supplemental semantic IDs must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (
-            not (that.supplemental_semantic_ids is not None)
-            or (that.semantic_id is not None)
-        ):
-            yield Error(
-                "Constraint AASd-118: If there are supplemental semantic IDs "
-                + "defined then there shall be also a main semantic ID."
-            )
-
-        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
-            yield Error("Qualifiers must be either not set or have at least one item.")
-
-        if not (
-            not (that.qualifiers is not None)
-            or qualifier_types_are_unique(that.qualifiers)
-        ):
-            yield Error(
-                "Constraint AASd-021: Every qualifiable can only have one "
-                + "qualifier with the same type."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.semantic_id is not None:
-            for error in self.transform(that.semantic_id):
-                error.path._prepend(PropertySegment(that, "semantic_id"))
-                yield error
-
-        if that.supplemental_semantic_ids is not None:
-            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
-                    error.path._prepend(
-                        PropertySegment(that, "supplemental_semantic_ids")
-                    )
-                    yield error
-
-        if that.qualifiers is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.qualifiers, i))
-                    error.path._prepend(PropertySegment(that, "qualifiers"))
-                    yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_yet_yet_another_item in enumerate(
-                that.embedded_data_specifications
-            ):
-                for error in self.transform(yet_yet_yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_concept_description(
-        self, that: aas_types.ConceptDescription
-    ) -> Iterator[Error]:
-        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
-            yield Error("Extensions must be either not set or have at least one item.")
-
-        if not (
-            not (that.extensions is not None)
-            or extension_names_are_unique(that.extensions)
-        ):
-            yield Error(
-                "Constraint AASd-077: The name of an extension within "
-                + "Has-Extensions needs to be unique."
-            )
-
-        if not (not (that.description is not None) or (len(that.description) >= 1)):
-            yield Error(
-                "Description must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.description is not None)
-            or lang_strings_have_unique_languages(that.description)
-        ):
-            yield Error("Description specifies no duplicate languages.")
-
-        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
-            yield Error(
-                "Display name must be either not set or have at least one " + "item."
-            )
-
-        if not (
-            not (that.display_name is not None)
-            or lang_strings_have_unique_languages(that.display_name)
-        ):
-            yield Error("Display name specifies no duplicate languages.")
-
-        if not (that.id_short is not None):
-            yield Error(
-                "Constraint AASd-117: ID-short of Referables not being "
-                + "a direct child of a Submodel element list shall be "
-                + "specified."
-            )
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (len(that.embedded_data_specifications) >= 1)
-        ):
-            yield Error(
-                "Embedded data specifications must be either not set or have "
-                + "at least one item."
-            )
-
-        if not (not (that.is_case_of is not None) or (len(that.is_case_of) >= 1)):
-            yield Error("Is-case-of must be either not set or have at least one item.")
-
-        if not (
-            not (that.embedded_data_specifications is not None)
-            or (
-                (
-                    data_specification_iec_61360s_have_definition_at_least_in_english(
-                        that.embedded_data_specifications
-                    )
-                    or data_specification_iec_61360s_have_value(
-                        that.embedded_data_specifications
-                    )
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASc-3a-008: For a concept description using "
-                + "data specification template IEC 61360, the definition is "
-                + "mandatory and shall be defined at least in English. "
-                + "Exception: The concept description describes a value."
-            )
-
-        if not (
-            not (
-                (
-                    (that.category is not None)
-                    and that.category == "QUALIFIER_TYPE"
-                    and (that.embedded_data_specifications is not None)
-                )
-            )
-            or data_specification_iec_61360s_have_data_type(
-                that.embedded_data_specifications
-            )
-        ):
-            yield Error(
-                "Constraint AASc-3a-007: For a concept description with "
-                + "category QUALIFIER_TYPE using data specification IEC 61360, "
-                + "the data type of the data specification is mandatory and "
-                + "shall be defined."
-            )
-
-        if not (
-            not (
-                (
-                    (that.category is not None)
-                    and that.category == "DOCUMENT"
-                    and (that.embedded_data_specifications is not None)
-                )
-            )
-            or data_specification_iec_61360s_for_document_have_appropriate_data_type(
-                that.embedded_data_specifications
-            )
-        ):
-            yield Error(
-                "Constraint AASc-3a-006: For a concept description with "
-                + "category DOCUMENT using data specification IEC 61360, "
-                + "the data type of the data specification shall be one of: "
-                + "FILE, BLOB, HTML."
-            )
-
-        if not (
-            not (
-                (
-                    (that.category is not None)
-                    and that.category == "REFERENCE"
-                    and (that.embedded_data_specifications is not None)
-                )
-            )
-            or data_specification_iec_61360s_for_reference_have_appropriate_data_type(
-                that.embedded_data_specifications
-            )
-        ):
-            yield Error(
-                "Constraint AASc-3a-005: For a concept description with "
-                + "category REFERENCE using data specification IEC 61360, "
-                + "the data type of the data specification shall be one of: "
-                + "STRING, IRI, IRDI."
-            )
-
-        if not (
-            not (
-                (
-                    (that.category is not None)
-                    and ((that.category == "PROPERTY" or that.category == "VALUE"))
-                    and (that.embedded_data_specifications is not None)
-                )
-            )
-            or data_specification_iec_61360s_for_property_or_value_have_appropriate_data_type(
-                that.embedded_data_specifications
-            )
-        ):
-            yield Error(
-                "Constraint AASc-3a-004: For a concept description with "
-                + "category PROPERTY or VALUE using data specification IEC "
-                + "61360, the data type of the data specification is mandatory "
-                + "and shall be one of: DATE, STRING, STRING_TRANSLATABLE, "
-                + "INTEGER_MEASURE, INTEGER_COUNT, INTEGER_CURRENCY, "
-                + "REAL_MEASURE, REAL_COUNT, REAL_CURRENCY, BOOLEAN, RATIONAL, "
-                + "RATIONAL_MEASURE, TIME, TIMESTAMP."
-            )
-
-        if that.extensions is not None:
-            for i, an_item in enumerate(that.extensions):
-                for error in self.transform(an_item):
-                    error.path._prepend(IndexSegment(that.extensions, i))
-                    error.path._prepend(PropertySegment(that, "extensions"))
-                    yield error
-
-        if that.category is not None:
-            for error in verify_name_type(that.category):
-                error.path._prepend(PropertySegment(that, "category"))
-                yield error
-
-        if that.id_short is not None:
-            for error in verify_id_short_type(that.id_short):
-                error.path._prepend(PropertySegment(that, "id_short"))
-                yield error
-
-        if that.display_name is not None:
-            for i, another_item in enumerate(that.display_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.display_name, i))
-                    error.path._prepend(PropertySegment(that, "display_name"))
-                    yield error
-
-        if that.description is not None:
-            for i, yet_another_item in enumerate(that.description):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.description, i))
-                    error.path._prepend(PropertySegment(that, "description"))
-                    yield error
-
-        if that.administration is not None:
-            for error in self.transform(that.administration):
-                error.path._prepend(PropertySegment(that, "administration"))
-                yield error
-
-        for error in verify_identifier(that.id):
-            error.path._prepend(PropertySegment(that, "id"))
-            yield error
-
-        if that.embedded_data_specifications is not None:
-            for i, yet_yet_another_item in enumerate(that.embedded_data_specifications):
-                for error in self.transform(yet_yet_another_item):
-                    error.path._prepend(
-                        IndexSegment(that.embedded_data_specifications, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "embedded_data_specifications")
-                    )
-                    yield error
-
-        if that.is_case_of is not None:
-            for i, yet_yet_yet_another_item in enumerate(that.is_case_of):
-                for error in self.transform(yet_yet_yet_another_item):
-                    error.path._prepend(IndexSegment(that.is_case_of, i))
-                    error.path._prepend(PropertySegment(that, "is_case_of"))
-                    yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_reference(self, that: aas_types.Reference) -> Iterator[Error]:
-        if not (len(that.keys) >= 1):
-            yield Error("Keys must contain at least one item.")
-
-        if not (
-            not (len(that.keys) >= 1)
-            or (that.keys[0].type in aas_constants.GLOBALLY_IDENTIFIABLES)
-        ):
-            yield Error(
-                "Constraint AASd-121: For References the value of type of "
-                + "the first key of keys shall be one of Globally "
-                + "Identifiables."
-            )
-
-        if not (
-            not (
-                (
-                    that.type == aas_types.ReferenceTypes.EXTERNAL_REFERENCE
-                    and len(that.keys) >= 1
-                )
-            )
-            or (that.keys[0].type in aas_constants.GENERIC_GLOBALLY_IDENTIFIABLES)
-        ):
-            yield Error(
-                "Constraint AASd-122: For external references the value of "
-                + "type of the first key of keys shall be one of Generic "
-                + "Globally Identifiables."
-            )
-
-        if not (
-            not (
-                (
-                    that.type == aas_types.ReferenceTypes.MODEL_REFERENCE
-                    and len(that.keys) >= 1
-                )
-            )
-            or (that.keys[0].type in aas_constants.AAS_IDENTIFIABLES)
-        ):
-            yield Error(
-                "Constraint AASd-123: For model references the value of type "
-                + "of the first key of keys shall be one of AAS identifiables."
-            )
-
-        if not (
-            not (
-                (
-                    that.type == aas_types.ReferenceTypes.EXTERNAL_REFERENCE
-                    and len(that.keys) >= 1
-                )
-            )
-            or (
-                (
-                    (that.keys[-1].type in aas_constants.GENERIC_GLOBALLY_IDENTIFIABLES)
-                    or (that.keys[-1].type in aas_constants.GENERIC_FRAGMENT_KEYS)
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASd-124: For external references the last key "
-                + "of keys shall be either one of Generic Globally "
-                + "Identifiables or one of Generic Fragment Keys."
-            )
-
-        if not (
-            not (
-                (
-                    that.type == aas_types.ReferenceTypes.MODEL_REFERENCE
-                    and len(that.keys) > 1
-                )
-            )
-            or (
-                all(
-                    that.keys[i].type in aas_constants.FRAGMENT_KEYS
-                    for i in range(1, len(that.keys))
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASd-125: For model references with more than "
-                + "one key in keys the value of type of each of the keys "
-                + "following the first key of keys shall be one of Fragment "
-                + "Keys."
-            )
-
-        if not (
-            not (
-                (
-                    that.type == aas_types.ReferenceTypes.MODEL_REFERENCE
-                    and len(that.keys) > 1
-                )
-            )
-            or (
-                all(
-                    not (that.keys[i].type in aas_constants.GENERIC_FRAGMENT_KEYS)
-                    for i in range(0, len(that.keys) - 1)
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASd-126: For model references with more than "
-                + "one key in keys the value of type of the last key in "
-                + "the reference key chain may be one of Generic Fragment Keys "
-                + "or no key at all shall have a value out of Generic Fragment "
-                + "Keys."
-            )
-
-        if not (
-            not (
-                (
-                    that.type == aas_types.ReferenceTypes.MODEL_REFERENCE
-                    and len(that.keys) > 1
-                    and that.keys[-1].type == aas_types.KeyTypes.FRAGMENT_REFERENCE
-                )
-            )
-            or (
-                (
-                    that.keys[-2].type == aas_types.KeyTypes.FILE
-                    or that.keys[-2].type == aas_types.KeyTypes.BLOB
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASd-127: For model references, with more than "
-                + "one key in keys a key with type Fragment Reference shall be "
-                + "preceded by a key with type File or Blob."
-            )
-
-        if not (
-            not (
-                (
-                    that.type == aas_types.ReferenceTypes.MODEL_REFERENCE
-                    and len(that.keys) > 2
-                )
-            )
-            or (
-                all(
-                    not (that.keys[i].type == aas_types.KeyTypes.SUBMODEL_ELEMENT_LIST)
-                    or matches_xs_positive_integer(that.keys[i + 1].value)
-                    for i in range(0, len(that.keys) - 1)
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASd-128: For model references, the value of "
-                + "a key preceded by a key with type Submodel element list is "
-                + "an integer number denoting the position in the array of "
-                + "the submodel element list."
-            )
-
-        if that.referred_semantic_id is not None:
-            for error in self.transform(that.referred_semantic_id):
-                error.path._prepend(PropertySegment(that, "referred_semantic_id"))
-                yield error
-
-        for i, an_item in enumerate(that.keys):
-            for error in self.transform(an_item):
-                error.path._prepend(IndexSegment(that.keys, i))
-                error.path._prepend(PropertySegment(that, "keys"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_key(self, that: aas_types.Key) -> Iterator[Error]:
-        for error in verify_identifier(that.value):
-            error.path._prepend(PropertySegment(that, "value"))
-            yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_lang_string_name_type(
-        self, that: aas_types.LangStringNameType
-    ) -> Iterator[Error]:
-        if not (len(that.text) <= 128):
-            yield Error("String shall have a maximum length of 128 characters.")
-
-        for error in verify_bcp_47_language_tag(that.language):
-            error.path._prepend(PropertySegment(that, "language"))
-            yield error
-
-        for error in verify_non_empty_xml_serializable_string(that.text):
-            error.path._prepend(PropertySegment(that, "text"))
-            yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_lang_string_text_type(
-        self, that: aas_types.LangStringTextType
-    ) -> Iterator[Error]:
-        if not (len(that.text) <= 1023):
-            yield Error("String shall have a maximum length of 1023 characters.")
-
-        for error in verify_bcp_47_language_tag(that.language):
-            error.path._prepend(PropertySegment(that, "language"))
-            yield error
-
-        for error in verify_non_empty_xml_serializable_string(that.text):
-            error.path._prepend(PropertySegment(that, "text"))
-            yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_environment(self, that: aas_types.Environment) -> Iterator[Error]:
-        if not (
-            not (that.concept_descriptions is not None)
-            or (len(that.concept_descriptions) >= 1)
-        ):
-            yield Error(
-                "Concept descriptions must be either not set or have at "
-                + "least one item."
-            )
-
-        if not (not (that.submodels is not None) or (len(that.submodels) >= 1)):
-            yield Error("Submodels must be either not set or have at least one item.")
-
-        if not (
-            not (that.asset_administration_shells is not None)
-            or (len(that.asset_administration_shells) >= 1)
-        ):
-            yield Error(
-                "Asset administration shells must be either not set or have "
-                + "at least one item."
-            )
-
-        if that.asset_administration_shells is not None:
-            for i, an_item in enumerate(that.asset_administration_shells):
-                for error in self.transform(an_item):
-                    error.path._prepend(
-                        IndexSegment(that.asset_administration_shells, i)
-                    )
-                    error.path._prepend(
-                        PropertySegment(that, "asset_administration_shells")
-                    )
-                    yield error
-
-        if that.submodels is not None:
-            for i, another_item in enumerate(that.submodels):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.submodels, i))
-                    error.path._prepend(PropertySegment(that, "submodels"))
-                    yield error
-
-        if that.concept_descriptions is not None:
-            for i, yet_another_item in enumerate(that.concept_descriptions):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.concept_descriptions, i))
-                    error.path._prepend(PropertySegment(that, "concept_descriptions"))
-                    yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_embedded_data_specification(
-        self, that: aas_types.EmbeddedDataSpecification
-    ) -> Iterator[Error]:
-        for error in self.transform(that.data_specification):
-            error.path._prepend(PropertySegment(that, "data_specification"))
-            yield error
-
-        for error in self.transform(that.data_specification_content):
-            error.path._prepend(PropertySegment(that, "data_specification_content"))
-            yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_level_type(self, that: aas_types.LevelType) -> Iterator[Error]:
-        # No verification has been defined for LevelType.
-        return
-        # For this uncommon return-yield construction, see:
-        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
-        # noinspection PyUnreachableCode
-        yield
-
-    # noinspection PyMethodMayBeStatic
-    def transform_value_reference_pair(
-        self, that: aas_types.ValueReferencePair
-    ) -> Iterator[Error]:
-        for error in verify_value_type_iec_61360(that.value):
-            error.path._prepend(PropertySegment(that, "value"))
-            yield error
-
-        for error in self.transform(that.value_id):
-            error.path._prepend(PropertySegment(that, "value_id"))
-            yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_value_list(self, that: aas_types.ValueList) -> Iterator[Error]:
-        if not (len(that.value_reference_pairs) >= 1):
-            yield Error("Value reference pair types must contain at least one item.")
-
-        for i, an_item in enumerate(that.value_reference_pairs):
-            for error in self.transform(an_item):
-                error.path._prepend(IndexSegment(that.value_reference_pairs, i))
-                error.path._prepend(PropertySegment(that, "value_reference_pairs"))
-                yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_lang_string_preferred_name_type_iec_61360(
-        self, that: aas_types.LangStringPreferredNameTypeIEC61360
-    ) -> Iterator[Error]:
-        if not (len(that.text) <= 255):
-            yield Error("String shall have a maximum length of 1023 characters.")
-
-        for error in verify_bcp_47_language_tag(that.language):
-            error.path._prepend(PropertySegment(that, "language"))
-            yield error
-
-        for error in verify_non_empty_xml_serializable_string(that.text):
-            error.path._prepend(PropertySegment(that, "text"))
-            yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_lang_string_short_name_type_iec_61360(
-        self, that: aas_types.LangStringShortNameTypeIEC61360
-    ) -> Iterator[Error]:
-        if not (len(that.text) <= 18):
-            yield Error("String shall have a maximum length of 1023 characters.")
-
-        for error in verify_bcp_47_language_tag(that.language):
-            error.path._prepend(PropertySegment(that, "language"))
-            yield error
-
-        for error in verify_non_empty_xml_serializable_string(that.text):
-            error.path._prepend(PropertySegment(that, "text"))
-            yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_lang_string_definition_type_iec_61360(
-        self, that: aas_types.LangStringDefinitionTypeIEC61360
-    ) -> Iterator[Error]:
-        if not (len(that.text) <= 1023):
-            yield Error("String shall have a maximum length of 1023 characters.")
-
-        for error in verify_bcp_47_language_tag(that.language):
-            error.path._prepend(PropertySegment(that, "language"))
-            yield error
-
-        for error in verify_non_empty_xml_serializable_string(that.text):
-            error.path._prepend(PropertySegment(that, "text"))
-            yield error
-
-    # noinspection PyMethodMayBeStatic
-    def transform_data_specification_iec_61360(
-        self, that: aas_types.DataSpecificationIEC61360
-    ) -> Iterator[Error]:
-        if not (
-            (
-                (((that.value is not None) and (that.value_list is None)))
-                or (
-                    (
-                        (that.value is None)
-                        and (that.value_list is not None)
-                        and len(that.value_list.value_reference_pairs) >= 1
-                    )
-                )
-            )
-        ):
-            yield Error(
-                "Constraint AASc-3a-010: If value is not empty then value "
-                + "list shall be empty and vice versa."
-            )
-
-        if not (
-            not (
-                (
-                    (that.data_type is None)
-                    and (that.data_type in aas_constants.IEC_61360_DATA_TYPES_WITH_UNIT)
-                )
-            )
-            or (((that.unit is not None) or (that.unit_id is not None)))
-        ):
-            yield Error(
-                "Constraint AASc-3a-009: If data type is a an integer, real "
-                + "or rational with a measure or currency, unit or unit ID "
-                + "shall be defined."
-            )
-
-        if not (not (that.definition is not None) or (len(that.definition) >= 1)):
-            yield Error("Definition must be either not set or have at least one item.")
-
-        if not (
-            not (that.definition is not None)
-            or lang_strings_have_unique_languages(that.definition)
-        ):
-            yield Error("Definition specifies no duplicate languages.")
-
-        if not (not (that.short_name is not None) or (len(that.short_name) >= 1)):
-            yield Error("Short name must be either not set or have at least one item.")
-
-        if not (
-            not (that.short_name is not None)
-            or lang_strings_have_unique_languages(that.short_name)
-        ):
-            yield Error("Short name specifies no duplicate languages.")
-
-        if not (len(that.preferred_name) >= 1):
-            yield Error("Preferred name must have at least one item.")
-
-        if not (lang_strings_have_unique_languages(that.preferred_name)):
-            yield Error("Preferred name specifies no duplicate languages.")
-
-        if not (
-            any(
-                is_bcp_47_for_english(lang_string.language)
-                for lang_string in that.preferred_name
-            )
-        ):
-            yield Error(
-                "Constraint AASc-002: preferred name shall be provided at "
-                + "least in English."
-            )
-
-        for i, an_item in enumerate(that.preferred_name):
-            for error in self.transform(an_item):
-                error.path._prepend(IndexSegment(that.preferred_name, i))
-                error.path._prepend(PropertySegment(that, "preferred_name"))
-                yield error
-
-        if that.short_name is not None:
-            for i, another_item in enumerate(that.short_name):
-                for error in self.transform(another_item):
-                    error.path._prepend(IndexSegment(that.short_name, i))
-                    error.path._prepend(PropertySegment(that, "short_name"))
-                    yield error
-
-        if that.unit is not None:
-            for error in verify_non_empty_xml_serializable_string(that.unit):
-                error.path._prepend(PropertySegment(that, "unit"))
-                yield error
-
-        if that.unit_id is not None:
-            for error in self.transform(that.unit_id):
-                error.path._prepend(PropertySegment(that, "unit_id"))
-                yield error
-
-        if that.source_of_definition is not None:
-            for error in verify_non_empty_xml_serializable_string(
-                that.source_of_definition
-            ):
-                error.path._prepend(PropertySegment(that, "source_of_definition"))
-                yield error
-
-        if that.symbol is not None:
-            for error in verify_non_empty_xml_serializable_string(that.symbol):
-                error.path._prepend(PropertySegment(that, "symbol"))
-                yield error
-
-        if that.definition is not None:
-            for i, yet_another_item in enumerate(that.definition):
-                for error in self.transform(yet_another_item):
-                    error.path._prepend(IndexSegment(that.definition, i))
-                    error.path._prepend(PropertySegment(that, "definition"))
-                    yield error
-
-        if that.value_format is not None:
-            for error in verify_non_empty_xml_serializable_string(that.value_format):
-                error.path._prepend(PropertySegment(that, "value_format"))
-                yield error
-
-        if that.value_list is not None:
-            for error in self.transform(that.value_list):
-                error.path._prepend(PropertySegment(that, "value_list"))
-                yield error
-
-        if that.value is not None:
-            for error in verify_value_type_iec_61360(that.value):
-                error.path._prepend(PropertySegment(that, "value"))
-                yield error
-
-        if that.level_type is not None:
-            for error in self.transform(that.level_type):
-                error.path._prepend(PropertySegment(that, "level_type"))
-                yield error
-
-
-_TRANSFORMER = _Transformer()
-
-
-def verify(that: aas_types.Class) -> Iterator[Error]:
-    """
-    Verify the constraints of :paramref:`that` recursively.
-
-    :param that: instance whose constraints we want to verify
-    :yield: constraint violations
-    """
-    yield from _TRANSFORMER.transform(that)
-
-
-def verify_non_empty_xml_serializable_string(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xml_serializable_string(that):
-        yield Error(
-            "Constraint AASd-130: An attribute with data type 'string' "
-            + "shall consist of these characters only: "
-            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
-        )
-
-    if not (len(that) >= 1):
-        yield Error("The value must not be empty.")
-
-
-def verify_date_time_utc(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xs_date_time_utc(that):
-        yield Error(
-            "The value must match the pattern of xs:dateTime with "
-            + "the time zone fixed to UTC."
-        )
-
-    if not is_xs_date_time_utc(that):
-        yield Error(
-            "The value must represent a valid xs:dateTime with the time "
-            + "zone fixed to UTC."
-        )
-
-
-def verify_duration(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xs_duration(that):
-        yield Error("The value must match the pattern of xs:duration.")
-
-
-# noinspection PyUnusedLocal
-def verify_blob_type(that: bytes) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    # There is no verification specified.
-    return
-
-    # Empty generator according to:
-    # https://stackoverflow.com/a/13243870/1600678
-    # noinspection PyUnreachableCode
-    yield
-
-
-def verify_identifier(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xml_serializable_string(that):
-        yield Error(
-            "Constraint AASd-130: An attribute with data type 'string' "
-            + "shall consist of these characters only: "
-            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
-        )
-
-    if not (len(that) >= 1):
-        yield Error("The value must not be empty.")
-
-    if not (len(that) <= 2000):
-        yield Error("Identifier shall have a maximum length of 2000 characters.")
-
-
-def verify_value_type_iec_61360(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xml_serializable_string(that):
-        yield Error(
-            "Constraint AASd-130: An attribute with data type 'string' "
-            + "shall consist of these characters only: "
-            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
-        )
-
-    if not (len(that) >= 1):
-        yield Error("The value must not be empty.")
-
-    if not (len(that) <= 2000):
-        yield Error(
-            "Value type IEC 61360 shall have a maximum length of 2000 " + "characters."
-        )
-
-
-def verify_name_type(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xml_serializable_string(that):
-        yield Error(
-            "Constraint AASd-130: An attribute with data type 'string' "
-            + "shall consist of these characters only: "
-            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
-        )
-
-    if not (len(that) >= 1):
-        yield Error("The value must not be empty.")
-
-    if not (len(that) <= 128):
-        yield Error("Name type shall have a maximum length of 128 characters.")
-
-
-def verify_version_type(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xml_serializable_string(that):
-        yield Error(
-            "Constraint AASd-130: An attribute with data type 'string' "
-            + "shall consist of these characters only: "
-            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
-        )
-
-    if not (len(that) >= 1):
-        yield Error("The value must not be empty.")
-
-    if not matches_version_type(that):
-        yield Error("Version type shall match the version pattern.")
-
-    if not (len(that) <= 4):
-        yield Error("Version type shall have a maximum length of 4 characters.")
-
-
-def verify_revision_type(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xml_serializable_string(that):
-        yield Error(
-            "Constraint AASd-130: An attribute with data type 'string' "
-            + "shall consist of these characters only: "
-            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
-        )
-
-    if not (len(that) >= 1):
-        yield Error("The value must not be empty.")
-
-    if not matches_revision_type(that):
-        yield Error("Revision type shall match the revision pattern.")
-
-    if not (len(that) <= 4):
-        yield Error("Revision type shall have a maximum length of 4 characters.")
-
-
-def verify_label_type(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xml_serializable_string(that):
-        yield Error(
-            "Constraint AASd-130: An attribute with data type 'string' "
-            + "shall consist of these characters only: "
-            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
-        )
-
-    if not (len(that) >= 1):
-        yield Error("The value must not be empty.")
-
-    if not (len(that) <= 64):
-        yield Error("Label type shall have a maximum length of 64 characters.")
-
-
-def verify_message_topic_type(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xml_serializable_string(that):
-        yield Error(
-            "Constraint AASd-130: An attribute with data type 'string' "
-            + "shall consist of these characters only: "
-            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
-        )
-
-    if not (len(that) >= 1):
-        yield Error("The value must not be empty.")
-
-    if not (len(that) <= 255):
-        yield Error(
-            "Message topic type shall have a maximum length of 255 " + "characters."
-        )
-
-
-def verify_bcp_47_language_tag(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_bcp_47(that):
-        yield Error(
-            "The value must represent a value language tag conformant to " + "BCP 47."
-        )
-
-
-def verify_content_type(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xml_serializable_string(that):
-        yield Error(
-            "Constraint AASd-130: An attribute with data type 'string' "
-            + "shall consist of these characters only: "
-            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
-        )
-
-    if not (len(that) >= 1):
-        yield Error("The value must not be empty.")
-
-    if not (len(that) <= 100):
-        yield Error("Content type shall have a maximum length of 100 characters.")
-
-    if not matches_mime_type(that):
-        yield Error(
-            "The value must represent a valid content MIME type "
-            + "according to RFC 2046."
-        )
-
-
-def verify_path_type(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xml_serializable_string(that):
-        yield Error(
-            "Constraint AASd-130: An attribute with data type 'string' "
-            + "shall consist of these characters only: "
-            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
-        )
-
-    if not (len(that) >= 1):
-        yield Error("The value must not be empty.")
-
-    if not (len(that) <= 2000):
-        yield Error("Identifier shall have a maximum length of 2000 characters.")
-
-    if not matches_rfc_8089_path(that):
-        yield Error(
-            "The value must represent a valid file URI scheme according "
-            + "to RFC 8089."
-        )
-
-
-def verify_qualifier_type(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xml_serializable_string(that):
-        yield Error(
-            "Constraint AASd-130: An attribute with data type 'string' "
-            + "shall consist of these characters only: "
-            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
-        )
-
-    if not (len(that) >= 1):
-        yield Error("The value must not be empty.")
-
-    if not (len(that) <= 128):
-        yield Error("Name type shall have a maximum length of 128 characters.")
-
-
-# noinspection PyUnusedLocal
-def verify_value_data_type(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    # There is no verification specified.
-    return
-
-    # Empty generator according to:
-    # https://stackoverflow.com/a/13243870/1600678
-    # noinspection PyUnreachableCode
-    yield
-
-
-def verify_id_short_type(that: str) -> Iterator[Error]:
-    """Verify the constraints of :paramref:`that`."""
-    if not matches_xml_serializable_string(that):
-        yield Error(
-            "Constraint AASd-130: An attribute with data type 'string' "
-            + "shall consist of these characters only: "
-            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
-        )
-
-    if not (len(that) >= 1):
-        yield Error("The value must not be empty.")
-
-    if not (len(that) <= 128):
-        yield Error("Name type shall have a maximum length of 128 characters.")
-
-    if not matches_id_short(that):
-        yield Error(
-            "ID-short of Referables shall only feature letters, digits, "
-            + "underscore (``_``); starting mandatory with a letter. "
-            + "*I.e.* ``[a-zA-Z][a-zA-Z0-9_]*``."
-        )
-
-
-# This code has been automatically generated by aas-core-codegen.
-# Do NOT edit or append.
+"""
+Verify that the instances of the meta-model satisfy the invariants.
+
+Here is an example how to verify an instance of :py:class:`aas_core3.types.Extension`:
+
+.. code-block::
+
+    import aas_core3.types as aas_types
+    import aas_core3.verification as aas_verification
+
+    an_instance = aas_types.Extension(
+        # ... some constructor arguments ...
+    )
+
+    for error in aas_verification.verify(an_instance):
+        print(f"{error.cause} at: {error.path}")
+"""
+
+
+# This code has been automatically generated by aas-core-codegen.
+# Do NOT edit or append.
+
+
+import math
+import re
+import struct
+import sys
+from typing import (
+    Callable,
+    Iterable,
+    Iterator,
+    List,
+    Mapping,
+    Optional,
+    Pattern,
+    Sequence,
+    Set,
+    Union,
+)
+
+if sys.version_info >= (3, 8):
+    from typing import Final
+else:
+    from typing_extensions import Final
+
+from aas_core3 import (
+    constants as aas_constants,
+    types as aas_types,
+)
+
+
+class PropertySegment:
+    """Represent a property access on a path to an erroneous value."""
+
+    #: Instance containing the property
+    instance: Final[aas_types.Class]
+
+    #: Name of the property
+    name: Final[str]
+
+    def __init__(self, instance: aas_types.Class, name: str) -> None:
+        """Initialize with the given values."""
+        self.instance = instance
+        self.name = name
+
+    def __str__(self) -> str:
+        return f".{self.name}"
+
+
+class IndexSegment:
+    """Represent an index access on a path to an erroneous value."""
+
+    #: Sequence containing the item at :py:attr:`~index`
+    sequence: Final[Sequence[aas_types.Class]]
+
+    #: Index of the item
+    index: Final[int]
+
+    def __init__(self, sequence: Sequence[aas_types.Class], index: int) -> None:
+        """Initialize with the given values."""
+        self.sequence = sequence
+        self.index = index
+
+    def __str__(self) -> str:
+        return f"[{self.index}]"
+
+
+Segment = Union[PropertySegment, IndexSegment]
+
+
+class Path:
+    """Represent the relative path to the erroneous value."""
+
+    def __init__(self) -> None:
+        """Initialize as an empty path."""
+        self._segments = []  # type: List[Segment]
+
+    @property
+    def segments(self) -> Sequence[Segment]:
+        """Get the segments of the path."""
+        return self._segments
+
+    def _prepend(self, segment: Segment) -> None:
+        """Insert the :paramref:`segment` in front of other segments."""
+        self._segments.insert(0, segment)
+
+    def __str__(self) -> str:
+        return "".join(str(segment) for segment in self._segments)
+
+
+class Error:
+    """Represent a verification error in the data."""
+
+    #: Human-readable description of the error
+    cause: Final[str]
+
+    #: Path to the erroneous value
+    path: Final[Path]
+
+    def __init__(self, cause: str) -> None:
+        """Initialize as an error with an empty path."""
+        self.cause = cause
+        self.path = Path()
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_id_short() -> Pattern[str]:
+    pattern = "^[a-zA-Z][a-zA-Z0-9_]*$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_ID_SHORT = _construct_matches_id_short()
+
+
+def matches_id_short(text: str) -> bool:
+    """Check that :paramref:`text` is a valid short ID."""
+    return _REGEX_MATCHES_ID_SHORT.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_version_type() -> Pattern[str]:
+    pattern = "^(0|[1-9][0-9]*)$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_VERSION_TYPE = _construct_matches_version_type()
+
+
+def matches_version_type(text: str) -> bool:
+    """Check that :paramref:`text` is a valid version string."""
+    return _REGEX_MATCHES_VERSION_TYPE.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_revision_type() -> Pattern[str]:
+    pattern = "^(0|[1-9][0-9]*)$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_REVISION_TYPE = _construct_matches_revision_type()
+
+
+def matches_revision_type(text: str) -> bool:
+    """Check that :paramref:`text` is a valid revision string."""
+    return _REGEX_MATCHES_REVISION_TYPE.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_date_time_utc() -> Pattern[str]:
+    digit = "[0-9]"
+    year_frag = f"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))"
+    month_frag = "((0[1-9])|(1[0-2]))"
+    day_frag = f"((0[1-9])|([12]{digit})|(3[01]))"
+    hour_frag = f"(([01]{digit})|(2[0-3]))"
+    minute_frag = f"[0-5]{digit}"
+    second_frag = f"([0-5]{digit})(\\.{digit}+)?"
+    end_of_day_frag = "24:00:00(\\.0+)?"
+    timezone_frag = "(Z|\\+00:00|-00:00)"
+    date_time_lexical_rep = f"{year_frag}-{month_frag}-{day_frag}T(({hour_frag}:{minute_frag}:{second_frag})|{end_of_day_frag}){timezone_frag}"
+    pattern = f"^{date_time_lexical_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_DATE_TIME_UTC = _construct_matches_xs_date_time_utc()
+
+
+def matches_xs_date_time_utc(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:dateTime``.
+
+    The time zone must be fixed to UTC. We verify only that the ``text`` matches
+    a pre-defined pattern. We *do not* verify that the day of month is
+    correct nor do we check for leap seconds.
+
+    See: https://www.w3.org/TR/xmlschema-2/#dateTime
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_DATE_TIME_UTC.match(text) is not None
+
+
+def is_xs_date_time_utc(value: str) -> bool:
+    """
+    Check that :paramref:`value` is a ``xs:dateTime`` with
+    the time zone set to UTC.
+    """
+    if not matches_xs_date_time_utc(value):
+        return False
+
+    date, _ = value.split("T")
+    return is_xs_date(date)
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_mime_type() -> Pattern[str]:
+    tchar = "[!#$%&'*+\\-.^_`|~0-9a-zA-Z]"
+    token = f"({tchar})+"
+    type = f"{token}"
+    subtype = f"{token}"
+    ows = "[ \\t]*"
+    obs_text = "[\\x80-\\xff]"
+    qd_text = f"([\\t !#-\\[\\]-~]|{obs_text})"
+    quoted_pair = f"\\\\([\\t !-~]|{obs_text})"
+    quoted_string = f'"({qd_text}|{quoted_pair})*"'
+    parameter = f"{token}=({token}|{quoted_string})"
+    media_type = f"^{type}/{subtype}({ows};{ows}{parameter})*$"
+
+    return re.compile(media_type)
+
+
+_REGEX_MATCHES_MIME_TYPE = _construct_matches_mime_type()
+
+
+def matches_mime_type(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of MIME type.
+
+    The definition has been taken from:
+    https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1,
+    https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3 and
+    https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6.
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_MIME_TYPE.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_rfc_8089_path() -> Pattern[str]:
+    h16 = "[0-9A-Fa-f]{1,4}"
+    dec_octet = "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
+    ipv4address = f"{dec_octet}\\.{dec_octet}\\.{dec_octet}\\.{dec_octet}"
+    ls32 = f"({h16}:{h16}|{ipv4address})"
+    ipv6address = f"(({h16}:){{6}}{ls32}|::({h16}:){{5}}{ls32}|({h16})?::({h16}:){{4}}{ls32}|(({h16}:)?{h16})?::({h16}:){{3}}{ls32}|(({h16}:){{2}}{h16})?::({h16}:){{2}}{ls32}|(({h16}:){{3}}{h16})?::{h16}:{ls32}|(({h16}:){{4}}{h16})?::{ls32}|(({h16}:){{5}}{h16})?::{h16}|(({h16}:){{6}}{h16})?::)"
+    unreserved = "[a-zA-Z0-9\\-._~]"
+    sub_delims = "[!$&'()*+,;=]"
+    ipvfuture = f"[vV][0-9A-Fa-f]+\\.({unreserved}|{sub_delims}|:)+"
+    ip_literal = f"\\[({ipv6address}|{ipvfuture})\\]"
+    pct_encoded = "%[0-9A-Fa-f][0-9A-Fa-f]"
+    reg_name = f"({unreserved}|{pct_encoded}|{sub_delims})*"
+    host = f"({ip_literal}|{ipv4address}|{reg_name})"
+    file_auth = f"(localhost|{host})"
+    pchar = f"({unreserved}|{pct_encoded}|{sub_delims}|[:@])"
+    segment_nz = f"({pchar})+"
+    segment = f"({pchar})*"
+    path_absolute = f"/({segment_nz}(/{segment})*)?"
+    auth_path = f"({file_auth})?{path_absolute}"
+    local_path = f"{path_absolute}"
+    file_hier_part = f"(//{auth_path}|{local_path})"
+    file_scheme = "file"
+    file_uri = f"{file_scheme}:{file_hier_part}"
+    pattern = f"^{file_uri}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_RFC_8089_PATH = _construct_matches_rfc_8089_path()
+
+
+def matches_rfc_8089_path(text: str) -> bool:
+    """
+    Check that :paramref:`text` is a path conforming to the pattern of RFC 8089.
+
+    The definition has been taken from:
+    https://datatracker.ietf.org/doc/html/rfc8089
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_RFC_8089_PATH.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_bcp_47() -> Pattern[str]:
+    alphanum = "[a-zA-Z0-9]"
+    singleton = "[0-9A-WY-Za-wy-z]"
+    extension = f"{singleton}(-({alphanum}){{2,8}})+"
+    extlang = "[a-zA-Z]{3}(-[a-zA-Z]{3}){2}"
+    irregular = "(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)"
+    regular = "(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)"
+    grandfathered = f"({irregular}|{regular})"
+    language = f"([a-zA-Z]{{2,3}}(-{extlang})?|[a-zA-Z]{{4}}|[a-zA-Z]{{5,8}})"
+    script = "[a-zA-Z]{4}"
+    region = "([a-zA-Z]{2}|[0-9]{3})"
+    variant = f"(({alphanum}){{5,8}}|[0-9]({alphanum}){{3}})"
+    privateuse = f"[xX](-({alphanum}){{1,8}})+"
+    langtag = f"{language}(-{script})?(-{region})?(-{variant})*(-{extension})*(-{privateuse})?"
+    language_tag = f"({langtag}|{privateuse}|{grandfathered})"
+    pattern = f"^{language_tag}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_BCP_47 = _construct_matches_bcp_47()
+
+
+def matches_bcp_47(text: str) -> bool:
+    """
+    Check that :paramref:`text` is a valid BCP 47 language tag.
+
+    See: https://en.wikipedia.org/wiki/IETF_language_tag
+    """
+    return _REGEX_MATCHES_BCP_47.match(text) is not None
+
+
+def lang_strings_have_unique_languages(
+    lang_strings: Iterable[aas_types.AbstractLangString],
+) -> bool:
+    """
+    Check that :paramref:`lang_strings` are specified each for a unique
+    language.
+    """
+    language_set = set()  # type: Set[str]
+    for lang_string in lang_strings:
+        if lang_string.language in language_set:
+            return False
+
+        language_set.add(lang_string.language)
+
+    return True
+
+
+def qualifier_types_are_unique(qualifiers: Iterable[aas_types.Qualifier]) -> bool:
+    """
+    Check that there are no duplicate
+    :py:attr:`.types.Qualifier.type`'s
+    in the :paramref:`qualifiers`.
+    """
+    type_set = set()  # type: Set[str]
+    for qualifier in qualifiers:
+        if qualifier.type in type_set:
+            return False
+
+        type_set.add(qualifier.type)
+
+    return True
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xml_serializable_string() -> Pattern[str]:
+    pattern = "^[\\x09\\x0a\\x0d\\x20-\\ud7ff\\ue000-\\ufffd\\U00010000-\\U0010ffff]*$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XML_SERIALIZABLE_STRING = _construct_matches_xml_serializable_string()
+
+
+def matches_xml_serializable_string(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of the Constraint AASd-130.
+
+    Ensures that encoding is possible and interoperability between different
+    serializations is possible.
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XML_SERIALIZABLE_STRING.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_any_uri() -> Pattern[str]:
+    scheme = "[a-zA-Z][a-zA-Z0-9+\\-.]*"
+    ucschar = "[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd]"
+    iunreserved = f"([a-zA-Z0-9\\-._~]|{ucschar})"
+    pct_encoded = "%[0-9A-Fa-f][0-9A-Fa-f]"
+    sub_delims = "[!$&'()*+,;=]"
+    iuserinfo = f"({iunreserved}|{pct_encoded}|{sub_delims}|:)*"
+    h16 = "[0-9A-Fa-f]{1,4}"
+    dec_octet = "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
+    ipv4address = f"{dec_octet}\\.{dec_octet}\\.{dec_octet}\\.{dec_octet}"
+    ls32 = f"({h16}:{h16}|{ipv4address})"
+    ipv6address = f"(({h16}:){{6}}{ls32}|::({h16}:){{5}}{ls32}|({h16})?::({h16}:){{4}}{ls32}|(({h16}:)?{h16})?::({h16}:){{3}}{ls32}|(({h16}:){{2}}{h16})?::({h16}:){{2}}{ls32}|(({h16}:){{3}}{h16})?::{h16}:{ls32}|(({h16}:){{4}}{h16})?::{ls32}|(({h16}:){{5}}{h16})?::{h16}|(({h16}:){{6}}{h16})?::)"
+    unreserved = "[a-zA-Z0-9\\-._~]"
+    ipvfuture = f"[vV][0-9A-Fa-f]+\\.({unreserved}|{sub_delims}|:)+"
+    ip_literal = f"\\[({ipv6address}|{ipvfuture})\\]"
+    ireg_name = f"({iunreserved}|{pct_encoded}|{sub_delims})*"
+    ihost = f"({ip_literal}|{ipv4address}|{ireg_name})"
+    port = "[0-9]*"
+    iauthority = f"({iuserinfo}@)?{ihost}(:{port})?"
+    ipchar = f"({iunreserved}|{pct_encoded}|{sub_delims}|[:@])"
+    isegment = f"({ipchar})*"
+    ipath_abempty = f"(/{isegment})*"
+    isegment_nz = f"({ipchar})+"
+    ipath_absolute = f"/({isegment_nz}(/{isegment})*)?"
+    ipath_rootless = f"{isegment_nz}(/{isegment})*"
+    ipath_empty = f"({ipchar}){{0}}"
+    ihier_part = f"(//{iauthority}{ipath_abempty}|{ipath_absolute}|{ipath_rootless}|{ipath_empty})"
+    iprivate = "[\\ue000-\\uf8ff\\U000f0000-\\U000ffffd\\U00100000-\\U0010fffd]"
+    iquery = f"({ipchar}|{iprivate}|[/?])*"
+    ifragment = f"({ipchar}|[/?])*"
+    isegment_nz_nc = f"({iunreserved}|{pct_encoded}|{sub_delims}|@)+"
+    ipath_noscheme = f"{isegment_nz_nc}(/{isegment})*"
+    irelative_part = f"(//{iauthority}{ipath_abempty}|{ipath_absolute}|{ipath_noscheme}|{ipath_empty})"
+    irelative_ref = f"{irelative_part}(\\?{iquery})?(#{ifragment})?"
+    iri = f"{scheme}:{ihier_part}(\\?{iquery})?(#{ifragment})?"
+    iri_reference = f"({iri}|{irelative_ref})"
+    pattern = f"^{iri_reference}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_ANY_URI = _construct_matches_xs_any_uri()
+
+
+def matches_xs_any_uri(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:anyURI``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#anyURI and
+    https://datatracker.ietf.org/doc/html/rfc3987
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_ANY_URI.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_base_64_binary() -> Pattern[str]:
+    b04_char = "[AQgw]"
+    b04 = f"{b04_char}\\x20?"
+    b16_char = "[AEIMQUYcgkosw048]"
+    b16 = f"{b16_char}\\x20?"
+    b64_char = "[A-Za-z0-9+/]"
+    b64 = f"{b64_char}\\x20?"
+    b64quad = f"({b64}{b64}{b64}{b64})"
+    b64_final_quad = f"({b64}{b64}{b64}{b64_char})"
+    padded_8 = f"{b64}{b04}= ?="
+    padded_16 = f"{b64}{b64}{b16}="
+    b64final = f"({b64_final_quad}|{padded_16}|{padded_8})"
+    base64_binary = f"({b64quad}*{b64final})?"
+    pattern = f"^{base64_binary}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_BASE_64_BINARY = _construct_matches_xs_base_64_binary()
+
+
+def matches_xs_base_64_binary(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:base64Binary``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#base64Binary
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_BASE_64_BINARY.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_boolean() -> Pattern[str]:
+    pattern = "^(true|false|1|0)$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_BOOLEAN = _construct_matches_xs_boolean()
+
+
+def matches_xs_boolean(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:boolean``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#boolean
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_BOOLEAN.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_date() -> Pattern[str]:
+    digit = "[0-9]"
+    year_frag = f"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))"
+    month_frag = "((0[1-9])|(1[0-2]))"
+    day_frag = f"((0[1-9])|([12]{digit})|(3[01]))"
+    minute_frag = f"[0-5]{digit}"
+    timezone_frag = f"(Z|(\\+|-)(0{digit}|1[0-3]):{minute_frag}|14:00)"
+    date_lexical_rep = f"{year_frag}-{month_frag}-{day_frag}{timezone_frag}?"
+    pattern = f"^{date_lexical_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_DATE = _construct_matches_xs_date()
+
+
+def matches_xs_date(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:date``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#date
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_DATE.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_date_time() -> Pattern[str]:
+    digit = "[0-9]"
+    year_frag = f"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))"
+    month_frag = "((0[1-9])|(1[0-2]))"
+    day_frag = f"((0[1-9])|([12]{digit})|(3[01]))"
+    hour_frag = f"(([01]{digit})|(2[0-3]))"
+    minute_frag = f"[0-5]{digit}"
+    second_frag = f"([0-5]{digit})(\\.{digit}+)?"
+    end_of_day_frag = "24:00:00(\\.0+)?"
+    timezone_frag = f"(Z|(\\+|-)(0{digit}|1[0-3]):{minute_frag}|14:00)"
+    date_time_lexical_rep = f"{year_frag}-{month_frag}-{day_frag}T(({hour_frag}:{minute_frag}:{second_frag})|{end_of_day_frag}){timezone_frag}?"
+    pattern = f"^{date_time_lexical_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_DATE_TIME = _construct_matches_xs_date_time()
+
+
+def matches_xs_date_time(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:dateTime``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#dateTime
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_DATE_TIME.match(text) is not None
+
+
+def is_xs_date_time(value: str) -> bool:
+    """
+    Check that :paramref:`value` is a ``xs:dateTime`` with
+    the time zone set to UTC.
+    """
+    if not matches_xs_date_time(value):
+        return False
+
+    date, _ = value.split("T")
+    return is_xs_date(date)
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_decimal() -> Pattern[str]:
+    digit = "[0-9]"
+    unsigned_no_decimal_pt_numeral = f"{digit}+"
+    no_decimal_pt_numeral = f"(\\+|-)?{unsigned_no_decimal_pt_numeral}"
+    frac_frag = f"{digit}+"
+    unsigned_decimal_pt_numeral = (
+        f"({unsigned_no_decimal_pt_numeral}\\.{frac_frag}|\\.{frac_frag})"
+    )
+    decimal_pt_numeral = f"(\\+|-)?{unsigned_decimal_pt_numeral}"
+    decimal_lexical_rep = f"({decimal_pt_numeral}|{no_decimal_pt_numeral})"
+    pattern = f"^{decimal_lexical_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_DECIMAL = _construct_matches_xs_decimal()
+
+
+def matches_xs_decimal(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:decimal``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#decimal
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_DECIMAL.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_double() -> Pattern[str]:
+    double_rep = (
+        "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)"
+    )
+    pattern = f"^{double_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_DOUBLE = _construct_matches_xs_double()
+
+
+def matches_xs_double(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:double``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#double
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_DOUBLE.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_duration() -> Pattern[str]:
+    duration_rep = "-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))"
+    pattern = f"^{duration_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_DURATION = _construct_matches_xs_duration()
+
+
+def matches_xs_duration(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:duration``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#duration
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_DURATION.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_float() -> Pattern[str]:
+    float_rep = (
+        "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)"
+    )
+    pattern = f"^{float_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_FLOAT = _construct_matches_xs_float()
+
+
+def matches_xs_float(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:float``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#float
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_FLOAT.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_g_day() -> Pattern[str]:
+    g_day_lexical_rep = (
+        "---(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
+    )
+    pattern = f"^{g_day_lexical_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_G_DAY = _construct_matches_xs_g_day()
+
+
+def matches_xs_g_day(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:gDay``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#gDay
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_G_DAY.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_g_month() -> Pattern[str]:
+    g_month_lexical_rep = (
+        "--(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
+    )
+    pattern = f"^{g_month_lexical_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_G_MONTH = _construct_matches_xs_g_month()
+
+
+def matches_xs_g_month(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:gMonth``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#gMonth
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_G_MONTH.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_g_month_day() -> Pattern[str]:
+    g_month_day_rep = "--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
+    pattern = f"^{g_month_day_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_G_MONTH_DAY = _construct_matches_xs_g_month_day()
+
+
+def matches_xs_g_month_day(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:gMonthDay``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#gMonthDay
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_G_MONTH_DAY.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_g_year() -> Pattern[str]:
+    g_year_rep = (
+        "-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
+    )
+    pattern = f"^{g_year_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_G_YEAR = _construct_matches_xs_g_year()
+
+
+def matches_xs_g_year(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:gYear``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#gYear
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_G_YEAR.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_g_year_month() -> Pattern[str]:
+    g_year_month_rep = "-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
+    pattern = f"^{g_year_month_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_G_YEAR_MONTH = _construct_matches_xs_g_year_month()
+
+
+def matches_xs_g_year_month(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:gYearMonth``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#gYearMonth
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_G_YEAR_MONTH.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_hex_binary() -> Pattern[str]:
+    hex_binary = "([0-9a-fA-F]{2})*"
+    pattern = f"^{hex_binary}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_HEX_BINARY = _construct_matches_xs_hex_binary()
+
+
+def matches_xs_hex_binary(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:hexBinary``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#hexBinary
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_HEX_BINARY.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_time() -> Pattern[str]:
+    time_rep = "(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?|(24:00:00(\\.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
+    pattern = f"^{time_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_TIME = _construct_matches_xs_time()
+
+
+def matches_xs_time(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:time``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#time
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_TIME.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_integer() -> Pattern[str]:
+    integer_rep = "[-+]?[0-9]+"
+    pattern = f"^{integer_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_INTEGER = _construct_matches_xs_integer()
+
+
+def matches_xs_integer(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:integer``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#integer
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_INTEGER.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_long() -> Pattern[str]:
+    long_rep = "[-+]?0*[0-9]{1,20}"
+    pattern = f"^{long_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_LONG = _construct_matches_xs_long()
+
+
+def matches_xs_long(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:long``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#long
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_LONG.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_int() -> Pattern[str]:
+    int_rep = "[-+]?0*[0-9]{1,10}"
+    pattern = f"^{int_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_INT = _construct_matches_xs_int()
+
+
+def matches_xs_int(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:int``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#int
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_INT.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_short() -> Pattern[str]:
+    short_rep = "[-+]?0*[0-9]{1,5}"
+    pattern = f"^{short_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_SHORT = _construct_matches_xs_short()
+
+
+def matches_xs_short(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:short``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#short
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_SHORT.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_byte() -> Pattern[str]:
+    byte_rep = "[-+]?0*[0-9]{1,3}"
+    pattern = f"^{byte_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_BYTE = _construct_matches_xs_byte()
+
+
+def matches_xs_byte(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:byte``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#byte
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_BYTE.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_non_negative_integer() -> Pattern[str]:
+    non_negative_integer_rep = "(-0|\\+?[0-9]+)"
+    pattern = f"^{non_negative_integer_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_NON_NEGATIVE_INTEGER = _construct_matches_xs_non_negative_integer()
+
+
+def matches_xs_non_negative_integer(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:nonNegativeInteger``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#nonNegativeInteger
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_NON_NEGATIVE_INTEGER.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_positive_integer() -> Pattern[str]:
+    positive_integer_rep = "\\+?0*[1-9][0-9]*"
+    pattern = f"^{positive_integer_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_POSITIVE_INTEGER = _construct_matches_xs_positive_integer()
+
+
+def matches_xs_positive_integer(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:positiveInteger``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#positiveInteger
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_POSITIVE_INTEGER.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_unsigned_long() -> Pattern[str]:
+    unsigned_long_rep = "(-0|\\+?0*[0-9]{1,20})"
+    pattern = f"^{unsigned_long_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_UNSIGNED_LONG = _construct_matches_xs_unsigned_long()
+
+
+def matches_xs_unsigned_long(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:unsignedLong``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#unsignedLong
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_UNSIGNED_LONG.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_unsigned_int() -> Pattern[str]:
+    unsigned_int_rep = "(-0|\\+?0*[0-9]{1,10})"
+    pattern = f"^{unsigned_int_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_UNSIGNED_INT = _construct_matches_xs_unsigned_int()
+
+
+def matches_xs_unsigned_int(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:unsignedInt``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#unsignedInt
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_UNSIGNED_INT.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_unsigned_short() -> Pattern[str]:
+    unsigned_short_rep = "(-0|\\+?0*[0-9]{1,5})"
+    pattern = f"^{unsigned_short_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_UNSIGNED_SHORT = _construct_matches_xs_unsigned_short()
+
+
+def matches_xs_unsigned_short(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:unsignedShort``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#unsignedShort
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_UNSIGNED_SHORT.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_unsigned_byte() -> Pattern[str]:
+    unsigned_byte_rep = "(-0|\\+?0*[0-9]{1,3})"
+    pattern = f"^{unsigned_byte_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_UNSIGNED_BYTE = _construct_matches_xs_unsigned_byte()
+
+
+def matches_xs_unsigned_byte(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:unsignedByte``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#unsignedByte
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_UNSIGNED_BYTE.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_non_positive_integer() -> Pattern[str]:
+    non_positive_integer_rep = "(\\+0|0|-[0-9]+)"
+    pattern = f"^{non_positive_integer_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_NON_POSITIVE_INTEGER = _construct_matches_xs_non_positive_integer()
+
+
+def matches_xs_non_positive_integer(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:nonPositiveInteger``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#nonPositiveInteger
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_NON_POSITIVE_INTEGER.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_negative_integer() -> Pattern[str]:
+    negative_integer_rep = "(-0*[1-9][0-9]*)"
+    pattern = f"^{negative_integer_rep}$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_NEGATIVE_INTEGER = _construct_matches_xs_negative_integer()
+
+
+def matches_xs_negative_integer(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:negativeInteger``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#negativeInteger
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_NEGATIVE_INTEGER.match(text) is not None
+
+
+# noinspection SpellCheckingInspection
+def _construct_matches_xs_string() -> Pattern[str]:
+    pattern = "^[\\x09\\x0a\\x0d\\x20-\\ud7ff\\ue000-\\ufffd\\U00010000-\\U0010ffff]*$"
+
+    return re.compile(pattern)
+
+
+_REGEX_MATCHES_XS_STRING = _construct_matches_xs_string()
+
+
+def matches_xs_string(text: str) -> bool:
+    """
+    Check that :paramref:`text` conforms to the pattern of an ``xs:string``.
+
+    See: https://www.w3.org/TR/xmlschema-2/#string
+
+    :param text: Text to be checked
+    :return:
+        True if the :paramref:`text` conforms to the pattern
+    """
+    return _REGEX_MATCHES_XS_STRING.match(text) is not None
+
+
+def _is_leap_year(year: int) -> bool:
+    """
+    Check if :paramref:`year` is a leap year.
+
+    >>> _is_leap_year(2016)
+    True
+
+    >>> _is_leap_year(1700)
+    False
+
+    >>> _is_leap_year(1600)
+    True
+
+    >>> _is_leap_year(2000)
+    True
+    """
+    # We consider the years B.C. to be one-off.
+    #
+    # See the note at: https://www.w3.org/TR/xmlschema-2/#dateTime:
+    # "'-0001' is the lexical representation of the year 1 Before Common Era
+    # (1 BCE, sometimes written "1 BC")."
+    #
+    # Hence, -1 year in XML is 1 BCE, which is 0 year in astronomical years.
+    if year < 0:
+        year = abs(year) - 1
+
+    # See: https://en.wikipedia.org/wiki/Leap_year#Algorithm
+    if year % 4 > 0:
+        return False
+
+    if year % 100 > 0:
+        return True
+
+    if year % 400 > 0:
+        return False
+
+    return True
+
+
+_DAYS_IN_MONTH: Mapping[int, int] = {
+    1: 31,
+    # Please use _is_leap_year if you need to check
+    # whether a concrete February has 28 or 29 days.
+    2: 29,
+    3: 31,
+    4: 30,
+    5: 31,
+    6: 30,
+    7: 31,
+    8: 31,
+    9: 30,
+    10: 31,
+    11: 30,
+    12: 31,
+}
+
+
+_DATE_PREFIX_RE = re.compile(r"^(-?[0-9]+)-([0-9]{2})-([0-9]{2})")
+
+
+def is_xs_date(value: str) -> bool:
+    """Check that :paramref:`value` is a valid ``xs:date``."""
+    if not matches_xs_date(value):
+        return False
+
+    # NOTE (mristin, 2022-11-23):
+    # We can not use :py:func:`datetime.datetime.strptime` as it does not
+    # handle years below 1000 correctly on Windows (*e.g.*, ``-999-01-01``).
+
+    # NOTE (mristin, 2022-10-30):
+    # We need to match the prefix as zone offsets are allowed in the dates. Optimally,
+    # we would re-use the pattern matching from :py:func`matches_xs_date`, but this
+    # would make the code generation and constraint inference for schemas much more
+    # difficult. Hence, we sacrifice the efficiency a bit for the clearer code & code
+    # generation.
+    match = _DATE_PREFIX_RE.match(value)
+    assert match is not None
+
+    year = int(match.group(1))
+    month = int(match.group(2))
+    day = int(match.group(3))
+
+    # We do not accept year zero,
+    # see the note at: https://www.w3.org/TR/xmlschema-2/#dateTime
+    if year == 0:
+        return False
+
+    if day <= 0:
+        return False
+
+    if month <= 0 or month >= 13:
+        return False
+
+    if month == 2:
+        max_days = 29 if _is_leap_year(year) else 28
+    else:
+        max_days = _DAYS_IN_MONTH[month]
+
+    if day > max_days:
+        return False
+
+    return True
+
+
+def is_xs_double(value: str) -> bool:
+    """Check that :paramref:`value` is a valid ``xs:double``."""
+    # We need to check explicitly for the regular expression since
+    # ``float(.)`` is too permissive. For example,
+    # it accepts "nan" although only "NaN" is valid.
+    # See: https://www.w3.org/TR/xmlschema-2/#double
+    if not matches_xs_double(value):
+        return False
+
+    converted = float(value)
+
+    # Check that the value is either "INF" or "-INF".
+    # Otherwise, the value is a decimal which is too big
+    # to be represented as a double-precision floating point
+    # number.
+    #
+    # Python simply rounds up/down to ``INF`` and ``-INF``,
+    # respectively, if the number is too large.
+    # For example: ``float("1e400") == math.inf``
+    if math.isinf(converted) and value != "INF" and value != "-INF":
+        return False
+
+    return True
+
+
+def is_xs_float(value: str) -> bool:
+    """Check that :paramref:`value` is a valid ``xs:float``."""
+    # We need to check explicitly for the regular expression since
+    # ``float(.)`` is too permissive. For example,
+    # it accepts "nan" although only "NaN" is valid.
+    # See: https://www.w3.org/TR/xmlschema-2/#double
+    if not matches_xs_float(value):
+        return False
+
+    converted = float(value)
+
+    # Check that the value is either "INF" or "-INF".
+    # Otherwise, the value is a decimal which is too big
+    # to be represented as a single-precision floating point
+    # number.
+    #
+    # Python simply rounds up/down to ``INF`` and ``-INF``,
+    # respectively, if the number is too large.
+    # For example: ``float("1e400") == math.inf``
+    if math.isinf(converted) and value != "INF" and value != "-INF":
+        return False
+
+    # Python uses double-precision floating point numbers. Since
+    # we check for a single-precision one, we have to explicitly
+    # see if the number is within a range of a single-precision
+    # floating point numbers.
+    try:
+        _ = struct.pack(">f", converted)
+    except OverflowError:
+        return False
+
+    return True
+
+
+def is_xs_g_month_day(value: str) -> bool:
+    """Check that :paramref:`value` is a valid ``xs:gMonthDay``."""
+    if not matches_xs_g_month_day(value):
+        return False
+
+    month = int(value[2:4])
+    day = int(value[5:7])
+
+    max_days = _DAYS_IN_MONTH[month]
+    return day <= max_days
+
+
+def is_xs_long(value: str) -> bool:
+    """Check that :paramref:`value` is a valid ``xs:long``."""
+    if not matches_xs_long(value):
+        return False
+
+    converted = int(value)
+    return -9223372036854775808 <= converted <= 9223372036854775807
+
+
+def is_xs_int(value: str) -> bool:
+    """Check that :paramref:`value` is a valid ``xs:int``."""
+    if not matches_xs_int(value):
+        return False
+
+    converted = int(value)
+    return -2147483648 <= converted <= 2147483647
+
+
+def is_xs_short(value: str) -> bool:
+    """Check that :paramref:`value` is a valid ``xs:short``."""
+    if not matches_xs_short(value):
+        return False
+
+    converted = int(value)
+    return -32768 <= converted <= 32767
+
+
+def is_xs_byte(value: str) -> bool:
+    """Check that :paramref:`value` is a valid ``xs:byte``."""
+    if not matches_xs_byte(value):
+        return False
+
+    converted = int(value)
+    return -128 <= converted <= 127
+
+
+def is_xs_unsigned_long(value: str) -> bool:
+    """Check that :paramref:`value` is a valid ``xs:unsignedLong``."""
+    if not matches_xs_unsigned_long(value):
+        return False
+
+    converted = int(value)
+    return 0 <= converted <= 18446744073709551615
+
+
+def is_xs_unsigned_int(value: str) -> bool:
+    """Check that :paramref:`value` is a valid ``xs:unsignedInt``."""
+    if not matches_xs_unsigned_int(value):
+        return False
+
+    converted = int(value)
+    return 0 <= converted <= 4294967295
+
+
+def is_xs_unsigned_short(value: str) -> bool:
+    """Check that :paramref:`value` is a valid ``xs:unsignedShort``."""
+    if not matches_xs_unsigned_short(value):
+        return False
+
+    converted = int(value)
+    return 0 <= converted <= 65535
+
+
+def is_xs_unsigned_byte(value: str) -> bool:
+    """Check that :paramref:`value` is a valid ``xs:unsignedByte``."""
+    if not matches_xs_unsigned_byte(value):
+        return False
+
+    converted = int(value)
+    return 0 <= converted <= 255
+
+
+_DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY: Mapping[
+    aas_types.DataTypeDefXSD, Callable[[str], bool]
+] = {
+    aas_types.DataTypeDefXSD.ANY_URI: matches_xs_any_uri,
+    aas_types.DataTypeDefXSD.BASE_64_BINARY: matches_xs_base_64_binary,
+    aas_types.DataTypeDefXSD.BOOLEAN: matches_xs_boolean,
+    aas_types.DataTypeDefXSD.BYTE: is_xs_byte,
+    aas_types.DataTypeDefXSD.DATE: is_xs_date,
+    aas_types.DataTypeDefXSD.DATE_TIME: is_xs_date_time,
+    aas_types.DataTypeDefXSD.DECIMAL: matches_xs_decimal,
+    aas_types.DataTypeDefXSD.DOUBLE: is_xs_double,
+    aas_types.DataTypeDefXSD.DURATION: matches_xs_duration,
+    aas_types.DataTypeDefXSD.FLOAT: is_xs_float,
+    aas_types.DataTypeDefXSD.G_DAY: matches_xs_g_day,
+    aas_types.DataTypeDefXSD.G_MONTH: matches_xs_g_month,
+    aas_types.DataTypeDefXSD.G_MONTH_DAY: is_xs_g_month_day,
+    aas_types.DataTypeDefXSD.G_YEAR: matches_xs_g_year,
+    aas_types.DataTypeDefXSD.G_YEAR_MONTH: matches_xs_g_year_month,
+    aas_types.DataTypeDefXSD.HEX_BINARY: matches_xs_hex_binary,
+    aas_types.DataTypeDefXSD.INT: is_xs_int,
+    aas_types.DataTypeDefXSD.INTEGER: matches_xs_integer,
+    aas_types.DataTypeDefXSD.LONG: is_xs_long,
+    aas_types.DataTypeDefXSD.NEGATIVE_INTEGER: matches_xs_negative_integer,
+    aas_types.DataTypeDefXSD.NON_NEGATIVE_INTEGER: matches_xs_non_negative_integer,
+    aas_types.DataTypeDefXSD.NON_POSITIVE_INTEGER: matches_xs_non_positive_integer,
+    aas_types.DataTypeDefXSD.POSITIVE_INTEGER: matches_xs_positive_integer,
+    aas_types.DataTypeDefXSD.SHORT: is_xs_short,
+    aas_types.DataTypeDefXSD.STRING: matches_xs_string,
+    aas_types.DataTypeDefXSD.TIME: matches_xs_time,
+    aas_types.DataTypeDefXSD.UNSIGNED_BYTE: is_xs_unsigned_byte,
+    aas_types.DataTypeDefXSD.UNSIGNED_INT: is_xs_unsigned_int,
+    aas_types.DataTypeDefXSD.UNSIGNED_LONG: is_xs_unsigned_long,
+    aas_types.DataTypeDefXSD.UNSIGNED_SHORT: is_xs_unsigned_short,
+}
+assert all(
+    data_type_def_xsd in _DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY
+    for data_type_def_xsd in aas_types.DataTypeDefXSD
+)
+
+
+def value_consistent_with_xsd_type(
+    value: str, value_type: aas_types.DataTypeDefXSD
+) -> bool:
+    """
+    Check that :paramref:`value` is consistent with the given
+    :paramref:`value_type`.
+    """
+    return _DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY[value_type](value)
+
+
+def is_model_reference_to(
+    reference: aas_types.Reference, expected_type: aas_types.KeyTypes
+) -> bool:
+    """
+    Check that the target of the model reference matches the :paramref:`expected_type`.
+    """
+    # pylint: disable=all
+    return (
+        reference.type == aas_types.ReferenceTypes.MODEL_REFERENCE
+        and len(reference.keys) != 0
+        and reference.keys[-1].type == expected_type
+    )
+
+
+def is_model_reference_to_referable(reference: aas_types.Reference) -> bool:
+    """
+    Check that the target of the reference matches a :py:attr:`.constants.AAS_REFERABLES`.
+    """
+    # pylint: disable=all
+    return (
+        reference.type == aas_types.ReferenceTypes.MODEL_REFERENCE
+        and len(reference.keys) != 0
+        and (reference.keys[-1].type in aas_constants.AAS_REFERABLES)
+    )
+
+
+def id_shorts_are_unique(referables: Iterable[aas_types.Referable]) -> bool:
+    """
+    Check that all :py:attr:`.types.Referable.id_short` are unique
+    among :paramref:`referables`.
+    """
+    id_short_set = set()  # type: Set[str]
+    for referable in referables:
+        if referable.id_short in id_short_set:
+            return False
+
+        if referable.id_short is not None:
+            id_short_set.add(referable.id_short)
+
+    return True
+
+
+def id_shorts_of_variables_are_unique(
+    input_variables: Optional[List[aas_types.OperationVariable]],
+    output_variables: Optional[List[aas_types.OperationVariable]],
+    inoutput_variables: Optional[List[aas_types.OperationVariable]],
+) -> bool:
+    """
+    Check that the :py:attr:`.types.Referable.id_short`'s among all the
+    :paramref:`input_variables`, :paramref:`output_variables`
+    and :paramref:`inoutput_variables` are unique.
+    """
+    id_short_set = set()
+    if input_variables is not None:
+        for variable in input_variables:
+            if variable.value.id_short is not None:
+                if variable.value.id_short in id_short_set:
+                    return False
+
+                id_short_set.add(variable.value.id_short)
+    if output_variables is not None:
+        for variable in output_variables:
+            if variable.value.id_short is not None:
+                if variable.value.id_short in id_short_set:
+                    return False
+
+                id_short_set.add(variable.value.id_short)
+    if inoutput_variables is not None:
+        for variable in inoutput_variables:
+            if variable.value.id_short is not None:
+                if variable.value.id_short in id_short_set:
+                    return False
+
+                id_short_set.add(variable.value.id_short)
+    return True
+
+
+def extension_names_are_unique(extensions: Iterable[aas_types.Extension]) -> bool:
+    """
+    Check that all :py:attr:`.types.Extension.name` are unique
+    among :paramref:`extensions`.
+    """
+    name_set = set()  # type: Set[str]
+    for extension in extensions:
+        if extension.name in name_set:
+            return False
+
+        name_set.add(extension.name)
+
+    return True
+
+
+def submodel_elements_have_identical_semantic_ids(
+    elements: Iterable[aas_types.SubmodelElement],
+) -> bool:
+    """
+    Check that all :paramref:`elements` have the identical
+    :py:attr:`.types.HasSemantics.semantic_id`.
+    """
+    that_semantic_id = None  # type: Optional[aas_types.Reference]
+
+    for element in elements:
+        if element.semantic_id is None:
+            continue
+
+        if that_semantic_id is None:
+            that_semantic_id = element.semantic_id
+            continue
+
+        this_semantic_id = element.semantic_id
+
+        if len(that_semantic_id.keys) != len(this_semantic_id.keys):
+            return False
+
+        for this_key, that_key in zip(this_semantic_id.keys, that_semantic_id.keys):
+            if this_key.value != that_key.value:
+                return False
+
+    return True
+
+
+# fmt: off
+_AAS_SUBMODEL_ELEMENTS_TO_TYPE: Mapping[
+    aas_types.AASSubmodelElements,
+    type
+] = {
+    aas_types.AASSubmodelElements.ANNOTATED_RELATIONSHIP_ELEMENT:
+        aas_types.AnnotatedRelationshipElement,
+
+    aas_types.AASSubmodelElements.BASIC_EVENT_ELEMENT:
+        aas_types.BasicEventElement,
+
+    aas_types.AASSubmodelElements.BLOB:
+        aas_types.Blob,
+
+    aas_types.AASSubmodelElements.CAPABILITY:
+        aas_types.Capability,
+
+    aas_types.AASSubmodelElements.DATA_ELEMENT:
+        aas_types.DataElement,
+
+    aas_types.AASSubmodelElements.ENTITY:
+        aas_types.Entity,
+
+    aas_types.AASSubmodelElements.EVENT_ELEMENT:
+        aas_types.EventElement,
+
+    aas_types.AASSubmodelElements.FILE:
+        aas_types.File,
+
+    aas_types.AASSubmodelElements.MULTI_LANGUAGE_PROPERTY:
+        aas_types.MultiLanguageProperty,
+
+    aas_types.AASSubmodelElements.OPERATION:
+        aas_types.Operation,
+
+    aas_types.AASSubmodelElements.PROPERTY:
+        aas_types.Property,
+
+    aas_types.AASSubmodelElements.RANGE:
+        aas_types.Range,
+
+    aas_types.AASSubmodelElements.REFERENCE_ELEMENT:
+        aas_types.ReferenceElement,
+
+    aas_types.AASSubmodelElements.RELATIONSHIP_ELEMENT:
+        aas_types.RelationshipElement,
+
+    aas_types.AASSubmodelElements.SUBMODEL_ELEMENT:
+        aas_types.SubmodelElement,
+
+    aas_types.AASSubmodelElements.SUBMODEL_ELEMENT_LIST:
+        aas_types.SubmodelElementList,
+
+    aas_types.AASSubmodelElements.SUBMODEL_ELEMENT_COLLECTION:
+        aas_types.SubmodelElementCollection,
+}
+# fmt: on
+
+
+def _assert_all_types_covered_in_aas_submodel_elements_to_type() -> None:
+    """
+    Assert that we did not miss a type in :py:attr:`_AAS_SUBMODEL_ELEMENTS_TO_TYPE`.
+    """
+    missing_literals = [
+        literal
+        for literal in aas_types.AASSubmodelElements
+        if literal not in _AAS_SUBMODEL_ELEMENTS_TO_TYPE
+    ]
+
+    assert len(missing_literals) == 0, (
+        f"Some literals were missed in "
+        f"_AAS_SUBMODEL_ELEMENTS_TO_TYPE: {missing_literals!r}"
+    )
+
+
+_assert_all_types_covered_in_aas_submodel_elements_to_type()
+
+
+def submodel_element_is_of_type(
+    element: aas_types.SubmodelElement, expected_type: aas_types.AASSubmodelElements
+) -> bool:
+    """
+    Check that :paramref:`element` is an instance of class corresponding
+    to :paramref:`expected_type`.
+    """
+    # noinspection PyTypeHints
+    return isinstance(element, _AAS_SUBMODEL_ELEMENTS_TO_TYPE[expected_type])
+
+
+def properties_or_ranges_have_value_type(
+    elements: Iterable[aas_types.SubmodelElement], value_type: aas_types.DataTypeDefXSD
+) -> bool:
+    """
+    Check that :paramref:`elements` which are
+    :py:class:`.types.Property` or :py:class:`.types.Range`
+    have the given :paramref:`value_type`.
+    """
+    range_or_property = (aas_types.Property, aas_types.Range)
+    for element in elements:
+        if isinstance(element, range_or_property):
+            if element.value_type is not value_type:
+                return False
+
+    return True
+
+
+def reference_key_values_equal(
+    that: aas_types.Reference, other: aas_types.Reference
+) -> bool:
+    """
+    Check that the two references, :paramref:`that` and :paramref:`other`,
+    are equal by comparing their :py:attr:`.types.Reference.keys`
+    by :py:attr:`.types.Key.value`'s.
+    """
+    if len(that.keys) != len(other.keys):
+        return False
+
+    for that_key, other_key in zip(that.keys, other.keys):
+        if that_key.value != other_key.value:
+            return False
+
+    return True
+
+
+def data_specification_iec_61360s_for_property_or_value_have_appropriate_data_type(
+    embedded_data_specifications: Iterable[aas_types.EmbeddedDataSpecification],
+) -> bool:
+    """
+    Check that :py:attr:`.types.DataSpecificationIEC61360.data_type`
+    is defined appropriately for all data specifications whose content is given
+    as IEC 61360.
+    """
+    for embedded_data_specification in embedded_data_specifications:
+        if isinstance(
+            embedded_data_specification.data_specification_content,
+            aas_types.DataSpecificationIEC61360,
+        ):
+            iec61360 = embedded_data_specification.data_specification_content
+            if (
+                iec61360.data_type is None
+                or iec61360.data_type
+                not in aas_constants.DATA_TYPE_IEC_61360_FOR_PROPERTY_OR_VALUE
+            ):
+                return False
+
+    return True
+
+
+def data_specification_iec_61360s_for_reference_have_appropriate_data_type(
+    embedded_data_specifications: Iterable[aas_types.EmbeddedDataSpecification],
+) -> bool:
+    """
+    Check that :py:attr:`.types.DataSpecificationIEC61360.data_type`
+    is defined appropriately for all data specifications whose content is given
+    as IEC 61360.
+    """
+    for embedded_data_specification in embedded_data_specifications:
+        if isinstance(
+            embedded_data_specification.data_specification_content,
+            aas_types.DataSpecificationIEC61360,
+        ):
+            iec61360 = embedded_data_specification.data_specification_content
+            if (
+                iec61360.data_type is None
+                or iec61360.data_type
+                not in aas_constants.DATA_TYPE_IEC_61360_FOR_REFERENCE
+            ):
+                return False
+
+    return True
+
+
+def data_specification_iec_61360s_for_document_have_appropriate_data_type(
+    embedded_data_specifications: Iterable[aas_types.EmbeddedDataSpecification],
+) -> bool:
+    """
+    Check that :py:attr:`.types.DataSpecificationIEC61360.data_type`
+    is defined appropriately for all data specifications whose content is given as
+    IEC 61360.
+    """
+    for embedded_data_specification in embedded_data_specifications:
+        if isinstance(
+            embedded_data_specification.data_specification_content,
+            aas_types.DataSpecificationIEC61360,
+        ):
+            iec61360 = embedded_data_specification.data_specification_content
+            if (
+                iec61360.data_type is None
+                or iec61360.data_type
+                not in aas_constants.DATA_TYPE_IEC_61360_FOR_DOCUMENT
+            ):
+                return False
+
+    return True
+
+
+def data_specification_iec_61360s_have_data_type(
+    embedded_data_specifications: Iterable[aas_types.EmbeddedDataSpecification],
+) -> bool:
+    """
+    Check that :py:attr:`.types.DataSpecificationIEC61360.data_type`
+    is defined for all data specifications whose content is given as IEC 61360.
+    """
+    for embedded_data_specification in embedded_data_specifications:
+        if isinstance(
+            embedded_data_specification.data_specification_content,
+            aas_types.DataSpecificationIEC61360,
+        ):
+            iec61360 = embedded_data_specification.data_specification_content
+            if iec61360.data_type is None:
+                return False
+
+    return True
+
+
+def data_specification_iec_61360s_have_value(
+    embedded_data_specifications: Iterable[aas_types.EmbeddedDataSpecification],
+) -> bool:
+    """
+    Check that :py:attr:`.types.DataSpecificationIEC61360.value`
+    is defined for all data specifications whose content is given as IEC 61360.
+    """
+    for embedded_data_specification in embedded_data_specifications:
+        if isinstance(
+            embedded_data_specification.data_specification_content,
+            aas_types.DataSpecificationIEC61360,
+        ):
+            iec61360 = embedded_data_specification.data_specification_content
+            if iec61360.value is None:
+                return False
+
+    return True
+
+
+def data_specification_iec_61360s_have_definition_at_least_in_english(
+    embedded_data_specifications: Iterable[aas_types.EmbeddedDataSpecification],
+) -> bool:
+    """
+    Check that :py:attr:`.types.DataSpecificationIEC61360.definition`
+    is defined for all data specifications whose content is given as IEC 61360
+    at least in English.
+    """
+    for embedded_data_specification in embedded_data_specifications:
+        if isinstance(
+            embedded_data_specification.data_specification_content,
+            aas_types.DataSpecificationIEC61360,
+        ):
+            iec61360 = embedded_data_specification.data_specification_content
+            if iec61360.definition is None:
+                return False
+
+            no_definition_in_english = True
+            for lang_string in iec61360.definition:
+                if is_bcp_47_for_english(lang_string.language):
+                    no_definition_in_english = False
+                    break
+
+            if no_definition_in_english:
+                return False
+
+    return True
+
+
+# noinspection SpellCheckingInspection
+def _construct_is_bcp_47_for_english() -> Pattern[str]:
+    pattern = "^(en|EN)(-.*)?$"
+
+    return re.compile(pattern)
+
+
+_REGEX_IS_BCP_47_FOR_ENGLISH = _construct_is_bcp_47_for_english()
+
+
+def is_bcp_47_for_english(text: str) -> bool:
+    """
+    Check that the :paramref:`text` corresponds to a BCP47 code for english.
+    """
+    return _REGEX_IS_BCP_47_FOR_ENGLISH.match(text) is not None
+
+
+class _Transformer(aas_types.AbstractTransformer[Iterator[Error]]):
+    # noinspection PyMethodMayBeStatic
+    def transform_extension(self, that: aas_types.Extension) -> Iterator[Error]:
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.refers_to is not None) or (len(that.refers_to) >= 1)):
+            yield Error("Refers-to must be either not set or have at least one item.")
+
+        if not (
+            not (that.value is not None)
+            or value_consistent_with_xsd_type(that.value, that.value_type_or_default())
+        ):
+            yield Error("The value must match the value type.")
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, an_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        for error in verify_name_type(that.name):
+            error.path._prepend(PropertySegment(that, "name"))
+            yield error
+
+        if that.value is not None:
+            for error in verify_value_data_type(that.value):
+                error.path._prepend(PropertySegment(that, "value"))
+                yield error
+
+        if that.refers_to is not None:
+            for i, another_item in enumerate(that.refers_to):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.refers_to, i))
+                    error.path._prepend(PropertySegment(that, "refers_to"))
+                    yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_administrative_information(
+        self, that: aas_types.AdministrativeInformation
+    ) -> Iterator[Error]:
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (not (that.revision is not None) or (that.version is not None)):
+            yield Error(
+                "Constraint AASd-005: If version is not specified then also "
+                + "revision shall be unspecified. This means, a revision "
+                + "requires a version. If there is no version there is no "
+                + "revision either. Revision is optional."
+            )
+
+        if that.embedded_data_specifications is not None:
+            for i, an_item in enumerate(that.embedded_data_specifications):
+                for error in self.transform(an_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.version is not None:
+            for error in verify_version_type(that.version):
+                error.path._prepend(PropertySegment(that, "version"))
+                yield error
+
+        if that.revision is not None:
+            for error in verify_revision_type(that.revision):
+                error.path._prepend(PropertySegment(that, "revision"))
+                yield error
+
+        if that.creator is not None:
+            for error in self.transform(that.creator):
+                error.path._prepend(PropertySegment(that, "creator"))
+                yield error
+
+        if that.template_id is not None:
+            for error in verify_identifier(that.template_id):
+                error.path._prepend(PropertySegment(that, "template_id"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_qualifier(self, that: aas_types.Qualifier) -> Iterator[Error]:
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (
+            not (that.value is not None)
+            or value_consistent_with_xsd_type(that.value, that.value_type)
+        ):
+            yield Error(
+                "Constraint AASd-020: The value shall be consistent to "
+                + "the data type as defined in value type."
+            )
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, an_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        for error in verify_qualifier_type(that.type):
+            error.path._prepend(PropertySegment(that, "type"))
+            yield error
+
+        if that.value is not None:
+            for error in verify_value_data_type(that.value):
+                error.path._prepend(PropertySegment(that, "value"))
+                yield error
+
+        if that.value_id is not None:
+            for error in self.transform(that.value_id):
+                error.path._prepend(PropertySegment(that, "value_id"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_asset_administration_shell(
+        self, that: aas_types.AssetAdministrationShell
+    ) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (not (that.submodels is not None) or (len(that.submodels) >= 1)):
+            yield Error("Submodels must be either not set or have at least one item.")
+
+        if not (
+            not (that.derived_from is not None)
+            or is_model_reference_to(
+                that.derived_from, aas_types.KeyTypes.ASSET_ADMINISTRATION_SHELL
+            )
+        ):
+            yield Error(
+                "Derived-from must be a model reference to an asset "
+                + "administration shell."
+            )
+
+        if not (
+            not (that.submodels is not None)
+            or (
+                all(
+                    is_model_reference_to(reference, aas_types.KeyTypes.SUBMODEL)
+                    for reference in that.submodels
+                )
+            )
+        ):
+            yield Error("All submodels must be model references to a submodel.")
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.administration is not None:
+            for error in self.transform(that.administration):
+                error.path._prepend(PropertySegment(that, "administration"))
+                yield error
+
+        for error in verify_identifier(that.id):
+            error.path._prepend(PropertySegment(that, "id"))
+            yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_another_item in enumerate(that.embedded_data_specifications):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.derived_from is not None:
+            for error in self.transform(that.derived_from):
+                error.path._prepend(PropertySegment(that, "derived_from"))
+                yield error
+
+        for error in self.transform(that.asset_information):
+            error.path._prepend(PropertySegment(that, "asset_information"))
+            yield error
+
+        if that.submodels is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.submodels):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.submodels, i))
+                    error.path._prepend(PropertySegment(that, "submodels"))
+                    yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_asset_information(
+        self, that: aas_types.AssetInformation
+    ) -> Iterator[Error]:
+        if not (
+            not (that.specific_asset_ids is not None)
+            or (
+                all(
+                    (
+                        specific_asset_id.name != "globalAssetId"
+                        or (
+                            (
+                                (that.global_asset_id is not None)
+                                and specific_asset_id.name == "globalAssetId"
+                                and specific_asset_id.value == that.global_asset_id
+                            )
+                        )
+                    )
+                    for specific_asset_id in that.specific_asset_ids
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASd-116: ``globalAssetId`` is a reserved key. "
+                + "If used as value for the name of specific asset ID then "
+                + "the value of specific asset ID shall be identical to "
+                + "the global asset ID."
+            )
+
+        if not (
+            (
+                (
+                    (
+                        (that.global_asset_id is not None)
+                        and (that.specific_asset_ids is None)
+                    )
+                )
+                or (
+                    (
+                        (that.global_asset_id is None)
+                        and (that.specific_asset_ids is not None)
+                        and len(that.specific_asset_ids) >= 1
+                    )
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASd-131: Either the global asset ID shall be "
+                + "defined or at least one specific asset ID."
+            )
+
+        if not (
+            not (that.specific_asset_ids is not None)
+            or (len(that.specific_asset_ids) >= 1)
+        ):
+            yield Error(
+                "Specific asset IDs must be either not set or have at least "
+                + "one item."
+            )
+
+        if that.global_asset_id is not None:
+            for error in verify_identifier(that.global_asset_id):
+                error.path._prepend(PropertySegment(that, "global_asset_id"))
+                yield error
+
+        if that.specific_asset_ids is not None:
+            for i, an_item in enumerate(that.specific_asset_ids):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.specific_asset_ids, i))
+                    error.path._prepend(PropertySegment(that, "specific_asset_ids"))
+                    yield error
+
+        if that.asset_type is not None:
+            for error in verify_identifier(that.asset_type):
+                error.path._prepend(PropertySegment(that, "asset_type"))
+                yield error
+
+        if that.default_thumbnail is not None:
+            for error in self.transform(that.default_thumbnail):
+                error.path._prepend(PropertySegment(that, "default_thumbnail"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_resource(self, that: aas_types.Resource) -> Iterator[Error]:
+        for error in verify_path_type(that.path):
+            error.path._prepend(PropertySegment(that, "path"))
+            yield error
+
+        if that.content_type is not None:
+            for error in verify_content_type(that.content_type):
+                error.path._prepend(PropertySegment(that, "content_type"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_specific_asset_id(
+        self, that: aas_types.SpecificAssetID
+    ) -> Iterator[Error]:
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (
+            not (that.external_subject_id is not None)
+            or (
+                that.external_subject_id.type
+                == aas_types.ReferenceTypes.EXTERNAL_REFERENCE
+            )
+        ):
+            yield Error(
+                "Constraint AASd-133: External subject ID shall be "
+                + "an external reference."
+            )
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, an_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        for error in verify_label_type(that.name):
+            error.path._prepend(PropertySegment(that, "name"))
+            yield error
+
+        for error in verify_identifier(that.value):
+            error.path._prepend(PropertySegment(that, "value"))
+            yield error
+
+        if that.external_subject_id is not None:
+            for error in self.transform(that.external_subject_id):
+                error.path._prepend(PropertySegment(that, "external_subject_id"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_submodel(self, that: aas_types.Submodel) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (
+            not (that.submodel_elements is not None)
+            or (len(that.submodel_elements) >= 1)
+        ):
+            yield Error(
+                "Submodel elements must be either not set or have at least "
+                + "one item."
+            )
+
+        if not (
+            not (that.submodel_elements is not None)
+            or (all(item.id_short is not None for item in that.submodel_elements))
+        ):
+            yield Error(
+                "ID-shorts need to be defined for all the items of submodel "
+                + "elements according to AASd-117 (ID-short of Referables not "
+                + "being a direct child of a Submodel element list shall be "
+                + "specified)."
+            )
+
+        if not (
+            not (that.submodel_elements is not None)
+            or id_shorts_are_unique(that.submodel_elements)
+        ):
+            yield Error(
+                "Constraint AASd-022: ID-short of non-identifiable "
+                + "referables within the same name space shall be unique "
+                + "(case-sensitive)."
+            )
+
+        if not (
+            not (that.submodel_elements is not None)
+            or (
+                not (that.kind_or_default() != aas_types.ModellingKind.TEMPLATE)
+                or (
+                    all(
+                        not (submodel_element.qualifiers is not None)
+                        or (
+                            all(
+                                qualifier.kind_or_default()
+                                != aas_types.QualifierKind.TEMPLATE_QUALIFIER
+                                for qualifier in submodel_element.qualifiers
+                            )
+                        )
+                        for submodel_element in that.submodel_elements
+                    )
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASd-129: If any qualifier kind value of "
+                + "a Submodel element qualifier (attribute qualifier inherited "
+                + "via Qualifiable) is equal to Template Qualifier then "
+                + "the submodel element shall be part of a submodel template, "
+                + "i.e. a Submodel with submodel kind (attribute kind "
+                + "inherited via Has-Kind) value is equal to Template."
+            )
+
+        if not (
+            not (that.qualifiers is not None)
+            or (
+                not (
+                    any(
+                        qualifier.kind_or_default()
+                        == aas_types.QualifierKind.TEMPLATE_QUALIFIER
+                        for qualifier in that.qualifiers
+                    )
+                )
+                or (that.kind_or_default() == aas_types.ModellingKind.TEMPLATE)
+            )
+        ):
+            yield Error(
+                "Constraint AASd-119: If any qualifier kind value of "
+                + "a qualifiable qualifier is equal to template qualifier and "
+                + "the qualified element has kind then the qualified element "
+                + "shall be of kind template."
+            )
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.administration is not None:
+            for error in self.transform(that.administration):
+                error.path._prepend(PropertySegment(that, "administration"))
+                yield error
+
+        for error in verify_identifier(that.id):
+            error.path._prepend(PropertySegment(that, "id"))
+            yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.submodel_elements is not None:
+            for i, yet_yet_yet_yet_yet_another_item in enumerate(
+                that.submodel_elements
+            ):
+                for error in self.transform(yet_yet_yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.submodel_elements, i))
+                    error.path._prepend(PropertySegment(that, "submodel_elements"))
+                    yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_relationship_element(
+        self, that: aas_types.RelationshipElement
+    ) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        for error in self.transform(that.first):
+            error.path._prepend(PropertySegment(that, "first"))
+            yield error
+
+        for error in self.transform(that.second):
+            error.path._prepend(PropertySegment(that, "second"))
+            yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_submodel_element_list(
+        self, that: aas_types.SubmodelElementList
+    ) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (not (that.value is not None) or (len(that.value) >= 1)):
+            yield Error("Value must be either not set or have at least one item.")
+
+        if not (
+            not (
+                (
+                    (that.value is not None)
+                    and (that.semantic_id_list_element is not None)
+                )
+            )
+            or (
+                all(
+                    not (child.semantic_id is not None)
+                    or reference_key_values_equal(
+                        child.semantic_id, that.semantic_id_list_element
+                    )
+                    for child in that.value
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASd-107: If a first level child element has "
+                + "a semantic ID it shall be identical to semantic ID list "
+                + "element."
+            )
+
+        if not (
+            not (that.value is not None)
+            or submodel_elements_have_identical_semantic_ids(that.value)
+        ):
+            yield Error(
+                "Constraint AASd-114: If two first level child elements have "
+                + "a semantic ID then they shall be identical."
+            )
+
+        if not (
+            not (that.value is not None)
+            or (
+                all(
+                    submodel_element_is_of_type(element, that.type_value_list_element)
+                    for element in that.value
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASd-108: All first level child elements shall "
+                + "have the same submodel element type as specified in type "
+                + "value list element."
+            )
+
+        if not (
+            not (
+                (
+                    (that.value is not None)
+                    and (
+                        (
+                            that.type_value_list_element
+                            == aas_types.AASSubmodelElements.PROPERTY
+                            or that.type_value_list_element
+                            == aas_types.AASSubmodelElements.RANGE
+                        )
+                    )
+                )
+            )
+            or (
+                (
+                    (that.value_type_list_element is not None)
+                    and properties_or_ranges_have_value_type(
+                        that.value, that.value_type_list_element
+                    )
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASd-109: If type value list element is equal to "
+                + "Property or Range value type list element shall be set and "
+                + "all first level child elements shall have the value type as "
+                + "specified in value type list element."
+            )
+
+        if not (
+            not (that.value is not None)
+            or (all(element.id_short is None for element in that.value))
+        ):
+            yield Error(
+                "Constraint AASd-120: ID-short of submodel elements being "
+                + "a direct child of a  Submodel element list shall not be "
+                + "specified."
+            )
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.semantic_id_list_element is not None:
+            for error in self.transform(that.semantic_id_list_element):
+                error.path._prepend(PropertySegment(that, "semantic_id_list_element"))
+                yield error
+
+        if that.value is not None:
+            for i, yet_yet_yet_yet_yet_another_item in enumerate(that.value):
+                for error in self.transform(yet_yet_yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.value, i))
+                    error.path._prepend(PropertySegment(that, "value"))
+                    yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_submodel_element_collection(
+        self, that: aas_types.SubmodelElementCollection
+    ) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (not (that.value is not None) or (len(that.value) >= 1)):
+            yield Error("Value must be either not set or have at least one item.")
+
+        if not (
+            not (that.value is not None)
+            or (all(item.id_short is not None for item in that.value))
+        ):
+            yield Error(
+                "ID-shorts need to be defined for all the items of value "
+                + "according to AASd-117 (ID-short of Referables not being "
+                + "a direct child of a Submodel element list shall be "
+                + "specified)."
+            )
+
+        if not (not (that.value is not None) or id_shorts_are_unique(that.value)):
+            yield Error("ID-shorts of the value must be unique.")
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.value is not None:
+            for i, yet_yet_yet_yet_yet_another_item in enumerate(that.value):
+                for error in self.transform(yet_yet_yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.value, i))
+                    error.path._prepend(PropertySegment(that, "value"))
+                    yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_property(self, that: aas_types.Property) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (
+            not (that.category is not None)
+            or (that.category in aas_constants.VALID_CATEGORIES_FOR_DATA_ELEMENT)
+        ):
+            yield Error(
+                "Constraint AASd-090: For data elements category shall be "
+                + "one of the following values: CONSTANT, PARAMETER or "
+                + "VARIABLE."
+            )
+
+        if not (
+            not (that.value is not None)
+            or value_consistent_with_xsd_type(that.value, that.value_type)
+        ):
+            yield Error("Value must be consistent with the value type.")
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.value is not None:
+            for error in verify_value_data_type(that.value):
+                error.path._prepend(PropertySegment(that, "value"))
+                yield error
+
+        if that.value_id is not None:
+            for error in self.transform(that.value_id):
+                error.path._prepend(PropertySegment(that, "value_id"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_multi_language_property(
+        self, that: aas_types.MultiLanguageProperty
+    ) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (
+            not (that.category is not None)
+            or (that.category in aas_constants.VALID_CATEGORIES_FOR_DATA_ELEMENT)
+        ):
+            yield Error(
+                "Constraint AASd-090: For data elements category shall be "
+                + "one of the following values: CONSTANT, PARAMETER or "
+                + "VARIABLE."
+            )
+
+        if not (
+            not (that.value is not None)
+            or lang_strings_have_unique_languages(that.value)
+        ):
+            yield Error("Value specifies no duplicate languages.")
+
+        if not (not (that.value is not None) or (len(that.value) >= 1)):
+            yield Error("Value must be either not set or have at least one item.")
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.value is not None:
+            for i, yet_yet_yet_yet_yet_another_item in enumerate(that.value):
+                for error in self.transform(yet_yet_yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.value, i))
+                    error.path._prepend(PropertySegment(that, "value"))
+                    yield error
+
+        if that.value_id is not None:
+            for error in self.transform(that.value_id):
+                error.path._prepend(PropertySegment(that, "value_id"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_range(self, that: aas_types.Range) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (
+            not (that.category is not None)
+            or (that.category in aas_constants.VALID_CATEGORIES_FOR_DATA_ELEMENT)
+        ):
+            yield Error(
+                "Constraint AASd-090: For data elements category shall be "
+                + "one of the following values: CONSTANT, PARAMETER or "
+                + "VARIABLE."
+            )
+
+        if not (
+            not (that.max is not None)
+            or value_consistent_with_xsd_type(that.max, that.value_type)
+        ):
+            yield Error("Max must be consistent with the value type.")
+
+        if not (
+            not (that.min is not None)
+            or value_consistent_with_xsd_type(that.min, that.value_type)
+        ):
+            yield Error("Min must be consistent with the value type.")
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.min is not None:
+            for error in verify_value_data_type(that.min):
+                error.path._prepend(PropertySegment(that, "min"))
+                yield error
+
+        if that.max is not None:
+            for error in verify_value_data_type(that.max):
+                error.path._prepend(PropertySegment(that, "max"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_reference_element(
+        self, that: aas_types.ReferenceElement
+    ) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (
+            not (that.category is not None)
+            or (that.category in aas_constants.VALID_CATEGORIES_FOR_DATA_ELEMENT)
+        ):
+            yield Error(
+                "Constraint AASd-090: For data elements category shall be "
+                + "one of the following values: CONSTANT, PARAMETER or "
+                + "VARIABLE."
+            )
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.value is not None:
+            for error in self.transform(that.value):
+                error.path._prepend(PropertySegment(that, "value"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_blob(self, that: aas_types.Blob) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (
+            not (that.category is not None)
+            or (that.category in aas_constants.VALID_CATEGORIES_FOR_DATA_ELEMENT)
+        ):
+            yield Error(
+                "Constraint AASd-090: For data elements category shall be "
+                + "one of the following values: CONSTANT, PARAMETER or "
+                + "VARIABLE."
+            )
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.value is not None:
+            for error in verify_blob_type(that.value):
+                error.path._prepend(PropertySegment(that, "value"))
+                yield error
+
+        for error in verify_content_type(that.content_type):
+            error.path._prepend(PropertySegment(that, "content_type"))
+            yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_file(self, that: aas_types.File) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (
+            not (that.category is not None)
+            or (that.category in aas_constants.VALID_CATEGORIES_FOR_DATA_ELEMENT)
+        ):
+            yield Error(
+                "Constraint AASd-090: For data elements category shall be "
+                + "one of the following values: CONSTANT, PARAMETER or "
+                + "VARIABLE."
+            )
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.value is not None:
+            for error in verify_path_type(that.value):
+                error.path._prepend(PropertySegment(that, "value"))
+                yield error
+
+        for error in verify_content_type(that.content_type):
+            error.path._prepend(PropertySegment(that, "content_type"))
+            yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_annotated_relationship_element(
+        self, that: aas_types.AnnotatedRelationshipElement
+    ) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (not (that.annotations is not None) or (len(that.annotations) >= 1)):
+            yield Error(
+                "Annotations must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.annotations is not None)
+            or (all(item.id_short is not None for item in that.annotations))
+        ):
+            yield Error(
+                "ID-shorts need to be defined for all the items of "
+                + "annotations according to AASd-117 (ID-short of Referables "
+                + "not being a direct child of a Submodel element list shall "
+                + "be specified)."
+            )
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        for error in self.transform(that.first):
+            error.path._prepend(PropertySegment(that, "first"))
+            yield error
+
+        for error in self.transform(that.second):
+            error.path._prepend(PropertySegment(that, "second"))
+            yield error
+
+        if that.annotations is not None:
+            for i, yet_yet_yet_yet_yet_another_item in enumerate(that.annotations):
+                for error in self.transform(yet_yet_yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.annotations, i))
+                    error.path._prepend(PropertySegment(that, "annotations"))
+                    yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_entity(self, that: aas_types.Entity) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (not (that.statements is not None) or (len(that.statements) >= 1)):
+            yield Error("Statements must be either not set or have at least one item.")
+
+        if not (
+            not (that.statements is not None)
+            or (all(item.id_short is not None for item in that.statements))
+        ):
+            yield Error(
+                "ID-shorts need to be defined for all the items of "
+                + "statements according to AASd-117 (ID-short of Referables "
+                + "not being a direct child of a Submodel element list shall "
+                + "be specified)."
+            )
+
+        if not (
+            (
+                (
+                    (
+                        that.entity_type == aas_types.EntityType.SELF_MANAGED_ENTITY
+                        and (
+                            (
+                                (
+                                    (
+                                        (that.global_asset_id is not None)
+                                        and (that.specific_asset_ids is None)
+                                    )
+                                )
+                                or (
+                                    (
+                                        (that.global_asset_id is None)
+                                        and (that.specific_asset_ids is not None)
+                                        and len(that.specific_asset_ids) >= 1
+                                    )
+                                )
+                            )
+                        )
+                    )
+                )
+                or (
+                    (
+                        that.entity_type != aas_types.EntityType.SELF_MANAGED_ENTITY
+                        and (that.global_asset_id is None)
+                        and (that.specific_asset_ids is None)
+                    )
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASd-014: Either the attribute global asset ID "
+                + "or specific asset ID must be set if entity type is set to "
+                + "self-managed entity. They are not existing otherwise."
+            )
+
+        if not (
+            not (that.specific_asset_ids is not None)
+            or (len(that.specific_asset_ids) >= 1)
+        ):
+            yield Error(
+                "Specific asset IDs must be either not set or have at least "
+                + "one item."
+            )
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.statements is not None:
+            for i, yet_yet_yet_yet_yet_another_item in enumerate(that.statements):
+                for error in self.transform(yet_yet_yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.statements, i))
+                    error.path._prepend(PropertySegment(that, "statements"))
+                    yield error
+
+        if that.global_asset_id is not None:
+            for error in verify_identifier(that.global_asset_id):
+                error.path._prepend(PropertySegment(that, "global_asset_id"))
+                yield error
+
+        if that.specific_asset_ids is not None:
+            for i, yet_yet_yet_yet_yet_yet_another_item in enumerate(
+                that.specific_asset_ids
+            ):
+                for error in self.transform(yet_yet_yet_yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.specific_asset_ids, i))
+                    error.path._prepend(PropertySegment(that, "specific_asset_ids"))
+                    yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_event_payload(self, that: aas_types.EventPayload) -> Iterator[Error]:
+        if not (
+            (
+                is_model_reference_to(that.source, aas_types.KeyTypes.EVENT_ELEMENT)
+                or is_model_reference_to(
+                    that.source, aas_types.KeyTypes.BASIC_EVENT_ELEMENT
+                )
+            )
+        ):
+            yield Error("Source must be a model reference to an Event element.")
+
+        if not (is_model_reference_to_referable(that.observable_reference)):
+            yield Error(
+                "Observable reference must be a model reference to " + "a referable."
+            )
+
+        for error in self.transform(that.source):
+            error.path._prepend(PropertySegment(that, "source"))
+            yield error
+
+        if that.source_semantic_id is not None:
+            for error in self.transform(that.source_semantic_id):
+                error.path._prepend(PropertySegment(that, "source_semantic_id"))
+                yield error
+
+        for error in self.transform(that.observable_reference):
+            error.path._prepend(PropertySegment(that, "observable_reference"))
+            yield error
+
+        if that.observable_semantic_id is not None:
+            for error in self.transform(that.observable_semantic_id):
+                error.path._prepend(PropertySegment(that, "observable_semantic_id"))
+                yield error
+
+        if that.topic is not None:
+            for error in verify_message_topic_type(that.topic):
+                error.path._prepend(PropertySegment(that, "topic"))
+                yield error
+
+        if that.subject_id is not None:
+            for error in self.transform(that.subject_id):
+                error.path._prepend(PropertySegment(that, "subject_id"))
+                yield error
+
+        for error in verify_date_time_utc(that.time_stamp):
+            error.path._prepend(PropertySegment(that, "time_stamp"))
+            yield error
+
+        if that.payload is not None:
+            for error in verify_blob_type(that.payload):
+                error.path._prepend(PropertySegment(that, "payload"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_basic_event_element(
+        self, that: aas_types.BasicEventElement
+    ) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (
+            not (that.direction == aas_types.Direction.INPUT)
+            or (that.max_interval is None)
+        ):
+            yield Error("Max. interval is not applicable for input direction.")
+
+        if not is_model_reference_to_referable(that.observed):
+            yield Error("Observed must be a model reference to a referable.")
+
+        if not (
+            not (that.message_broker is not None)
+            or is_model_reference_to_referable(that.message_broker)
+        ):
+            yield Error("Message broker must be a model reference to a referable.")
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        for error in self.transform(that.observed):
+            error.path._prepend(PropertySegment(that, "observed"))
+            yield error
+
+        if that.message_topic is not None:
+            for error in verify_message_topic_type(that.message_topic):
+                error.path._prepend(PropertySegment(that, "message_topic"))
+                yield error
+
+        if that.message_broker is not None:
+            for error in self.transform(that.message_broker):
+                error.path._prepend(PropertySegment(that, "message_broker"))
+                yield error
+
+        if that.last_update is not None:
+            for error in verify_date_time_utc(that.last_update):
+                error.path._prepend(PropertySegment(that, "last_update"))
+                yield error
+
+        if that.min_interval is not None:
+            for error in verify_duration(that.min_interval):
+                error.path._prepend(PropertySegment(that, "min_interval"))
+                yield error
+
+        if that.max_interval is not None:
+            for error in verify_duration(that.max_interval):
+                error.path._prepend(PropertySegment(that, "max_interval"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_operation(self, that: aas_types.Operation) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (
+            id_shorts_of_variables_are_unique(
+                that.input_variables, that.output_variables, that.inoutput_variables
+            )
+        ):
+            yield Error(
+                "Constraint AASd-134: For an Operation the ID-short of all "
+                + "values of input, output and in/output variables."
+            )
+
+        if not (
+            not (that.input_variables is not None) or (len(that.input_variables) >= 1)
+        ):
+            yield Error(
+                "Input variables must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.output_variables is not None) or (len(that.output_variables) >= 1)
+        ):
+            yield Error(
+                "Output variables must be either not set or have at least "
+                + "one item."
+            )
+
+        if not (
+            not (that.inoutput_variables is not None)
+            or (len(that.inoutput_variables) >= 1)
+        ):
+            yield Error(
+                "Inoutput variables must be either not set or have at least "
+                + "one item."
+            )
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.input_variables is not None:
+            for i, yet_yet_yet_yet_yet_another_item in enumerate(that.input_variables):
+                for error in self.transform(yet_yet_yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.input_variables, i))
+                    error.path._prepend(PropertySegment(that, "input_variables"))
+                    yield error
+
+        if that.output_variables is not None:
+            for i, yet_yet_yet_yet_yet_yet_another_item in enumerate(
+                that.output_variables
+            ):
+                for error in self.transform(yet_yet_yet_yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.output_variables, i))
+                    error.path._prepend(PropertySegment(that, "output_variables"))
+                    yield error
+
+        if that.inoutput_variables is not None:
+            for i, yet_yet_yet_yet_yet_yet_yet_another_item in enumerate(
+                that.inoutput_variables
+            ):
+                for error in self.transform(yet_yet_yet_yet_yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.inoutput_variables, i))
+                    error.path._prepend(PropertySegment(that, "inoutput_variables"))
+                    yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_operation_variable(
+        self, that: aas_types.OperationVariable
+    ) -> Iterator[Error]:
+        if not (that.value.id_short is not None):
+            yield Error(
+                "Value must have the ID-short specified according to "
+                + "Constraint AASd-117 (ID-short of Referables not being "
+                + "a direct child of a Submodel element list shall be "
+                + "specified)."
+            )
+
+        for error in self.transform(that.value):
+            error.path._prepend(PropertySegment(that, "value"))
+            yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_capability(self, that: aas_types.Capability) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (len(that.supplemental_semantic_ids) >= 1)
+        ):
+            yield Error(
+                "Supplemental semantic IDs must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (
+            not (that.supplemental_semantic_ids is not None)
+            or (that.semantic_id is not None)
+        ):
+            yield Error(
+                "Constraint AASd-118: If there are supplemental semantic IDs "
+                + "defined then there shall be also a main semantic ID."
+            )
+
+        if not (not (that.qualifiers is not None) or (len(that.qualifiers) >= 1)):
+            yield Error("Qualifiers must be either not set or have at least one item.")
+
+        if not (
+            not (that.qualifiers is not None)
+            or qualifier_types_are_unique(that.qualifiers)
+        ):
+            yield Error(
+                "Constraint AASd-021: Every qualifiable can only have one "
+                + "qualifier with the same type."
+            )
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.semantic_id is not None:
+            for error in self.transform(that.semantic_id):
+                error.path._prepend(PropertySegment(that, "semantic_id"))
+                yield error
+
+        if that.supplemental_semantic_ids is not None:
+            for i, yet_yet_another_item in enumerate(that.supplemental_semantic_ids):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.supplemental_semantic_ids, i))
+                    error.path._prepend(
+                        PropertySegment(that, "supplemental_semantic_ids")
+                    )
+                    yield error
+
+        if that.qualifiers is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.qualifiers):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.qualifiers, i))
+                    error.path._prepend(PropertySegment(that, "qualifiers"))
+                    yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_yet_yet_another_item in enumerate(
+                that.embedded_data_specifications
+            ):
+                for error in self.transform(yet_yet_yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_concept_description(
+        self, that: aas_types.ConceptDescription
+    ) -> Iterator[Error]:
+        if not (not (that.extensions is not None) or (len(that.extensions) >= 1)):
+            yield Error("Extensions must be either not set or have at least one item.")
+
+        if not (
+            not (that.extensions is not None)
+            or extension_names_are_unique(that.extensions)
+        ):
+            yield Error(
+                "Constraint AASd-077: The name of an extension within "
+                + "Has-Extensions needs to be unique."
+            )
+
+        if not (not (that.description is not None) or (len(that.description) >= 1)):
+            yield Error(
+                "Description must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.description is not None)
+            or lang_strings_have_unique_languages(that.description)
+        ):
+            yield Error("Description specifies no duplicate languages.")
+
+        if not (not (that.display_name is not None) or (len(that.display_name) >= 1)):
+            yield Error(
+                "Display name must be either not set or have at least one " + "item."
+            )
+
+        if not (
+            not (that.display_name is not None)
+            or lang_strings_have_unique_languages(that.display_name)
+        ):
+            yield Error("Display name specifies no duplicate languages.")
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (len(that.embedded_data_specifications) >= 1)
+        ):
+            yield Error(
+                "Embedded data specifications must be either not set or have "
+                + "at least one item."
+            )
+
+        if not (not (that.is_case_of is not None) or (len(that.is_case_of) >= 1)):
+            yield Error("Is-case-of must be either not set or have at least one item.")
+
+        if not (
+            not (that.embedded_data_specifications is not None)
+            or (
+                (
+                    data_specification_iec_61360s_have_definition_at_least_in_english(
+                        that.embedded_data_specifications
+                    )
+                    or data_specification_iec_61360s_have_value(
+                        that.embedded_data_specifications
+                    )
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASc-3a-008: For a concept description using "
+                + "data specification template IEC 61360, the definition is "
+                + "mandatory and shall be defined at least in English. "
+                + "Exception: The concept description describes a value."
+            )
+
+        if not (
+            not (
+                (
+                    (that.category is not None)
+                    and that.category == "QUALIFIER_TYPE"
+                    and (that.embedded_data_specifications is not None)
+                )
+            )
+            or data_specification_iec_61360s_have_data_type(
+                that.embedded_data_specifications
+            )
+        ):
+            yield Error(
+                "Constraint AASc-3a-007: For a concept description with "
+                + "category QUALIFIER_TYPE using data specification IEC 61360, "
+                + "the data type of the data specification is mandatory and "
+                + "shall be defined."
+            )
+
+        if not (
+            not (
+                (
+                    (that.category is not None)
+                    and that.category == "DOCUMENT"
+                    and (that.embedded_data_specifications is not None)
+                )
+            )
+            or data_specification_iec_61360s_for_document_have_appropriate_data_type(
+                that.embedded_data_specifications
+            )
+        ):
+            yield Error(
+                "Constraint AASc-3a-006: For a concept description with "
+                + "category DOCUMENT using data specification IEC 61360, "
+                + "the data type of the data specification shall be one of: "
+                + "FILE, BLOB, HTML."
+            )
+
+        if not (
+            not (
+                (
+                    (that.category is not None)
+                    and that.category == "REFERENCE"
+                    and (that.embedded_data_specifications is not None)
+                )
+            )
+            or data_specification_iec_61360s_for_reference_have_appropriate_data_type(
+                that.embedded_data_specifications
+            )
+        ):
+            yield Error(
+                "Constraint AASc-3a-005: For a concept description with "
+                + "category REFERENCE using data specification IEC 61360, "
+                + "the data type of the data specification shall be one of: "
+                + "STRING, IRI, IRDI."
+            )
+
+        if not (
+            not (
+                (
+                    (that.category is not None)
+                    and ((that.category == "PROPERTY" or that.category == "VALUE"))
+                    and (that.embedded_data_specifications is not None)
+                )
+            )
+            or data_specification_iec_61360s_for_property_or_value_have_appropriate_data_type(
+                that.embedded_data_specifications
+            )
+        ):
+            yield Error(
+                "Constraint AASc-3a-004: For a concept description with "
+                + "category PROPERTY or VALUE using data specification IEC "
+                + "61360, the data type of the data specification is mandatory "
+                + "and shall be one of: DATE, STRING, STRING_TRANSLATABLE, "
+                + "INTEGER_MEASURE, INTEGER_COUNT, INTEGER_CURRENCY, "
+                + "REAL_MEASURE, REAL_COUNT, REAL_CURRENCY, BOOLEAN, RATIONAL, "
+                + "RATIONAL_MEASURE, TIME, TIMESTAMP."
+            )
+
+        if that.extensions is not None:
+            for i, an_item in enumerate(that.extensions):
+                for error in self.transform(an_item):
+                    error.path._prepend(IndexSegment(that.extensions, i))
+                    error.path._prepend(PropertySegment(that, "extensions"))
+                    yield error
+
+        if that.category is not None:
+            for error in verify_name_type(that.category):
+                error.path._prepend(PropertySegment(that, "category"))
+                yield error
+
+        if that.id_short is not None:
+            for error in verify_id_short_type(that.id_short):
+                error.path._prepend(PropertySegment(that, "id_short"))
+                yield error
+
+        if that.display_name is not None:
+            for i, another_item in enumerate(that.display_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.display_name, i))
+                    error.path._prepend(PropertySegment(that, "display_name"))
+                    yield error
+
+        if that.description is not None:
+            for i, yet_another_item in enumerate(that.description):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.description, i))
+                    error.path._prepend(PropertySegment(that, "description"))
+                    yield error
+
+        if that.administration is not None:
+            for error in self.transform(that.administration):
+                error.path._prepend(PropertySegment(that, "administration"))
+                yield error
+
+        for error in verify_identifier(that.id):
+            error.path._prepend(PropertySegment(that, "id"))
+            yield error
+
+        if that.embedded_data_specifications is not None:
+            for i, yet_yet_another_item in enumerate(that.embedded_data_specifications):
+                for error in self.transform(yet_yet_another_item):
+                    error.path._prepend(
+                        IndexSegment(that.embedded_data_specifications, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "embedded_data_specifications")
+                    )
+                    yield error
+
+        if that.is_case_of is not None:
+            for i, yet_yet_yet_another_item in enumerate(that.is_case_of):
+                for error in self.transform(yet_yet_yet_another_item):
+                    error.path._prepend(IndexSegment(that.is_case_of, i))
+                    error.path._prepend(PropertySegment(that, "is_case_of"))
+                    yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_reference(self, that: aas_types.Reference) -> Iterator[Error]:
+        if not (len(that.keys) >= 1):
+            yield Error("Keys must contain at least one item.")
+
+        if not (
+            not (len(that.keys) >= 1)
+            or (that.keys[0].type in aas_constants.GLOBALLY_IDENTIFIABLES)
+        ):
+            yield Error(
+                "Constraint AASd-121: For References the value of type of "
+                + "the first key of keys shall be one of Globally "
+                + "Identifiables."
+            )
+
+        if not (
+            not (
+                (
+                    that.type == aas_types.ReferenceTypes.EXTERNAL_REFERENCE
+                    and len(that.keys) >= 1
+                )
+            )
+            or (that.keys[0].type in aas_constants.GENERIC_GLOBALLY_IDENTIFIABLES)
+        ):
+            yield Error(
+                "Constraint AASd-122: For external references the value of "
+                + "type of the first key of keys shall be one of Generic "
+                + "Globally Identifiables."
+            )
+
+        if not (
+            not (
+                (
+                    that.type == aas_types.ReferenceTypes.MODEL_REFERENCE
+                    and len(that.keys) >= 1
+                )
+            )
+            or (that.keys[0].type in aas_constants.AAS_IDENTIFIABLES)
+        ):
+            yield Error(
+                "Constraint AASd-123: For model references the value of type "
+                + "of the first key of keys shall be one of AAS identifiables."
+            )
+
+        if not (
+            not (
+                (
+                    that.type == aas_types.ReferenceTypes.EXTERNAL_REFERENCE
+                    and len(that.keys) >= 1
+                )
+            )
+            or (
+                (
+                    (that.keys[-1].type in aas_constants.GENERIC_GLOBALLY_IDENTIFIABLES)
+                    or (that.keys[-1].type in aas_constants.GENERIC_FRAGMENT_KEYS)
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASd-124: For external references the last key "
+                + "of keys shall be either one of Generic Globally "
+                + "Identifiables or one of Generic Fragment Keys."
+            )
+
+        if not (
+            not (
+                (
+                    that.type == aas_types.ReferenceTypes.MODEL_REFERENCE
+                    and len(that.keys) > 1
+                )
+            )
+            or (
+                all(
+                    that.keys[i].type in aas_constants.FRAGMENT_KEYS
+                    for i in range(1, len(that.keys))
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASd-125: For model references with more than "
+                + "one key in keys the value of type of each of the keys "
+                + "following the first key of keys shall be one of Fragment "
+                + "Keys."
+            )
+
+        if not (
+            not (
+                (
+                    that.type == aas_types.ReferenceTypes.MODEL_REFERENCE
+                    and len(that.keys) > 1
+                )
+            )
+            or (
+                all(
+                    not (that.keys[i].type in aas_constants.GENERIC_FRAGMENT_KEYS)
+                    for i in range(0, len(that.keys) - 1)
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASd-126: For model references with more than "
+                + "one key in keys the value of type of the last key in "
+                + "the reference key chain may be one of Generic Fragment Keys "
+                + "or no key at all shall have a value out of Generic Fragment "
+                + "Keys."
+            )
+
+        if not (
+            not (
+                (
+                    that.type == aas_types.ReferenceTypes.MODEL_REFERENCE
+                    and len(that.keys) > 1
+                    and that.keys[-1].type == aas_types.KeyTypes.FRAGMENT_REFERENCE
+                )
+            )
+            or (
+                (
+                    that.keys[-2].type == aas_types.KeyTypes.FILE
+                    or that.keys[-2].type == aas_types.KeyTypes.BLOB
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASd-127: For model references, with more than "
+                + "one key in keys a key with type Fragment Reference shall be "
+                + "preceded by a key with type File or Blob."
+            )
+
+        if not (
+            not (
+                (
+                    that.type == aas_types.ReferenceTypes.MODEL_REFERENCE
+                    and len(that.keys) > 2
+                )
+            )
+            or (
+                all(
+                    not (that.keys[i].type == aas_types.KeyTypes.SUBMODEL_ELEMENT_LIST)
+                    or matches_xs_positive_integer(that.keys[i + 1].value)
+                    for i in range(0, len(that.keys) - 1)
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASd-128: For model references, the value of "
+                + "a key preceded by a key with type Submodel element list is "
+                + "an integer number denoting the position in the array of "
+                + "the submodel element list."
+            )
+
+        if that.referred_semantic_id is not None:
+            for error in self.transform(that.referred_semantic_id):
+                error.path._prepend(PropertySegment(that, "referred_semantic_id"))
+                yield error
+
+        for i, an_item in enumerate(that.keys):
+            for error in self.transform(an_item):
+                error.path._prepend(IndexSegment(that.keys, i))
+                error.path._prepend(PropertySegment(that, "keys"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_key(self, that: aas_types.Key) -> Iterator[Error]:
+        for error in verify_identifier(that.value):
+            error.path._prepend(PropertySegment(that, "value"))
+            yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_lang_string_name_type(
+        self, that: aas_types.LangStringNameType
+    ) -> Iterator[Error]:
+        if not (len(that.text) <= 128):
+            yield Error("String shall have a maximum length of 128 characters.")
+
+        for error in verify_bcp_47_language_tag(that.language):
+            error.path._prepend(PropertySegment(that, "language"))
+            yield error
+
+        for error in verify_non_empty_xml_serializable_string(that.text):
+            error.path._prepend(PropertySegment(that, "text"))
+            yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_lang_string_text_type(
+        self, that: aas_types.LangStringTextType
+    ) -> Iterator[Error]:
+        if not (len(that.text) <= 1023):
+            yield Error("String shall have a maximum length of 1023 characters.")
+
+        for error in verify_bcp_47_language_tag(that.language):
+            error.path._prepend(PropertySegment(that, "language"))
+            yield error
+
+        for error in verify_non_empty_xml_serializable_string(that.text):
+            error.path._prepend(PropertySegment(that, "text"))
+            yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_environment(self, that: aas_types.Environment) -> Iterator[Error]:
+        if not (
+            not (that.concept_descriptions is not None)
+            or (len(that.concept_descriptions) >= 1)
+        ):
+            yield Error(
+                "Concept descriptions must be either not set or have at "
+                + "least one item."
+            )
+
+        if not (not (that.submodels is not None) or (len(that.submodels) >= 1)):
+            yield Error("Submodels must be either not set or have at least one item.")
+
+        if not (
+            not (that.asset_administration_shells is not None)
+            or (len(that.asset_administration_shells) >= 1)
+        ):
+            yield Error(
+                "Asset administration shells must be either not set or have "
+                + "at least one item."
+            )
+
+        if that.asset_administration_shells is not None:
+            for i, an_item in enumerate(that.asset_administration_shells):
+                for error in self.transform(an_item):
+                    error.path._prepend(
+                        IndexSegment(that.asset_administration_shells, i)
+                    )
+                    error.path._prepend(
+                        PropertySegment(that, "asset_administration_shells")
+                    )
+                    yield error
+
+        if that.submodels is not None:
+            for i, another_item in enumerate(that.submodels):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.submodels, i))
+                    error.path._prepend(PropertySegment(that, "submodels"))
+                    yield error
+
+        if that.concept_descriptions is not None:
+            for i, yet_another_item in enumerate(that.concept_descriptions):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.concept_descriptions, i))
+                    error.path._prepend(PropertySegment(that, "concept_descriptions"))
+                    yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_embedded_data_specification(
+        self, that: aas_types.EmbeddedDataSpecification
+    ) -> Iterator[Error]:
+        for error in self.transform(that.data_specification):
+            error.path._prepend(PropertySegment(that, "data_specification"))
+            yield error
+
+        for error in self.transform(that.data_specification_content):
+            error.path._prepend(PropertySegment(that, "data_specification_content"))
+            yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_level_type(self, that: aas_types.LevelType) -> Iterator[Error]:
+        # No verification has been defined for LevelType.
+        return
+        # For this uncommon return-yield construction, see:
+        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
+        # noinspection PyUnreachableCode
+        yield
+
+    # noinspection PyMethodMayBeStatic
+    def transform_value_reference_pair(
+        self, that: aas_types.ValueReferencePair
+    ) -> Iterator[Error]:
+        for error in verify_value_type_iec_61360(that.value):
+            error.path._prepend(PropertySegment(that, "value"))
+            yield error
+
+        for error in self.transform(that.value_id):
+            error.path._prepend(PropertySegment(that, "value_id"))
+            yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_value_list(self, that: aas_types.ValueList) -> Iterator[Error]:
+        if not (len(that.value_reference_pairs) >= 1):
+            yield Error("Value reference pair types must contain at least one item.")
+
+        for i, an_item in enumerate(that.value_reference_pairs):
+            for error in self.transform(an_item):
+                error.path._prepend(IndexSegment(that.value_reference_pairs, i))
+                error.path._prepend(PropertySegment(that, "value_reference_pairs"))
+                yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_lang_string_preferred_name_type_iec_61360(
+        self, that: aas_types.LangStringPreferredNameTypeIEC61360
+    ) -> Iterator[Error]:
+        if not (len(that.text) <= 255):
+            yield Error("String shall have a maximum length of 1023 characters.")
+
+        for error in verify_bcp_47_language_tag(that.language):
+            error.path._prepend(PropertySegment(that, "language"))
+            yield error
+
+        for error in verify_non_empty_xml_serializable_string(that.text):
+            error.path._prepend(PropertySegment(that, "text"))
+            yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_lang_string_short_name_type_iec_61360(
+        self, that: aas_types.LangStringShortNameTypeIEC61360
+    ) -> Iterator[Error]:
+        if not (len(that.text) <= 18):
+            yield Error("String shall have a maximum length of 1023 characters.")
+
+        for error in verify_bcp_47_language_tag(that.language):
+            error.path._prepend(PropertySegment(that, "language"))
+            yield error
+
+        for error in verify_non_empty_xml_serializable_string(that.text):
+            error.path._prepend(PropertySegment(that, "text"))
+            yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_lang_string_definition_type_iec_61360(
+        self, that: aas_types.LangStringDefinitionTypeIEC61360
+    ) -> Iterator[Error]:
+        if not (len(that.text) <= 1023):
+            yield Error("String shall have a maximum length of 1023 characters.")
+
+        for error in verify_bcp_47_language_tag(that.language):
+            error.path._prepend(PropertySegment(that, "language"))
+            yield error
+
+        for error in verify_non_empty_xml_serializable_string(that.text):
+            error.path._prepend(PropertySegment(that, "text"))
+            yield error
+
+    # noinspection PyMethodMayBeStatic
+    def transform_data_specification_iec_61360(
+        self, that: aas_types.DataSpecificationIEC61360
+    ) -> Iterator[Error]:
+        if not (
+            (
+                (((that.value is not None) and (that.value_list is None)))
+                or (
+                    (
+                        (that.value is None)
+                        and (that.value_list is not None)
+                        and len(that.value_list.value_reference_pairs) >= 1
+                    )
+                )
+            )
+        ):
+            yield Error(
+                "Constraint AASc-3a-010: If value is not empty then value "
+                + "list shall be empty and vice versa."
+            )
+
+        if not (
+            not (
+                (
+                    (that.data_type is not None)
+                    and (that.data_type in aas_constants.IEC_61360_DATA_TYPES_WITH_UNIT)
+                )
+            )
+            or (((that.unit is not None) or (that.unit_id is not None)))
+        ):
+            yield Error(
+                "Constraint AASc-3a-009: If data type is a an integer, real "
+                + "or rational with a measure or currency, unit or unit ID "
+                + "shall be defined."
+            )
+
+        if not (not (that.definition is not None) or (len(that.definition) >= 1)):
+            yield Error("Definition must be either not set or have at least one item.")
+
+        if not (
+            not (that.definition is not None)
+            or lang_strings_have_unique_languages(that.definition)
+        ):
+            yield Error("Definition specifies no duplicate languages.")
+
+        if not (not (that.short_name is not None) or (len(that.short_name) >= 1)):
+            yield Error("Short name must be either not set or have at least one item.")
+
+        if not (
+            not (that.short_name is not None)
+            or lang_strings_have_unique_languages(that.short_name)
+        ):
+            yield Error("Short name specifies no duplicate languages.")
+
+        if not (len(that.preferred_name) >= 1):
+            yield Error("Preferred name must have at least one item.")
+
+        if not (lang_strings_have_unique_languages(that.preferred_name)):
+            yield Error("Preferred name specifies no duplicate languages.")
+
+        if not (
+            any(
+                is_bcp_47_for_english(lang_string.language)
+                for lang_string in that.preferred_name
+            )
+        ):
+            yield Error(
+                "Constraint AASc-002: preferred name shall be provided at "
+                + "least in English."
+            )
+
+        for i, an_item in enumerate(that.preferred_name):
+            for error in self.transform(an_item):
+                error.path._prepend(IndexSegment(that.preferred_name, i))
+                error.path._prepend(PropertySegment(that, "preferred_name"))
+                yield error
+
+        if that.short_name is not None:
+            for i, another_item in enumerate(that.short_name):
+                for error in self.transform(another_item):
+                    error.path._prepend(IndexSegment(that.short_name, i))
+                    error.path._prepend(PropertySegment(that, "short_name"))
+                    yield error
+
+        if that.unit is not None:
+            for error in verify_non_empty_xml_serializable_string(that.unit):
+                error.path._prepend(PropertySegment(that, "unit"))
+                yield error
+
+        if that.unit_id is not None:
+            for error in self.transform(that.unit_id):
+                error.path._prepend(PropertySegment(that, "unit_id"))
+                yield error
+
+        if that.source_of_definition is not None:
+            for error in verify_non_empty_xml_serializable_string(
+                that.source_of_definition
+            ):
+                error.path._prepend(PropertySegment(that, "source_of_definition"))
+                yield error
+
+        if that.symbol is not None:
+            for error in verify_non_empty_xml_serializable_string(that.symbol):
+                error.path._prepend(PropertySegment(that, "symbol"))
+                yield error
+
+        if that.definition is not None:
+            for i, yet_another_item in enumerate(that.definition):
+                for error in self.transform(yet_another_item):
+                    error.path._prepend(IndexSegment(that.definition, i))
+                    error.path._prepend(PropertySegment(that, "definition"))
+                    yield error
+
+        if that.value_format is not None:
+            for error in verify_non_empty_xml_serializable_string(that.value_format):
+                error.path._prepend(PropertySegment(that, "value_format"))
+                yield error
+
+        if that.value_list is not None:
+            for error in self.transform(that.value_list):
+                error.path._prepend(PropertySegment(that, "value_list"))
+                yield error
+
+        if that.value is not None:
+            for error in verify_value_type_iec_61360(that.value):
+                error.path._prepend(PropertySegment(that, "value"))
+                yield error
+
+        if that.level_type is not None:
+            for error in self.transform(that.level_type):
+                error.path._prepend(PropertySegment(that, "level_type"))
+                yield error
+
+
+_TRANSFORMER = _Transformer()
+
+
+def verify(that: aas_types.Class) -> Iterator[Error]:
+    """
+    Verify the constraints of :paramref:`that` recursively.
+
+    :param that: instance whose constraints we want to verify
+    :yield: constraint violations
+    """
+    yield from _TRANSFORMER.transform(that)
+
+
+def verify_non_empty_xml_serializable_string(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xml_serializable_string(that):
+        yield Error(
+            "Constraint AASd-130: An attribute with data type 'string' "
+            + "shall consist of these characters only: "
+            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
+        )
+
+    if not (len(that) >= 1):
+        yield Error("The value must not be empty.")
+
+
+def verify_date_time_utc(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xs_date_time_utc(that):
+        yield Error(
+            "The value must match the pattern of xs:dateTime with "
+            + "the time zone fixed to UTC."
+        )
+
+    if not is_xs_date_time_utc(that):
+        yield Error(
+            "The value must represent a valid xs:dateTime with the time "
+            + "zone fixed to UTC."
+        )
+
+
+def verify_duration(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xs_duration(that):
+        yield Error("The value must match the pattern of xs:duration.")
+
+
+# noinspection PyUnusedLocal
+def verify_blob_type(that: bytes) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    # There is no verification specified.
+    return
+
+    # Empty generator according to:
+    # https://stackoverflow.com/a/13243870/1600678
+    # noinspection PyUnreachableCode
+    yield
+
+
+def verify_identifier(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xml_serializable_string(that):
+        yield Error(
+            "Constraint AASd-130: An attribute with data type 'string' "
+            + "shall consist of these characters only: "
+            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
+        )
+
+    if not (len(that) >= 1):
+        yield Error("The value must not be empty.")
+
+    if not (len(that) <= 2000):
+        yield Error("Identifier shall have a maximum length of 2000 characters.")
+
+
+def verify_value_type_iec_61360(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xml_serializable_string(that):
+        yield Error(
+            "Constraint AASd-130: An attribute with data type 'string' "
+            + "shall consist of these characters only: "
+            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
+        )
+
+    if not (len(that) >= 1):
+        yield Error("The value must not be empty.")
+
+    if not (len(that) <= 2000):
+        yield Error(
+            "Value type IEC 61360 shall have a maximum length of 2000 " + "characters."
+        )
+
+
+def verify_name_type(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xml_serializable_string(that):
+        yield Error(
+            "Constraint AASd-130: An attribute with data type 'string' "
+            + "shall consist of these characters only: "
+            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
+        )
+
+    if not (len(that) >= 1):
+        yield Error("The value must not be empty.")
+
+    if not (len(that) <= 128):
+        yield Error("Name type shall have a maximum length of 128 characters.")
+
+
+def verify_version_type(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xml_serializable_string(that):
+        yield Error(
+            "Constraint AASd-130: An attribute with data type 'string' "
+            + "shall consist of these characters only: "
+            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
+        )
+
+    if not (len(that) >= 1):
+        yield Error("The value must not be empty.")
+
+    if not matches_version_type(that):
+        yield Error("Version type shall match the version pattern.")
+
+    if not (len(that) <= 4):
+        yield Error("Version type shall have a maximum length of 4 characters.")
+
+
+def verify_revision_type(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xml_serializable_string(that):
+        yield Error(
+            "Constraint AASd-130: An attribute with data type 'string' "
+            + "shall consist of these characters only: "
+            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
+        )
+
+    if not (len(that) >= 1):
+        yield Error("The value must not be empty.")
+
+    if not matches_revision_type(that):
+        yield Error("Revision type shall match the revision pattern.")
+
+    if not (len(that) <= 4):
+        yield Error("Revision type shall have a maximum length of 4 characters.")
+
+
+def verify_label_type(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xml_serializable_string(that):
+        yield Error(
+            "Constraint AASd-130: An attribute with data type 'string' "
+            + "shall consist of these characters only: "
+            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
+        )
+
+    if not (len(that) >= 1):
+        yield Error("The value must not be empty.")
+
+    if not (len(that) <= 64):
+        yield Error("Label type shall have a maximum length of 64 characters.")
+
+
+def verify_message_topic_type(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xml_serializable_string(that):
+        yield Error(
+            "Constraint AASd-130: An attribute with data type 'string' "
+            + "shall consist of these characters only: "
+            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
+        )
+
+    if not (len(that) >= 1):
+        yield Error("The value must not be empty.")
+
+    if not (len(that) <= 255):
+        yield Error(
+            "Message topic type shall have a maximum length of 255 " + "characters."
+        )
+
+
+def verify_bcp_47_language_tag(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_bcp_47(that):
+        yield Error(
+            "The value must represent a value language tag conformant to " + "BCP 47."
+        )
+
+
+def verify_content_type(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xml_serializable_string(that):
+        yield Error(
+            "Constraint AASd-130: An attribute with data type 'string' "
+            + "shall consist of these characters only: "
+            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
+        )
+
+    if not (len(that) >= 1):
+        yield Error("The value must not be empty.")
+
+    if not (len(that) <= 100):
+        yield Error("Content type shall have a maximum length of 100 characters.")
+
+    if not matches_mime_type(that):
+        yield Error(
+            "The value must represent a valid content MIME type "
+            + "according to RFC 2046."
+        )
+
+
+def verify_path_type(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xml_serializable_string(that):
+        yield Error(
+            "Constraint AASd-130: An attribute with data type 'string' "
+            + "shall consist of these characters only: "
+            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
+        )
+
+    if not (len(that) >= 1):
+        yield Error("The value must not be empty.")
+
+    if not (len(that) <= 2000):
+        yield Error("Identifier shall have a maximum length of 2000 characters.")
+
+    if not matches_rfc_8089_path(that):
+        yield Error(
+            "The value must represent a valid file URI scheme according "
+            + "to RFC 8089."
+        )
+
+
+def verify_qualifier_type(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xml_serializable_string(that):
+        yield Error(
+            "Constraint AASd-130: An attribute with data type 'string' "
+            + "shall consist of these characters only: "
+            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
+        )
+
+    if not (len(that) >= 1):
+        yield Error("The value must not be empty.")
+
+    if not (len(that) <= 128):
+        yield Error("Name type shall have a maximum length of 128 characters.")
+
+
+# noinspection PyUnusedLocal
+def verify_value_data_type(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    # There is no verification specified.
+    return
+
+    # Empty generator according to:
+    # https://stackoverflow.com/a/13243870/1600678
+    # noinspection PyUnreachableCode
+    yield
+
+
+def verify_id_short_type(that: str) -> Iterator[Error]:
+    """Verify the constraints of :paramref:`that`."""
+    if not matches_xml_serializable_string(that):
+        yield Error(
+            "Constraint AASd-130: An attribute with data type 'string' "
+            + "shall consist of these characters only: "
+            + "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
+        )
+
+    if not (len(that) >= 1):
+        yield Error("The value must not be empty.")
+
+    if not (len(that) <= 128):
+        yield Error("Name type shall have a maximum length of 128 characters.")
+
+    if not matches_id_short(that):
+        yield Error(
+            "ID-short of Referables shall only feature letters, digits, "
+            + "underscore (``_``); starting mandatory with a letter. "
+            + "*I.e.* ``[a-zA-Z][a-zA-Z0-9_]*``."
+        )
+
+
+# This code has been automatically generated by aas-core-codegen.
+# Do NOT edit or append.
```

### Comparing `aas-core3.0-1.0.0rc1/aas_core3/xmlization.py` & `aas-core3.0-1.0.0rc2/aas_core3/xmlization.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,26496 +1,26496 @@
-"""
-Read and write AAS models as XML.
-
-For reading, we provide different reading functions, each handling a different kind
-of input. All the reading functions operate in one pass, *i.e.*, the source is read
-incrementally and the complete XML is not held in memory.
-
-We provide the following four reading functions (where ``X`` represents the name of
-the class):
-
-1) ``X_from_iterparse`` reads from a stream of ``(event, element)`` tuples coming from
-   :py:func:`xml.etree.ElementTree.iterparse` with the argument
-   ``events=["start", "end"]``. If you do not trust the source, please consider
-   using `defusedxml.ElementTree`_.
-2) ``X_from_stream`` reads from the given text stream.
-3) ``X_from_file`` reads from a file on disk.
-4) ``X_from_str`` reads from the given string.
-
-The functions ``X_from_stream``, ``X_from_file`` and ``X_from_str`` provide
-an extra parameter, ``has_iterparse``, which allows you to use a parsing library
-different from :py:mod:`xml.etree.ElementTree`. For example, you can pass in
-`defusedxml.ElementTree`_.
-
-.. _defusedxml.ElementTree: https://pypi.org/project/defusedxml/#defusedxml-elementtree
-
-All XML elements are expected to live in the :py:attr:`~NAMESPACE`.
-
-For writing, use the function :py:func:`aas_core3.xmlization.write` which
-translates the instance of the model into an XML document and writes it in one pass
-to the stream.
-
-Here is an example usage how to de-serialize from a file:
-
-.. code-block::
-
-    import pathlib
-    import xml.etree.ElementTree as ET
-
-    import aas_core3.xmlization as aas_xmlization
-
-    path = pathlib.Path(...)
-    instance = aas_xmlization.read_extension_from_file(
-        path
-    )
-
-    # Do something with the ``instance``
-
-Here is another code example where we serialize the instance:
-
-.. code-block::
-
-    import pathlib
-
-    import aas_core3.types as aas_types
-    import aas_core3.xmlization as aas_xmlization
-
-    instance = Extension(
-       ... # some constructor arguments
-    )
-
-    pth = pathlib.Path(...)
-    with pth.open("wt") as fid:
-        aas_xmlization.write(instance, fid)
-"""
-
-
-# This code has been automatically generated by aas-core-codegen.
-# Do NOT edit or append.
-
-
-import base64
-import io
-import math
-import os
-import sys
-from typing import (
-    Any,
-    Callable,
-    Iterator,
-    List,
-    Mapping,
-    Optional,
-    Sequence,
-    TextIO,
-    Tuple,
-    Union,
-    TYPE_CHECKING,
-)
-import xml.etree.ElementTree
-
-if sys.version_info >= (3, 8):
-    from typing import Final, Protocol
-else:
-    from typing_extensions import Final, Protocol
-
-import aas_core3.stringification as aas_stringification
-import aas_core3.types as aas_types
-
-# See: https://stackoverflow.com/questions/55076778/why-isnt-this-function-type-annotated-correctly-error-missing-type-parameters
-if TYPE_CHECKING:
-    PathLike = os.PathLike[Any]
-else:
-    PathLike = os.PathLike
-
-
-#: XML namespace in which all the elements are expected to reside
-NAMESPACE = "https://admin-shell.io/aas/3/0"
-
-
-# region De-serialization
-
-
-#: XML namespace as a prefix specially tailored for
-#: :py:mod:`xml.etree.ElementTree`
-_NAMESPACE_IN_CURLY_BRACKETS = f"{{{NAMESPACE}}}"
-
-
-class Element(Protocol):
-    """Behave like :py:meth:`xml.etree.ElementTree.Element`."""
-
-    @property
-    def attrib(self) -> Optional[Mapping[str, str]]:
-        """Attributes of the element"""
-        raise NotImplementedError()
-
-    @property
-    def text(self) -> Optional[str]:
-        """Text content of the element"""
-        raise NotImplementedError()
-
-    @property
-    def tail(self) -> Optional[str]:
-        """Tail text of the element"""
-        raise NotImplementedError()
-
-    @property
-    def tag(self) -> str:
-        """Tag of the element; with a namespace provided as a ``{...}`` prefix"""
-        raise NotImplementedError()
-
-    def clear(self) -> None:
-        """Behave like :py:meth:`xml.etree.ElementTree.Element.clear`."""
-        raise NotImplementedError()
-
-
-class HasIterparse(Protocol):
-    """Parse an XML document incrementally."""
-
-    # NOTE (mristin, 2022-10-26):
-    # ``self`` is not used in this context, but is necessary for Mypy,
-    # see: https://github.com/python/mypy/issues/5018 and
-    # https://github.com/python/mypy/commit/3efbc5c5e910296a60ed5b9e0e7eb11dd912c3ed#diff-e165eb7aed9dca0a5ebd93985c8cd263a6462d36ac185f9461348dc5a1396d76R9937
-
-    def iterparse(
-        self, source: TextIO, events: Optional[Sequence[str]] = None
-    ) -> Iterator[Tuple[str, Element]]:
-        """Behave like :py:func:`xml.etree.ElementTree.iterparse`."""
-
-
-class ElementSegment:
-    """Represent an element on a path to the erroneous value."""
-
-    #: Erroneous element
-    element: Final[Element]
-
-    def __init__(self, element: Element) -> None:
-        """Initialize with the given values."""
-        self.element = element
-
-    def __str__(self) -> str:
-        """
-        Render the segment as a tag without the namespace.
-
-        We deliberately omit the namespace in the tag names. If you want to actually
-        query with the resulting XPath, you have to insert the namespaces manually.
-        We did not know how to include the namespace in a meaningful way, as XPath
-        assumes namespace prefixes to be defined *outside* of the document. At least
-        the path thus rendered is informative, and you should be able to descend it
-        manually.
-        """
-        _, has_namespace, tag_wo_ns = self.element.tag.rpartition("}")
-        if not has_namespace:
-            return self.element.tag
-        else:
-            return tag_wo_ns
-
-
-class IndexSegment:
-    """Represent an element in a sequence on a path to the erroneous value."""
-
-    #: Erroneous element
-    element: Final[Element]
-
-    #: Index of the element in the sequence
-    index: Final[int]
-
-    def __init__(self, element: Element, index: int) -> None:
-        """Initialize with the given values."""
-        self.element = element
-        self.index = index
-
-    def __str__(self) -> str:
-        """Render the segment as an element wildcard with the index."""
-        return f"*[{self.index}]"
-
-
-Segment = Union[ElementSegment, IndexSegment]
-
-
-class Path:
-    """Represent the relative path to the erroneous element."""
-
-    def __init__(self) -> None:
-        """Initialize as an empty path."""
-        self._segments = []  # type: List[Segment]
-
-    @property
-    def segments(self) -> Sequence[Segment]:
-        """Get the segments of the path."""
-        return self._segments
-
-    def _prepend(self, segment: Segment) -> None:
-        """Insert the :paramref:`segment` in front of other segments."""
-        self._segments.insert(0, segment)
-
-    def __str__(self) -> str:
-        """Render the path as a relative XPath.
-
-        We omit the leading ``/`` so that you can easily prefix it as you need.
-        """
-        return "/".join(str(segment) for segment in self._segments)
-
-
-class DeserializationException(Exception):
-    """Signal that the XML de-serialization could not be performed."""
-
-    #: Human-readable explanation of the exception's cause
-    cause: Final[str]
-
-    #: Relative path to the erroneous value
-    path: Final[Path]
-
-    def __init__(self, cause: str) -> None:
-        """Initialize with the given :paramref:`cause` and an empty path."""
-        self.cause = cause
-        self.path = Path()
-
-
-def _with_elements_cleared_after_yield(
-    iterator: Iterator[Tuple[str, Element]]
-) -> Iterator[Tuple[str, Element]]:
-    """
-    Map the :paramref:`iterator` such that the element is ``clear()``'ed
-    *after* every ``yield``.
-
-    :param iterator: to be mapped
-    :yield: event and element from :paramref:`iterator`
-    """
-    for event, element in iterator:
-        yield event, element
-        element.clear()
-
-
-def has_semantics_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.HasSemantics:
-    """
-    Read an instance of :py:class:`.types.HasSemantics` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.has_semantics_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasSemantics` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for HasSemantics, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for HasSemantics, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_has_semantics_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def has_semantics_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.HasSemantics:
-    """
-    Read an instance of :py:class:`.types.HasSemantics` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.has_semantics_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.HasSemantics` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasSemantics` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return has_semantics_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def has_semantics_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.HasSemantics:
-    """
-    Read an instance of :py:class:`.types.HasSemantics` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.has_semantics_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.HasSemantics` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasSemantics` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return has_semantics_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def has_semantics_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.HasSemantics:
-    """
-    Read an instance of :py:class:`.types.HasSemantics` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.has_semantics_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.HasSemantics` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasSemantics` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return has_semantics_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def extension_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Extension:
-    """
-    Read an instance of :py:class:`.types.Extension` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.extension_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Extension` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Extension, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Extension, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_extension_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def extension_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Extension:
-    """
-    Read an instance of :py:class:`.types.Extension` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.extension_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Extension` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Extension` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return extension_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def extension_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Extension:
-    """
-    Read an instance of :py:class:`.types.Extension` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.extension_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Extension` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Extension` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return extension_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def extension_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Extension:
-    """
-    Read an instance of :py:class:`.types.Extension` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.extension_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Extension` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Extension` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return extension_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def has_extensions_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.HasExtensions:
-    """
-    Read an instance of :py:class:`.types.HasExtensions` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.has_extensions_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasExtensions` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for HasExtensions, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for HasExtensions, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_has_extensions_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def has_extensions_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.HasExtensions:
-    """
-    Read an instance of :py:class:`.types.HasExtensions` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.has_extensions_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.HasExtensions` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasExtensions` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return has_extensions_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def has_extensions_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.HasExtensions:
-    """
-    Read an instance of :py:class:`.types.HasExtensions` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.has_extensions_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.HasExtensions` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasExtensions` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return has_extensions_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def has_extensions_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.HasExtensions:
-    """
-    Read an instance of :py:class:`.types.HasExtensions` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.has_extensions_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.HasExtensions` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasExtensions` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return has_extensions_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def referable_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Referable:
-    """
-    Read an instance of :py:class:`.types.Referable` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.referable_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Referable` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Referable, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Referable, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_referable_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def referable_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Referable:
-    """
-    Read an instance of :py:class:`.types.Referable` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.referable_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Referable` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Referable` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return referable_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def referable_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Referable:
-    """
-    Read an instance of :py:class:`.types.Referable` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.referable_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Referable` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Referable` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return referable_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def referable_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Referable:
-    """
-    Read an instance of :py:class:`.types.Referable` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.referable_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Referable` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Referable` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return referable_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def identifiable_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Identifiable:
-    """
-    Read an instance of :py:class:`.types.Identifiable` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.identifiable_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Identifiable` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Identifiable, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Identifiable, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_identifiable_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def identifiable_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Identifiable:
-    """
-    Read an instance of :py:class:`.types.Identifiable` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.identifiable_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Identifiable` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Identifiable` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return identifiable_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def identifiable_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Identifiable:
-    """
-    Read an instance of :py:class:`.types.Identifiable` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.identifiable_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Identifiable` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Identifiable` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return identifiable_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def identifiable_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Identifiable:
-    """
-    Read an instance of :py:class:`.types.Identifiable` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.identifiable_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Identifiable` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Identifiable` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return identifiable_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def has_kind_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.HasKind:
-    """
-    Read an instance of :py:class:`.types.HasKind` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.has_kind_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasKind` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for HasKind, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for HasKind, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_has_kind_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def has_kind_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.HasKind:
-    """
-    Read an instance of :py:class:`.types.HasKind` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.has_kind_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.HasKind` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasKind` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return has_kind_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def has_kind_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.HasKind:
-    """
-    Read an instance of :py:class:`.types.HasKind` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.has_kind_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.HasKind` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasKind` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return has_kind_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def has_kind_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.HasKind:
-    """
-    Read an instance of :py:class:`.types.HasKind` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.has_kind_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.HasKind` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasKind` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return has_kind_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def has_data_specification_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.HasDataSpecification:
-    """
-    Read an instance of :py:class:`.types.HasDataSpecification` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.has_data_specification_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasDataSpecification` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for HasDataSpecification, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for HasDataSpecification, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_has_data_specification_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def has_data_specification_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.HasDataSpecification:
-    """
-    Read an instance of :py:class:`.types.HasDataSpecification` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.has_data_specification_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.HasDataSpecification` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasDataSpecification` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return has_data_specification_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def has_data_specification_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.HasDataSpecification:
-    """
-    Read an instance of :py:class:`.types.HasDataSpecification` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.has_data_specification_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.HasDataSpecification` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasDataSpecification` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return has_data_specification_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def has_data_specification_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.HasDataSpecification:
-    """
-    Read an instance of :py:class:`.types.HasDataSpecification` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.has_data_specification_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.HasDataSpecification` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.HasDataSpecification` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return has_data_specification_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def administrative_information_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AdministrativeInformation:
-    """
-    Read an instance of :py:class:`.types.AdministrativeInformation` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.administrative_information_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AdministrativeInformation` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for AdministrativeInformation, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for AdministrativeInformation, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_administrative_information_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def administrative_information_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AdministrativeInformation:
-    """
-    Read an instance of :py:class:`.types.AdministrativeInformation` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.administrative_information_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.AdministrativeInformation` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AdministrativeInformation` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return administrative_information_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def administrative_information_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AdministrativeInformation:
-    """
-    Read an instance of :py:class:`.types.AdministrativeInformation` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.administrative_information_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.AdministrativeInformation` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AdministrativeInformation` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return administrative_information_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def administrative_information_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AdministrativeInformation:
-    """
-    Read an instance of :py:class:`.types.AdministrativeInformation` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.administrative_information_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.AdministrativeInformation` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AdministrativeInformation` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return administrative_information_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def qualifiable_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Qualifiable:
-    """
-    Read an instance of :py:class:`.types.Qualifiable` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.qualifiable_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Qualifiable` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Qualifiable, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Qualifiable, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_qualifiable_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def qualifiable_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Qualifiable:
-    """
-    Read an instance of :py:class:`.types.Qualifiable` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.qualifiable_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Qualifiable` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Qualifiable` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return qualifiable_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def qualifiable_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Qualifiable:
-    """
-    Read an instance of :py:class:`.types.Qualifiable` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.qualifiable_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Qualifiable` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Qualifiable` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return qualifiable_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def qualifiable_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Qualifiable:
-    """
-    Read an instance of :py:class:`.types.Qualifiable` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.qualifiable_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Qualifiable` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Qualifiable` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return qualifiable_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def qualifier_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Qualifier:
-    """
-    Read an instance of :py:class:`.types.Qualifier` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.qualifier_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Qualifier` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Qualifier, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Qualifier, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_qualifier_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def qualifier_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Qualifier:
-    """
-    Read an instance of :py:class:`.types.Qualifier` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.qualifier_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Qualifier` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Qualifier` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return qualifier_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def qualifier_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Qualifier:
-    """
-    Read an instance of :py:class:`.types.Qualifier` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.qualifier_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Qualifier` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Qualifier` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return qualifier_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def qualifier_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Qualifier:
-    """
-    Read an instance of :py:class:`.types.Qualifier` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.qualifier_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Qualifier` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Qualifier` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return qualifier_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def asset_administration_shell_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AssetAdministrationShell:
-    """
-    Read an instance of :py:class:`.types.AssetAdministrationShell` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.asset_administration_shell_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AssetAdministrationShell` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for AssetAdministrationShell, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for AssetAdministrationShell, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_asset_administration_shell_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def asset_administration_shell_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AssetAdministrationShell:
-    """
-    Read an instance of :py:class:`.types.AssetAdministrationShell` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.asset_administration_shell_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.AssetAdministrationShell` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AssetAdministrationShell` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return asset_administration_shell_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def asset_administration_shell_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AssetAdministrationShell:
-    """
-    Read an instance of :py:class:`.types.AssetAdministrationShell` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.asset_administration_shell_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.AssetAdministrationShell` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AssetAdministrationShell` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return asset_administration_shell_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def asset_administration_shell_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AssetAdministrationShell:
-    """
-    Read an instance of :py:class:`.types.AssetAdministrationShell` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.asset_administration_shell_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.AssetAdministrationShell` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AssetAdministrationShell` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return asset_administration_shell_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def asset_information_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AssetInformation:
-    """
-    Read an instance of :py:class:`.types.AssetInformation` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.asset_information_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AssetInformation` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for AssetInformation, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for AssetInformation, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_asset_information_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def asset_information_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AssetInformation:
-    """
-    Read an instance of :py:class:`.types.AssetInformation` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.asset_information_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.AssetInformation` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AssetInformation` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return asset_information_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def asset_information_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AssetInformation:
-    """
-    Read an instance of :py:class:`.types.AssetInformation` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.asset_information_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.AssetInformation` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AssetInformation` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return asset_information_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def asset_information_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AssetInformation:
-    """
-    Read an instance of :py:class:`.types.AssetInformation` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.asset_information_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.AssetInformation` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AssetInformation` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return asset_information_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def resource_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Resource:
-    """
-    Read an instance of :py:class:`.types.Resource` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.resource_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Resource` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Resource, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Resource, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_resource_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def resource_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Resource:
-    """
-    Read an instance of :py:class:`.types.Resource` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.resource_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Resource` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Resource` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return resource_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def resource_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Resource:
-    """
-    Read an instance of :py:class:`.types.Resource` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.resource_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Resource` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Resource` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return resource_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def resource_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Resource:
-    """
-    Read an instance of :py:class:`.types.Resource` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.resource_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Resource` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Resource` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return resource_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def specific_asset_id_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.SpecificAssetID:
-    """
-    Read an instance of :py:class:`.types.SpecificAssetID` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.specific_asset_id_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SpecificAssetID` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for SpecificAssetID, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for SpecificAssetID, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_specific_asset_id_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def specific_asset_id_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.SpecificAssetID:
-    """
-    Read an instance of :py:class:`.types.SpecificAssetID` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.specific_asset_id_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.SpecificAssetID` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SpecificAssetID` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return specific_asset_id_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def specific_asset_id_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.SpecificAssetID:
-    """
-    Read an instance of :py:class:`.types.SpecificAssetID` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.specific_asset_id_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.SpecificAssetID` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SpecificAssetID` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return specific_asset_id_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def specific_asset_id_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.SpecificAssetID:
-    """
-    Read an instance of :py:class:`.types.SpecificAssetID` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.specific_asset_id_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.SpecificAssetID` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SpecificAssetID` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return specific_asset_id_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def submodel_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Submodel:
-    """
-    Read an instance of :py:class:`.types.Submodel` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.submodel_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Submodel` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Submodel, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Submodel, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_submodel_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def submodel_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Submodel:
-    """
-    Read an instance of :py:class:`.types.Submodel` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.submodel_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Submodel` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Submodel` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return submodel_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def submodel_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Submodel:
-    """
-    Read an instance of :py:class:`.types.Submodel` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.submodel_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Submodel` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Submodel` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return submodel_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def submodel_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Submodel:
-    """
-    Read an instance of :py:class:`.types.Submodel` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.submodel_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Submodel` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Submodel` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return submodel_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def submodel_element_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.SubmodelElement:
-    """
-    Read an instance of :py:class:`.types.SubmodelElement` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.submodel_element_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SubmodelElement` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for SubmodelElement, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for SubmodelElement, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_submodel_element_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def submodel_element_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.SubmodelElement:
-    """
-    Read an instance of :py:class:`.types.SubmodelElement` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.submodel_element_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.SubmodelElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SubmodelElement` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return submodel_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def submodel_element_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.SubmodelElement:
-    """
-    Read an instance of :py:class:`.types.SubmodelElement` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.submodel_element_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.SubmodelElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SubmodelElement` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return submodel_element_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def submodel_element_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.SubmodelElement:
-    """
-    Read an instance of :py:class:`.types.SubmodelElement` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.submodel_element_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.SubmodelElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SubmodelElement` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return submodel_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def relationship_element_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.RelationshipElement:
-    """
-    Read an instance of :py:class:`.types.RelationshipElement` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.relationship_element_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.RelationshipElement` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for RelationshipElement, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for RelationshipElement, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_relationship_element_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def relationship_element_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.RelationshipElement:
-    """
-    Read an instance of :py:class:`.types.RelationshipElement` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.relationship_element_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.RelationshipElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.RelationshipElement` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return relationship_element_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def relationship_element_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.RelationshipElement:
-    """
-    Read an instance of :py:class:`.types.RelationshipElement` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.relationship_element_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.RelationshipElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.RelationshipElement` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return relationship_element_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def relationship_element_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.RelationshipElement:
-    """
-    Read an instance of :py:class:`.types.RelationshipElement` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.relationship_element_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.RelationshipElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.RelationshipElement` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return relationship_element_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def submodel_element_list_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.SubmodelElementList:
-    """
-    Read an instance of :py:class:`.types.SubmodelElementList` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.submodel_element_list_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SubmodelElementList` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for SubmodelElementList, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for SubmodelElementList, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_submodel_element_list_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def submodel_element_list_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.SubmodelElementList:
-    """
-    Read an instance of :py:class:`.types.SubmodelElementList` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.submodel_element_list_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.SubmodelElementList` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SubmodelElementList` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return submodel_element_list_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def submodel_element_list_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.SubmodelElementList:
-    """
-    Read an instance of :py:class:`.types.SubmodelElementList` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.submodel_element_list_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.SubmodelElementList` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SubmodelElementList` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return submodel_element_list_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def submodel_element_list_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.SubmodelElementList:
-    """
-    Read an instance of :py:class:`.types.SubmodelElementList` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.submodel_element_list_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.SubmodelElementList` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SubmodelElementList` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return submodel_element_list_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def submodel_element_collection_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.SubmodelElementCollection:
-    """
-    Read an instance of :py:class:`.types.SubmodelElementCollection` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.submodel_element_collection_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SubmodelElementCollection` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for SubmodelElementCollection, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for SubmodelElementCollection, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_submodel_element_collection_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def submodel_element_collection_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.SubmodelElementCollection:
-    """
-    Read an instance of :py:class:`.types.SubmodelElementCollection` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.submodel_element_collection_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.SubmodelElementCollection` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SubmodelElementCollection` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return submodel_element_collection_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def submodel_element_collection_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.SubmodelElementCollection:
-    """
-    Read an instance of :py:class:`.types.SubmodelElementCollection` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.submodel_element_collection_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.SubmodelElementCollection` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SubmodelElementCollection` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return submodel_element_collection_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def submodel_element_collection_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.SubmodelElementCollection:
-    """
-    Read an instance of :py:class:`.types.SubmodelElementCollection` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.submodel_element_collection_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.SubmodelElementCollection` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.SubmodelElementCollection` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return submodel_element_collection_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def data_element_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.DataElement:
-    """
-    Read an instance of :py:class:`.types.DataElement` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.data_element_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.DataElement` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for DataElement, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for DataElement, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_data_element_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def data_element_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.DataElement:
-    """
-    Read an instance of :py:class:`.types.DataElement` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.data_element_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.DataElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.DataElement` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return data_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def data_element_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.DataElement:
-    """
-    Read an instance of :py:class:`.types.DataElement` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.data_element_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.DataElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.DataElement` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return data_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def data_element_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.DataElement:
-    """
-    Read an instance of :py:class:`.types.DataElement` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.data_element_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.DataElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.DataElement` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return data_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def property_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Property:
-    """
-    Read an instance of :py:class:`.types.Property` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.property_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Property` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Property, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Property, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_property_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def property_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Property:
-    """
-    Read an instance of :py:class:`.types.Property` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.property_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Property` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Property` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return property_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def property_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Property:
-    """
-    Read an instance of :py:class:`.types.Property` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.property_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Property` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Property` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return property_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def property_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Property:
-    """
-    Read an instance of :py:class:`.types.Property` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.property_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Property` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Property` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return property_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def multi_language_property_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.MultiLanguageProperty:
-    """
-    Read an instance of :py:class:`.types.MultiLanguageProperty` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.multi_language_property_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.MultiLanguageProperty` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for MultiLanguageProperty, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for MultiLanguageProperty, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_multi_language_property_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def multi_language_property_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.MultiLanguageProperty:
-    """
-    Read an instance of :py:class:`.types.MultiLanguageProperty` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.multi_language_property_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.MultiLanguageProperty` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.MultiLanguageProperty` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return multi_language_property_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def multi_language_property_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.MultiLanguageProperty:
-    """
-    Read an instance of :py:class:`.types.MultiLanguageProperty` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.multi_language_property_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.MultiLanguageProperty` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.MultiLanguageProperty` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return multi_language_property_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def multi_language_property_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.MultiLanguageProperty:
-    """
-    Read an instance of :py:class:`.types.MultiLanguageProperty` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.multi_language_property_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.MultiLanguageProperty` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.MultiLanguageProperty` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return multi_language_property_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def range_from_iterparse(iterator: Iterator[Tuple[str, Element]]) -> aas_types.Range:
-    """
-    Read an instance of :py:class:`.types.Range` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.range_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Range` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Range, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Range, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_range_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def range_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Range:
-    """
-    Read an instance of :py:class:`.types.Range` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.range_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Range` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Range` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return range_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def range_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Range:
-    """
-    Read an instance of :py:class:`.types.Range` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.range_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Range` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Range` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return range_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def range_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Range:
-    """
-    Read an instance of :py:class:`.types.Range` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.range_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Range` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Range` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return range_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def reference_element_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ReferenceElement:
-    """
-    Read an instance of :py:class:`.types.ReferenceElement` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.reference_element_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ReferenceElement` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for ReferenceElement, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for ReferenceElement, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_reference_element_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def reference_element_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.ReferenceElement:
-    """
-    Read an instance of :py:class:`.types.ReferenceElement` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.reference_element_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.ReferenceElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ReferenceElement` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return reference_element_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def reference_element_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.ReferenceElement:
-    """
-    Read an instance of :py:class:`.types.ReferenceElement` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.reference_element_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.ReferenceElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ReferenceElement` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return reference_element_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def reference_element_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.ReferenceElement:
-    """
-    Read an instance of :py:class:`.types.ReferenceElement` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.reference_element_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.ReferenceElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ReferenceElement` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return reference_element_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def blob_from_iterparse(iterator: Iterator[Tuple[str, Element]]) -> aas_types.Blob:
-    """
-    Read an instance of :py:class:`.types.Blob` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.blob_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Blob` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Blob, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Blob, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_blob_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def blob_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Blob:
-    """
-    Read an instance of :py:class:`.types.Blob` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.blob_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Blob` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Blob` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return blob_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def blob_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Blob:
-    """
-    Read an instance of :py:class:`.types.Blob` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.blob_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Blob` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Blob` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return blob_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def blob_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Blob:
-    """
-    Read an instance of :py:class:`.types.Blob` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.blob_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Blob` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Blob` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return blob_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def file_from_iterparse(iterator: Iterator[Tuple[str, Element]]) -> aas_types.File:
-    """
-    Read an instance of :py:class:`.types.File` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.file_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.File` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for File, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for File, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_file_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def file_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.File:
-    """
-    Read an instance of :py:class:`.types.File` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.file_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.File` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.File` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return file_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def file_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.File:
-    """
-    Read an instance of :py:class:`.types.File` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.file_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.File` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.File` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return file_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def file_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.File:
-    """
-    Read an instance of :py:class:`.types.File` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.file_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.File` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.File` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return file_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def annotated_relationship_element_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AnnotatedRelationshipElement:
-    """
-    Read an instance of :py:class:`.types.AnnotatedRelationshipElement` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.annotated_relationship_element_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AnnotatedRelationshipElement` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for AnnotatedRelationshipElement, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for AnnotatedRelationshipElement, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_annotated_relationship_element_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def annotated_relationship_element_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AnnotatedRelationshipElement:
-    """
-    Read an instance of :py:class:`.types.AnnotatedRelationshipElement` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.annotated_relationship_element_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.AnnotatedRelationshipElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AnnotatedRelationshipElement` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return annotated_relationship_element_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def annotated_relationship_element_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AnnotatedRelationshipElement:
-    """
-    Read an instance of :py:class:`.types.AnnotatedRelationshipElement` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.annotated_relationship_element_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.AnnotatedRelationshipElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AnnotatedRelationshipElement` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return annotated_relationship_element_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def annotated_relationship_element_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AnnotatedRelationshipElement:
-    """
-    Read an instance of :py:class:`.types.AnnotatedRelationshipElement` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.annotated_relationship_element_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.AnnotatedRelationshipElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AnnotatedRelationshipElement` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return annotated_relationship_element_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def entity_from_iterparse(iterator: Iterator[Tuple[str, Element]]) -> aas_types.Entity:
-    """
-    Read an instance of :py:class:`.types.Entity` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.entity_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Entity` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Entity, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Entity, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_entity_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def entity_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Entity:
-    """
-    Read an instance of :py:class:`.types.Entity` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.entity_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Entity` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Entity` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return entity_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def entity_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Entity:
-    """
-    Read an instance of :py:class:`.types.Entity` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.entity_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Entity` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Entity` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return entity_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def entity_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Entity:
-    """
-    Read an instance of :py:class:`.types.Entity` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.entity_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Entity` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Entity` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return entity_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def event_payload_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.EventPayload:
-    """
-    Read an instance of :py:class:`.types.EventPayload` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.event_payload_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.EventPayload` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for EventPayload, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for EventPayload, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_event_payload_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def event_payload_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.EventPayload:
-    """
-    Read an instance of :py:class:`.types.EventPayload` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.event_payload_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.EventPayload` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.EventPayload` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return event_payload_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def event_payload_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.EventPayload:
-    """
-    Read an instance of :py:class:`.types.EventPayload` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.event_payload_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.EventPayload` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.EventPayload` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return event_payload_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def event_payload_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.EventPayload:
-    """
-    Read an instance of :py:class:`.types.EventPayload` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.event_payload_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.EventPayload` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.EventPayload` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return event_payload_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def event_element_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.EventElement:
-    """
-    Read an instance of :py:class:`.types.EventElement` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.event_element_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.EventElement` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for EventElement, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for EventElement, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_event_element_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def event_element_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.EventElement:
-    """
-    Read an instance of :py:class:`.types.EventElement` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.event_element_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.EventElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.EventElement` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return event_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def event_element_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.EventElement:
-    """
-    Read an instance of :py:class:`.types.EventElement` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.event_element_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.EventElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.EventElement` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return event_element_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def event_element_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.EventElement:
-    """
-    Read an instance of :py:class:`.types.EventElement` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.event_element_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.EventElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.EventElement` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return event_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def basic_event_element_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.BasicEventElement:
-    """
-    Read an instance of :py:class:`.types.BasicEventElement` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.basic_event_element_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.BasicEventElement` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for BasicEventElement, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for BasicEventElement, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_basic_event_element_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def basic_event_element_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.BasicEventElement:
-    """
-    Read an instance of :py:class:`.types.BasicEventElement` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.basic_event_element_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.BasicEventElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.BasicEventElement` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return basic_event_element_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def basic_event_element_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.BasicEventElement:
-    """
-    Read an instance of :py:class:`.types.BasicEventElement` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.basic_event_element_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.BasicEventElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.BasicEventElement` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return basic_event_element_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def basic_event_element_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.BasicEventElement:
-    """
-    Read an instance of :py:class:`.types.BasicEventElement` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.basic_event_element_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.BasicEventElement` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.BasicEventElement` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return basic_event_element_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def operation_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Operation:
-    """
-    Read an instance of :py:class:`.types.Operation` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.operation_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Operation` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Operation, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Operation, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_operation_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def operation_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Operation:
-    """
-    Read an instance of :py:class:`.types.Operation` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.operation_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Operation` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Operation` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return operation_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def operation_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Operation:
-    """
-    Read an instance of :py:class:`.types.Operation` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.operation_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Operation` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Operation` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return operation_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def operation_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Operation:
-    """
-    Read an instance of :py:class:`.types.Operation` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.operation_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Operation` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Operation` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return operation_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def operation_variable_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.OperationVariable:
-    """
-    Read an instance of :py:class:`.types.OperationVariable` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.operation_variable_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.OperationVariable` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for OperationVariable, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for OperationVariable, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_operation_variable_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def operation_variable_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.OperationVariable:
-    """
-    Read an instance of :py:class:`.types.OperationVariable` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.operation_variable_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.OperationVariable` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.OperationVariable` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return operation_variable_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def operation_variable_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.OperationVariable:
-    """
-    Read an instance of :py:class:`.types.OperationVariable` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.operation_variable_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.OperationVariable` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.OperationVariable` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return operation_variable_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def operation_variable_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.OperationVariable:
-    """
-    Read an instance of :py:class:`.types.OperationVariable` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.operation_variable_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.OperationVariable` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.OperationVariable` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return operation_variable_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def capability_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Capability:
-    """
-    Read an instance of :py:class:`.types.Capability` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.capability_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Capability` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Capability, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Capability, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_capability_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def capability_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Capability:
-    """
-    Read an instance of :py:class:`.types.Capability` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.capability_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Capability` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Capability` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return capability_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def capability_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Capability:
-    """
-    Read an instance of :py:class:`.types.Capability` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.capability_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Capability` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Capability` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return capability_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def capability_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Capability:
-    """
-    Read an instance of :py:class:`.types.Capability` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.capability_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Capability` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Capability` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return capability_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def concept_description_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ConceptDescription:
-    """
-    Read an instance of :py:class:`.types.ConceptDescription` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.concept_description_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ConceptDescription` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for ConceptDescription, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for ConceptDescription, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_concept_description_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def concept_description_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.ConceptDescription:
-    """
-    Read an instance of :py:class:`.types.ConceptDescription` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.concept_description_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.ConceptDescription` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ConceptDescription` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return concept_description_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def concept_description_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.ConceptDescription:
-    """
-    Read an instance of :py:class:`.types.ConceptDescription` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.concept_description_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.ConceptDescription` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ConceptDescription` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return concept_description_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def concept_description_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.ConceptDescription:
-    """
-    Read an instance of :py:class:`.types.ConceptDescription` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.concept_description_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.ConceptDescription` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ConceptDescription` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return concept_description_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def reference_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Reference:
-    """
-    Read an instance of :py:class:`.types.Reference` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.reference_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Reference` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Reference, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Reference, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_reference_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def reference_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Reference:
-    """
-    Read an instance of :py:class:`.types.Reference` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.reference_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Reference` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Reference` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return reference_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def reference_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Reference:
-    """
-    Read an instance of :py:class:`.types.Reference` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.reference_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Reference` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Reference` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return reference_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def reference_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Reference:
-    """
-    Read an instance of :py:class:`.types.Reference` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.reference_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Reference` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Reference` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return reference_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def key_from_iterparse(iterator: Iterator[Tuple[str, Element]]) -> aas_types.Key:
-    """
-    Read an instance of :py:class:`.types.Key` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.key_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Key` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Key, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Key, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_key_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def key_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Key:
-    """
-    Read an instance of :py:class:`.types.Key` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.key_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Key` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Key` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return key_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def key_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Key:
-    """
-    Read an instance of :py:class:`.types.Key` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.key_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Key` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Key` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return key_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def key_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Key:
-    """
-    Read an instance of :py:class:`.types.Key` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.key_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Key` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Key` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return key_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def abstract_lang_string_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AbstractLangString:
-    """
-    Read an instance of :py:class:`.types.AbstractLangString` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.abstract_lang_string_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AbstractLangString` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for AbstractLangString, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for AbstractLangString, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_abstract_lang_string_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def abstract_lang_string_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AbstractLangString:
-    """
-    Read an instance of :py:class:`.types.AbstractLangString` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.abstract_lang_string_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.AbstractLangString` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AbstractLangString` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return abstract_lang_string_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def abstract_lang_string_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AbstractLangString:
-    """
-    Read an instance of :py:class:`.types.AbstractLangString` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.abstract_lang_string_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.AbstractLangString` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AbstractLangString` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return abstract_lang_string_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def abstract_lang_string_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.AbstractLangString:
-    """
-    Read an instance of :py:class:`.types.AbstractLangString` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.abstract_lang_string_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.AbstractLangString` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.AbstractLangString` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return abstract_lang_string_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def lang_string_name_type_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringNameType:
-    """
-    Read an instance of :py:class:`.types.LangStringNameType` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.lang_string_name_type_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringNameType` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for LangStringNameType, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for LangStringNameType, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_lang_string_name_type_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def lang_string_name_type_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringNameType:
-    """
-    Read an instance of :py:class:`.types.LangStringNameType` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.lang_string_name_type_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.LangStringNameType` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringNameType` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return lang_string_name_type_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def lang_string_name_type_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringNameType:
-    """
-    Read an instance of :py:class:`.types.LangStringNameType` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.lang_string_name_type_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.LangStringNameType` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringNameType` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return lang_string_name_type_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def lang_string_name_type_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringNameType:
-    """
-    Read an instance of :py:class:`.types.LangStringNameType` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.lang_string_name_type_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.LangStringNameType` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringNameType` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return lang_string_name_type_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def lang_string_text_type_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringTextType:
-    """
-    Read an instance of :py:class:`.types.LangStringTextType` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.lang_string_text_type_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringTextType` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for LangStringTextType, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for LangStringTextType, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_lang_string_text_type_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def lang_string_text_type_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringTextType:
-    """
-    Read an instance of :py:class:`.types.LangStringTextType` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.lang_string_text_type_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.LangStringTextType` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringTextType` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return lang_string_text_type_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def lang_string_text_type_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringTextType:
-    """
-    Read an instance of :py:class:`.types.LangStringTextType` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.lang_string_text_type_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.LangStringTextType` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringTextType` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return lang_string_text_type_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def lang_string_text_type_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringTextType:
-    """
-    Read an instance of :py:class:`.types.LangStringTextType` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.lang_string_text_type_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.LangStringTextType` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringTextType` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return lang_string_text_type_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def environment_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Environment:
-    """
-    Read an instance of :py:class:`.types.Environment` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.environment_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Environment` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for Environment, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for Environment, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_environment_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def environment_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Environment:
-    """
-    Read an instance of :py:class:`.types.Environment` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.environment_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.Environment` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Environment` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return environment_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def environment_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Environment:
-    """
-    Read an instance of :py:class:`.types.Environment` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.environment_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.Environment` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Environment` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return environment_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def environment_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.Environment:
-    """
-    Read an instance of :py:class:`.types.Environment` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.environment_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.Environment` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.Environment` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return environment_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def data_specification_content_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.DataSpecificationContent:
-    """
-    Read an instance of :py:class:`.types.DataSpecificationContent` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.data_specification_content_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.DataSpecificationContent` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for DataSpecificationContent, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for DataSpecificationContent, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_data_specification_content_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def data_specification_content_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.DataSpecificationContent:
-    """
-    Read an instance of :py:class:`.types.DataSpecificationContent` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.data_specification_content_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.DataSpecificationContent` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.DataSpecificationContent` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return data_specification_content_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def data_specification_content_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.DataSpecificationContent:
-    """
-    Read an instance of :py:class:`.types.DataSpecificationContent` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.data_specification_content_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.DataSpecificationContent` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.DataSpecificationContent` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return data_specification_content_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def data_specification_content_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.DataSpecificationContent:
-    """
-    Read an instance of :py:class:`.types.DataSpecificationContent` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.data_specification_content_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.DataSpecificationContent` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.DataSpecificationContent` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return data_specification_content_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def embedded_data_specification_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.EmbeddedDataSpecification:
-    """
-    Read an instance of :py:class:`.types.EmbeddedDataSpecification` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.embedded_data_specification_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.EmbeddedDataSpecification` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for EmbeddedDataSpecification, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for EmbeddedDataSpecification, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_embedded_data_specification_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def embedded_data_specification_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.EmbeddedDataSpecification:
-    """
-    Read an instance of :py:class:`.types.EmbeddedDataSpecification` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.embedded_data_specification_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.EmbeddedDataSpecification` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.EmbeddedDataSpecification` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return embedded_data_specification_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def embedded_data_specification_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.EmbeddedDataSpecification:
-    """
-    Read an instance of :py:class:`.types.EmbeddedDataSpecification` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.embedded_data_specification_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.EmbeddedDataSpecification` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.EmbeddedDataSpecification` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return embedded_data_specification_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def embedded_data_specification_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.EmbeddedDataSpecification:
-    """
-    Read an instance of :py:class:`.types.EmbeddedDataSpecification` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.embedded_data_specification_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.EmbeddedDataSpecification` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.EmbeddedDataSpecification` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return embedded_data_specification_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def level_type_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LevelType:
-    """
-    Read an instance of :py:class:`.types.LevelType` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.level_type_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LevelType` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for LevelType, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for LevelType, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_level_type_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def level_type_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LevelType:
-    """
-    Read an instance of :py:class:`.types.LevelType` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.level_type_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.LevelType` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LevelType` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return level_type_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def level_type_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LevelType:
-    """
-    Read an instance of :py:class:`.types.LevelType` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.level_type_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.LevelType` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LevelType` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return level_type_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def level_type_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LevelType:
-    """
-    Read an instance of :py:class:`.types.LevelType` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.level_type_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.LevelType` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LevelType` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return level_type_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def value_reference_pair_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ValueReferencePair:
-    """
-    Read an instance of :py:class:`.types.ValueReferencePair` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.value_reference_pair_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ValueReferencePair` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for ValueReferencePair, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for ValueReferencePair, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_value_reference_pair_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def value_reference_pair_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.ValueReferencePair:
-    """
-    Read an instance of :py:class:`.types.ValueReferencePair` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.value_reference_pair_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.ValueReferencePair` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ValueReferencePair` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return value_reference_pair_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def value_reference_pair_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.ValueReferencePair:
-    """
-    Read an instance of :py:class:`.types.ValueReferencePair` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.value_reference_pair_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.ValueReferencePair` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ValueReferencePair` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return value_reference_pair_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def value_reference_pair_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.ValueReferencePair:
-    """
-    Read an instance of :py:class:`.types.ValueReferencePair` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.value_reference_pair_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.ValueReferencePair` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ValueReferencePair` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return value_reference_pair_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def value_list_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ValueList:
-    """
-    Read an instance of :py:class:`.types.ValueList` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.value_list_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ValueList` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for ValueList, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for ValueList, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_value_list_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def value_list_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.ValueList:
-    """
-    Read an instance of :py:class:`.types.ValueList` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.value_list_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.ValueList` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ValueList` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return value_list_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def value_list_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.ValueList:
-    """
-    Read an instance of :py:class:`.types.ValueList` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.value_list_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.ValueList` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ValueList` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return value_list_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def value_list_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.ValueList:
-    """
-    Read an instance of :py:class:`.types.ValueList` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.value_list_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.ValueList` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.ValueList` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return value_list_from_iterparse(_with_elements_cleared_after_yield(iterator))
-
-
-def lang_string_preferred_name_type_iec_61360_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringPreferredNameTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.lang_string_preferred_name_type_iec_61360_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for LangStringPreferredNameTypeIEC61360, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for LangStringPreferredNameTypeIEC61360, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_lang_string_preferred_name_type_iec_61360_as_element(
-            next_element, iterator
-        )
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def lang_string_preferred_name_type_iec_61360_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringPreferredNameTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.lang_string_preferred_name_type_iec_61360_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.LangStringPreferredNameTypeIEC61360` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return lang_string_preferred_name_type_iec_61360_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def lang_string_preferred_name_type_iec_61360_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringPreferredNameTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.lang_string_preferred_name_type_iec_61360_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.LangStringPreferredNameTypeIEC61360` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return lang_string_preferred_name_type_iec_61360_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def lang_string_preferred_name_type_iec_61360_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringPreferredNameTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.lang_string_preferred_name_type_iec_61360_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.LangStringPreferredNameTypeIEC61360` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return lang_string_preferred_name_type_iec_61360_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def lang_string_short_name_type_iec_61360_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringShortNameTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringShortNameTypeIEC61360` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.lang_string_short_name_type_iec_61360_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringShortNameTypeIEC61360` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for LangStringShortNameTypeIEC61360, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for LangStringShortNameTypeIEC61360, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_lang_string_short_name_type_iec_61360_as_element(
-            next_element, iterator
-        )
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def lang_string_short_name_type_iec_61360_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringShortNameTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringShortNameTypeIEC61360` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.lang_string_short_name_type_iec_61360_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.LangStringShortNameTypeIEC61360` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringShortNameTypeIEC61360` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return lang_string_short_name_type_iec_61360_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def lang_string_short_name_type_iec_61360_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringShortNameTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringShortNameTypeIEC61360` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.lang_string_short_name_type_iec_61360_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.LangStringShortNameTypeIEC61360` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringShortNameTypeIEC61360` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return lang_string_short_name_type_iec_61360_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def lang_string_short_name_type_iec_61360_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringShortNameTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringShortNameTypeIEC61360` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.lang_string_short_name_type_iec_61360_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.LangStringShortNameTypeIEC61360` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringShortNameTypeIEC61360` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return lang_string_short_name_type_iec_61360_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def lang_string_definition_type_iec_61360_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringDefinitionTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.lang_string_definition_type_iec_61360_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for LangStringDefinitionTypeIEC61360, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for LangStringDefinitionTypeIEC61360, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_lang_string_definition_type_iec_61360_as_element(
-            next_element, iterator
-        )
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def lang_string_definition_type_iec_61360_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringDefinitionTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.lang_string_definition_type_iec_61360_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.LangStringDefinitionTypeIEC61360` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return lang_string_definition_type_iec_61360_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def lang_string_definition_type_iec_61360_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringDefinitionTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.lang_string_definition_type_iec_61360_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.LangStringDefinitionTypeIEC61360` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return lang_string_definition_type_iec_61360_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def lang_string_definition_type_iec_61360_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.LangStringDefinitionTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.lang_string_definition_type_iec_61360_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.LangStringDefinitionTypeIEC61360` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return lang_string_definition_type_iec_61360_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def data_specification_iec_61360_from_iterparse(
-    iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.DataSpecificationIEC61360:
-    """
-    Read an instance of :py:class:`.types.DataSpecificationIEC61360` from
-    the :paramref:`iterator`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import xml.etree.ElementTree as ET
-
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        with path.open("rt") as fid:
-            iterator = ET.iterparse(
-                source=fid,
-                events=['start', 'end']
-            )
-            instance = aas_xmlization.data_specification_iec_61360_from_iterparse(
-                iterator
-            )
-
-        # Do something with the ``instance``
-
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.DataSpecificationIEC61360` read from
-        :paramref:`iterator`
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            # fmt: off
-            "Expected the start element for DataSpecificationIEC61360, "
-            "but got the end-of-input"
-            # fmt: on
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "start":
-        raise DeserializationException(
-            f"Expected the start element for DataSpecificationIEC61360, "
-            f"but got event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    try:
-        return _read_data_specification_iec_61360_as_element(next_element, iterator)
-    except DeserializationException as exception:
-        exception.path._prepend(ElementSegment(next_element))
-        raise exception
-
-
-def data_specification_iec_61360_from_stream(
-    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.DataSpecificationIEC61360:
-    """
-    Read an instance of :py:class:`.types.DataSpecificationIEC61360` from
-    the :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import aas_core3.xmlization as aas_xmlization
-
-        with open_some_stream_over_network(...) as stream:
-            instance = aas_xmlization.data_specification_iec_61360_from_stream(
-                stream
-            )
-
-        # Do something with the ``instance``
-
-    :param stream:
-        representing an instance of
-        :py:class:`.types.DataSpecificationIEC61360` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.DataSpecificationIEC61360` read from
-        :paramref:`stream`
-    """
-    iterator = has_iterparse.iterparse(stream, ["start", "end"])
-    return data_specification_iec_61360_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-def data_specification_iec_61360_from_file(
-    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.DataSpecificationIEC61360:
-    """
-    Read an instance of :py:class:`.types.DataSpecificationIEC61360` from
-    the :paramref:`path`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        path = pathlib.Path(...)
-        instance = aas_xmlization.data_specification_iec_61360_from_file(
-            path
-        )
-
-        # Do something with the ``instance``
-
-    :param path:
-        to the file representing an instance of
-        :py:class:`.types.DataSpecificationIEC61360` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.DataSpecificationIEC61360` read from
-        :paramref:`path`
-    """
-    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
-        iterator = has_iterparse.iterparse(fid, ["start", "end"])
-        return data_specification_iec_61360_from_iterparse(
-            _with_elements_cleared_after_yield(iterator)
-        )
-
-
-def data_specification_iec_61360_from_str(
-    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
-) -> aas_types.DataSpecificationIEC61360:
-    """
-    Read an instance of :py:class:`.types.DataSpecificationIEC61360` from
-    the :paramref:`text`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-        import aas_core3.xmlization as aas_xmlization
-
-        text = "<...>...</...>"
-        instance = aas_xmlization.data_specification_iec_61360_from_str(
-            text
-        )
-
-        # Do something with the ``instance``
-
-    :param text:
-        representing an instance of
-        :py:class:`.types.DataSpecificationIEC61360` in XML
-    :param has_iterparse:
-        Module containing ``iterparse`` function.
-
-        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
-        library. If you have to deal with malicious input, consider using
-        a library such as `defusedxml.ElementTree`_.
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return:
-        Instance of :py:class:`.types.DataSpecificationIEC61360` read from
-        :paramref:`text`
-    """
-    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
-    return data_specification_iec_61360_from_iterparse(
-        _with_elements_cleared_after_yield(iterator)
-    )
-
-
-# NOTE (mristin, 2022-10-08):
-# Directly using the iterator turned out to result in very complex function
-# designs. The design became much simpler as soon as we considered one look-ahead
-# element. We came up finally with the following pattern which all the protected
-# reading functions below roughly follow:
-#
-# ..code-block::
-#
-#    _read_*(
-#       look-ahead element,
-#       iterator
-#    ) -> result
-#
-# The reading functions all read from the ``iterator`` coming from
-# :py:func:`xml.etree.ElementTree.iterparse` with the argument
-# ``events=["start", "end"]``. The exception :py:class:`.DeserializationException`
-# is raised in case of unexpected input.
-#
-# The reading functions are responsible to read the end element corresponding to the
-# start look-ahead element.
-#
-# When it comes to error reporting, we use exceptions. The exceptions are raised in
-# the *callee*, as usual. However, the context of the exception, such as the error path,
-# is added in the *caller*, as only the caller knows the context of
-# the lookahead-element. In particular, prepending the path segment corresponding to
-# the lookahead-element is the responsibility of the *caller*, and not of
-# the *callee*.
-
-
-def _parse_element_tag(element: Element) -> str:
-    """
-    Extract the tag name without the namespace prefix from :paramref:`element`.
-
-    :param element: whose tag without namespace we want to extract
-    :return: tag name without the namespace prefix
-    :raise: :py:class:`DeserializationException` if unexpected :paramref:`element`
-    """
-    if not element.tag.startswith(_NAMESPACE_IN_CURLY_BRACKETS):
-        namespace, got_namespace, tag_wo_ns = element.tag.rpartition("}")
-        if got_namespace:
-            if namespace.startswith("{"):
-                namespace = namespace[1:]
-
-            raise DeserializationException(
-                f"Expected the element in the namespace {NAMESPACE!r}, "
-                f"but got the element {tag_wo_ns!r} in the namespace {namespace!r}"
-            )
-        else:
-            raise DeserializationException(
-                f"Expected the element in the namespace {NAMESPACE!r}, "
-                f"but got the element {tag_wo_ns!r} without the namespace prefix"
-            )
-
-    return element.tag[len(_NAMESPACE_IN_CURLY_BRACKETS) :]
-
-
-def _raise_if_has_tail_or_attrib(element: Element) -> None:
-    """
-    Check that :paramref:`element` has no trailing text and no attributes.
-
-    :param element: to be verified
-    :raise:
-        :py:class:`.DeserializationException` if trailing text or attributes;
-        conforming to the convention about handling error paths,
-        the exception path is left empty.
-    """
-    if element.tail is not None and len(element.tail.strip()) != 0:
-        raise DeserializationException(
-            f"Expected no trailing text, but got: {element.tail!r}"
-        )
-
-    if element.attrib is not None and len(element.attrib) > 0:
-        raise DeserializationException(
-            f"Expected no attributes, but got: {element.attrib}"
-        )
-
-
-def _read_end_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> None:
-    """
-    Read the end element corresponding to the start :paramref:`element`
-    from :paramref:`iterator`.
-
-    :param element: corresponding start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    """
-    next_event_element = next(iterator, None)
-    if next_event_element is None:
-        raise DeserializationException(
-            f"Expected the end element for {element.tag}, " f"but got the end-of-input"
-        )
-
-    next_event, next_element = next_event_element
-    if next_event != "end" or next_element.tag != element.tag:
-        raise DeserializationException(
-            f"Expected the end element for {element.tag!r}, "
-            f"but got the event {next_event!r} and element {next_element.tag!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(next_element)
-
-
-def _read_text_from_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> str:
-    """
-    Extract the text from the :paramref:`element`, and read
-    the end element from :paramref:`iterator`.
-
-    The :paramref:`element` is expected to contain text. Otherwise,
-    it is considered as unexpected input.
-
-    :param element: start element enclosing the text
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    """
-    _raise_if_has_tail_or_attrib(element)
-
-    if element.text is None:
-        raise DeserializationException(
-            "Expected an element with text, but got an element with no text."
-        )
-
-    text = element.text
-
-    _read_end_element(element, iterator)
-
-    return text
-
-
-_XS_BOOLEAN_LITERAL_SET = {
-    "1",
-    "true",
-    "0",
-    "false",
-}
-
-
-def _read_bool_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> bool:
-    """
-    Parse the text of :paramref:`element` as a boolean, and
-    read the corresponding end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    if text not in _XS_BOOLEAN_LITERAL_SET:
-        raise DeserializationException(
-            f"Expected a boolean, " f"but got an element with text: {text!r}"
-        )
-
-    return text in ("1", "true")
-
-
-def _read_int_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> int:
-    """
-    Parse the text of :paramref:`element` as an integer, and
-    read the corresponding end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    try:
-        value = int(text)
-    except ValueError:
-        # pylint: disable=raise-missing-from
-        raise DeserializationException(
-            f"Expected an integer, " f"but got an element with text: {text!r}"
-        )
-
-    return value
-
-
-_TEXT_TO_XS_DOUBLE_LITERALS = {
-    "NaN": math.nan,
-    "INF": math.inf,
-    "-INF": -math.inf,
-}
-
-
-def _read_float_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> float:
-    """
-    Parse the text of :paramref:`element` as a floating-point number, and
-    read the corresponding end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    value = _TEXT_TO_XS_DOUBLE_LITERALS.get(text, None)
-    if value is None:
-        try:
-            value = float(text)
-        except ValueError:
-            # pylint: disable=raise-missing-from
-            raise DeserializationException(
-                f"Expected a floating-point number, "
-                f"but got an element with text: {text!r}"
-            )
-
-    return value
-
-
-def _read_str_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> str:
-    """
-    Parse the text of :paramref:`element` as a string, and
-    read the corresponding end element from :paramref:`iterator`.
-
-    If there is no text, empty string is returned.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    # NOTE (mristin, 2022-10-26):
-    # We do not use ``_read_text_from_element`` as that function expects
-    # the ``element`` to contain *some* text. In contrast, this function
-    # can also deal with empty text, in which case it returns an empty string.
-
-    _raise_if_has_tail_or_attrib(element)
-    result = element.text if element.text is not None else ""
-
-    _read_end_element(element, iterator)
-
-    return result
-
-
-def _read_bytes_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> bytes:
-    """
-    Parse the text of :paramref:`element` as base64-encoded bytes, and
-    read the corresponding end element from :paramref:`iterator`.
-
-    :param element: look-ahead element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    try:
-        value = base64.b64decode(text)
-    except Exception:
-        # pylint: disable=raise-missing-from
-        raise DeserializationException(
-            f"Expected a text as base64-encoded bytes, "
-            f"but got an element with text: {text!r}"
-        )
-
-    return value
-
-
-def _read_has_semantics_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.HasSemantics:
-    """
-    Read an instance of :py:class:`.types.HasSemantics` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_HAS_SEMANTICS.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'HasSemantics', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForExtension:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Extension`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Extension`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.name: Optional[str] = None
-        self.value_type: Optional[aas_types.DataTypeDefXSD] = None
-        self.value: Optional[str] = None
-        self.refers_to: Optional[List[aas_types.Reference]] = None
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Extension.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Extension.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Extension.name` and set it.
-        """
-        self.name = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_value_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Extension.value_type` and set it.
-        """
-        self.value_type = _read_data_type_def_xsd_from_element_text(element, iterator)
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Extension.value` and set it.
-        """
-        self.value = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_refers_to(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Extension.refers_to` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.refers_to = result
-
-
-def _read_extension_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Extension:
-    """
-    Read an instance of :py:class:`.types.Extension`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForExtension()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_EXTENSION.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.name is None:
-        raise DeserializationException("The required property 'name' is missing")
-
-    return aas_types.Extension(
-        reader_and_setter.name,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.value_type,
-        reader_and_setter.value,
-        reader_and_setter.refers_to,
-    )
-
-
-def _read_extension_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Extension:
-    """
-    Read an instance of :py:class:`.types.Extension` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "extension":
-        raise DeserializationException(
-            f"Expected the element with the tag 'extension', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_extension_as_sequence(element, iterator)
-
-
-def _read_has_extensions_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.HasExtensions:
-    """
-    Read an instance of :py:class:`.types.HasExtensions` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_HAS_EXTENSIONS.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'HasExtensions', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-def _read_referable_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Referable:
-    """
-    Read an instance of :py:class:`.types.Referable` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_REFERABLE.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'Referable', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-def _read_identifiable_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Identifiable:
-    """
-    Read an instance of :py:class:`.types.Identifiable` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_IDENTIFIABLE.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'Identifiable', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-def _read_modelling_kind_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ModellingKind:
-    """
-    Parse the text of :paramref:`element` as a literal of
-    :py:class:`.types.ModellingKind`, and read the corresponding
-    end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    literal = aas_stringification.modelling_kind_from_str(text)
-    if literal is None:
-        raise DeserializationException(
-            f"Not a valid string representation of "
-            f"a literal of ModellingKind: {text}"
-        )
-
-    return literal
-
-
-def _read_has_kind_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.HasKind:
-    """
-    Read an instance of :py:class:`.types.HasKind` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_HAS_KIND.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'HasKind', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-def _read_has_data_specification_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.HasDataSpecification:
-    """
-    Read an instance of :py:class:`.types.HasDataSpecification` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_HAS_DATA_SPECIFICATION.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'HasDataSpecification', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForAdministrativeInformation:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`AdministrativeInformation`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`AdministrativeInformation`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.version: Optional[str] = None
-        self.revision: Optional[str] = None
-        self.creator: Optional[aas_types.Reference] = None
-        self.template_id: Optional[str] = None
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AdministrativeInformation.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_version(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AdministrativeInformation.version` and set it.
-        """
-        self.version = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_revision(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AdministrativeInformation.revision` and set it.
-        """
-        self.revision = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_creator(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AdministrativeInformation.creator` and set it.
-        """
-        self.creator = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_template_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AdministrativeInformation.template_id` and set it.
-        """
-        self.template_id = _read_str_from_element_text(element, iterator)
-
-
-def _read_administrative_information_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AdministrativeInformation:
-    """
-    Read an instance of :py:class:`.types.AdministrativeInformation`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForAdministrativeInformation()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_ADMINISTRATIVE_INFORMATION.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    return aas_types.AdministrativeInformation(
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.version,
-        reader_and_setter.revision,
-        reader_and_setter.creator,
-        reader_and_setter.template_id,
-    )
-
-
-def _read_administrative_information_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AdministrativeInformation:
-    """
-    Read an instance of :py:class:`.types.AdministrativeInformation` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "administrativeInformation":
-        raise DeserializationException(
-            f"Expected the element with the tag 'administrativeInformation', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_administrative_information_as_sequence(element, iterator)
-
-
-def _read_qualifiable_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Qualifiable:
-    """
-    Read an instance of :py:class:`.types.Qualifiable` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_QUALIFIABLE.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'Qualifiable', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-def _read_qualifier_kind_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.QualifierKind:
-    """
-    Parse the text of :paramref:`element` as a literal of
-    :py:class:`.types.QualifierKind`, and read the corresponding
-    end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    literal = aas_stringification.qualifier_kind_from_str(text)
-    if literal is None:
-        raise DeserializationException(
-            f"Not a valid string representation of "
-            f"a literal of QualifierKind: {text}"
-        )
-
-    return literal
-
-
-class _ReaderAndSetterForQualifier:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Qualifier`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Qualifier`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.kind: Optional[aas_types.QualifierKind] = None
-        self.type: Optional[str] = None
-        self.value_type: Optional[aas_types.DataTypeDefXSD] = None
-        self.value: Optional[str] = None
-        self.value_id: Optional[aas_types.Reference] = None
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Qualifier.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Qualifier.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_kind(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Qualifier.kind` and set it.
-        """
-        self.kind = _read_qualifier_kind_from_element_text(element, iterator)
-
-    def read_and_set_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Qualifier.type` and set it.
-        """
-        self.type = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_value_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Qualifier.value_type` and set it.
-        """
-        self.value_type = _read_data_type_def_xsd_from_element_text(element, iterator)
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Qualifier.value` and set it.
-        """
-        self.value = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_value_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Qualifier.value_id` and set it.
-        """
-        self.value_id = _read_reference_as_sequence(element, iterator)
-
-
-def _read_qualifier_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Qualifier:
-    """
-    Read an instance of :py:class:`.types.Qualifier`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForQualifier()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_QUALIFIER.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.type is None:
-        raise DeserializationException("The required property 'type' is missing")
-
-    if reader_and_setter.value_type is None:
-        raise DeserializationException("The required property 'valueType' is missing")
-
-    return aas_types.Qualifier(
-        reader_and_setter.type,
-        reader_and_setter.value_type,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.kind,
-        reader_and_setter.value,
-        reader_and_setter.value_id,
-    )
-
-
-def _read_qualifier_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Qualifier:
-    """
-    Read an instance of :py:class:`.types.Qualifier` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "qualifier":
-        raise DeserializationException(
-            f"Expected the element with the tag 'qualifier', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_qualifier_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForAssetAdministrationShell:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`AssetAdministrationShell`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`AssetAdministrationShell`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.administration: Optional[aas_types.AdministrativeInformation] = None
-        self.id: Optional[str] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.derived_from: Optional[aas_types.Reference] = None
-        self.asset_information: Optional[aas_types.AssetInformation] = None
-        self.submodels: Optional[List[aas_types.Reference]] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetAdministrationShell.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetAdministrationShell.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetAdministrationShell.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetAdministrationShell.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetAdministrationShell.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_administration(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetAdministrationShell.administration` and set it.
-        """
-        self.administration = _read_administrative_information_as_sequence(
-            element, iterator
-        )
-
-    def read_and_set_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetAdministrationShell.id` and set it.
-        """
-        self.id = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetAdministrationShell.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_derived_from(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetAdministrationShell.derived_from` and set it.
-        """
-        self.derived_from = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_asset_information(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetAdministrationShell.asset_information` and set it.
-        """
-        self.asset_information = _read_asset_information_as_sequence(element, iterator)
-
-    def read_and_set_submodels(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetAdministrationShell.submodels` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.submodels = result
-
-
-def _read_asset_administration_shell_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AssetAdministrationShell:
-    """
-    Read an instance of :py:class:`.types.AssetAdministrationShell`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForAssetAdministrationShell()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_ASSET_ADMINISTRATION_SHELL.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.id is None:
-        raise DeserializationException("The required property 'id' is missing")
-
-    if reader_and_setter.asset_information is None:
-        raise DeserializationException(
-            "The required property 'assetInformation' is missing"
-        )
-
-    return aas_types.AssetAdministrationShell(
-        reader_and_setter.id,
-        reader_and_setter.asset_information,
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.administration,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.derived_from,
-        reader_and_setter.submodels,
-    )
-
-
-def _read_asset_administration_shell_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AssetAdministrationShell:
-    """
-    Read an instance of :py:class:`.types.AssetAdministrationShell` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "assetAdministrationShell":
-        raise DeserializationException(
-            f"Expected the element with the tag 'assetAdministrationShell', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_asset_administration_shell_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForAssetInformation:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`AssetInformation`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`AssetInformation`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.asset_kind: Optional[aas_types.AssetKind] = None
-        self.global_asset_id: Optional[str] = None
-        self.specific_asset_ids: Optional[List[aas_types.SpecificAssetID]] = None
-        self.asset_type: Optional[str] = None
-        self.default_thumbnail: Optional[aas_types.Resource] = None
-
-    def read_and_set_asset_kind(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetInformation.asset_kind` and set it.
-        """
-        self.asset_kind = _read_asset_kind_from_element_text(element, iterator)
-
-    def read_and_set_global_asset_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetInformation.global_asset_id` and set it.
-        """
-        self.global_asset_id = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_specific_asset_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetInformation.specific_asset_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.SpecificAssetID] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_specific_asset_id_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.specific_asset_ids = result
-
-    def read_and_set_asset_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetInformation.asset_type` and set it.
-        """
-        self.asset_type = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_default_thumbnail(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AssetInformation.default_thumbnail` and set it.
-        """
-        self.default_thumbnail = _read_resource_as_sequence(element, iterator)
-
-
-def _read_asset_information_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AssetInformation:
-    """
-    Read an instance of :py:class:`.types.AssetInformation`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForAssetInformation()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_ASSET_INFORMATION.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.asset_kind is None:
-        raise DeserializationException("The required property 'assetKind' is missing")
-
-    return aas_types.AssetInformation(
-        reader_and_setter.asset_kind,
-        reader_and_setter.global_asset_id,
-        reader_and_setter.specific_asset_ids,
-        reader_and_setter.asset_type,
-        reader_and_setter.default_thumbnail,
-    )
-
-
-def _read_asset_information_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AssetInformation:
-    """
-    Read an instance of :py:class:`.types.AssetInformation` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "assetInformation":
-        raise DeserializationException(
-            f"Expected the element with the tag 'assetInformation', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_asset_information_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForResource:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Resource`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Resource`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.path: Optional[str] = None
-        self.content_type: Optional[str] = None
-
-    def read_and_set_path(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Resource.path` and set it.
-        """
-        self.path = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_content_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Resource.content_type` and set it.
-        """
-        self.content_type = _read_str_from_element_text(element, iterator)
-
-
-def _read_resource_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Resource:
-    """
-    Read an instance of :py:class:`.types.Resource`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForResource()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_RESOURCE.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.path is None:
-        raise DeserializationException("The required property 'path' is missing")
-
-    return aas_types.Resource(reader_and_setter.path, reader_and_setter.content_type)
-
-
-def _read_resource_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Resource:
-    """
-    Read an instance of :py:class:`.types.Resource` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "resource":
-        raise DeserializationException(
-            f"Expected the element with the tag 'resource', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_resource_as_sequence(element, iterator)
-
-
-def _read_asset_kind_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AssetKind:
-    """
-    Parse the text of :paramref:`element` as a literal of
-    :py:class:`.types.AssetKind`, and read the corresponding
-    end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    literal = aas_stringification.asset_kind_from_str(text)
-    if literal is None:
-        raise DeserializationException(
-            f"Not a valid string representation of " f"a literal of AssetKind: {text}"
-        )
-
-    return literal
-
-
-class _ReaderAndSetterForSpecificAssetID:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`SpecificAssetID`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`SpecificAssetID`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.name: Optional[str] = None
-        self.value: Optional[str] = None
-        self.external_subject_id: Optional[aas_types.Reference] = None
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SpecificAssetID.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SpecificAssetID.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SpecificAssetID.name` and set it.
-        """
-        self.name = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SpecificAssetID.value` and set it.
-        """
-        self.value = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_external_subject_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SpecificAssetID.external_subject_id` and set it.
-        """
-        self.external_subject_id = _read_reference_as_sequence(element, iterator)
-
-
-def _read_specific_asset_id_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.SpecificAssetID:
-    """
-    Read an instance of :py:class:`.types.SpecificAssetID`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForSpecificAssetID()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_SPECIFIC_ASSET_ID.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.name is None:
-        raise DeserializationException("The required property 'name' is missing")
-
-    if reader_and_setter.value is None:
-        raise DeserializationException("The required property 'value' is missing")
-
-    return aas_types.SpecificAssetID(
-        reader_and_setter.name,
-        reader_and_setter.value,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.external_subject_id,
-    )
-
-
-def _read_specific_asset_id_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.SpecificAssetID:
-    """
-    Read an instance of :py:class:`.types.SpecificAssetID` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "specificAssetId":
-        raise DeserializationException(
-            f"Expected the element with the tag 'specificAssetId', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_specific_asset_id_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForSubmodel:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Submodel`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Submodel`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.administration: Optional[aas_types.AdministrativeInformation] = None
-        self.id: Optional[str] = None
-        self.kind: Optional[aas_types.ModellingKind] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.submodel_elements: Optional[List[aas_types.SubmodelElement]] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_administration(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.administration` and set it.
-        """
-        self.administration = _read_administrative_information_as_sequence(
-            element, iterator
-        )
-
-    def read_and_set_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.id` and set it.
-        """
-        self.id = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_kind(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.kind` and set it.
-        """
-        self.kind = _read_modelling_kind_from_element_text(element, iterator)
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_submodel_elements(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Submodel.submodel_elements` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.SubmodelElement] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_submodel_element_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.submodel_elements = result
-
-
-def _read_submodel_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Submodel:
-    """
-    Read an instance of :py:class:`.types.Submodel`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForSubmodel()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_SUBMODEL.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.id is None:
-        raise DeserializationException("The required property 'id' is missing")
-
-    return aas_types.Submodel(
-        reader_and_setter.id,
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.administration,
-        reader_and_setter.kind,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.submodel_elements,
-    )
-
-
-def _read_submodel_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Submodel:
-    """
-    Read an instance of :py:class:`.types.Submodel` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "submodel":
-        raise DeserializationException(
-            f"Expected the element with the tag 'submodel', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_submodel_as_sequence(element, iterator)
-
-
-def _read_submodel_element_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.SubmodelElement:
-    """
-    Read an instance of :py:class:`.types.SubmodelElement` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_SUBMODEL_ELEMENT.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'SubmodelElement', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForRelationshipElement:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`RelationshipElement`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`RelationshipElement`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.first: Optional[aas_types.Reference] = None
-        self.second: Optional[aas_types.Reference] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.RelationshipElement.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.RelationshipElement.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.RelationshipElement.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.RelationshipElement.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.RelationshipElement.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.RelationshipElement.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.RelationshipElement.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.RelationshipElement.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.RelationshipElement.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_first(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.RelationshipElement.first` and set it.
-        """
-        self.first = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_second(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.RelationshipElement.second` and set it.
-        """
-        self.second = _read_reference_as_sequence(element, iterator)
-
-
-def _read_relationship_element_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.RelationshipElement:
-    """
-    Read an instance of :py:class:`.types.RelationshipElement`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForRelationshipElement()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_RELATIONSHIP_ELEMENT.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.first is None:
-        raise DeserializationException("The required property 'first' is missing")
-
-    if reader_and_setter.second is None:
-        raise DeserializationException("The required property 'second' is missing")
-
-    return aas_types.RelationshipElement(
-        reader_and_setter.first,
-        reader_and_setter.second,
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-    )
-
-
-def _read_relationship_element_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.RelationshipElement:
-    """
-    Read an instance of :py:class:`.types.RelationshipElement` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_RELATIONSHIP_ELEMENT.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'RelationshipElement', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-def _read_aas_submodel_elements_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AASSubmodelElements:
-    """
-    Parse the text of :paramref:`element` as a literal of
-    :py:class:`.types.AASSubmodelElements`, and read the corresponding
-    end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    literal = aas_stringification.aas_submodel_elements_from_str(text)
-    if literal is None:
-        raise DeserializationException(
-            f"Not a valid string representation of "
-            f"a literal of AASSubmodelElements: {text}"
-        )
-
-    return literal
-
-
-class _ReaderAndSetterForSubmodelElementList:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`SubmodelElementList`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`SubmodelElementList`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.order_relevant: Optional[bool] = None
-        self.semantic_id_list_element: Optional[aas_types.Reference] = None
-        self.type_value_list_element: Optional[aas_types.AASSubmodelElements] = None
-        self.value_type_list_element: Optional[aas_types.DataTypeDefXSD] = None
-        self.value: Optional[List[aas_types.SubmodelElement]] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_order_relevant(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.order_relevant` and set it.
-        """
-        self.order_relevant = _read_bool_from_element_text(element, iterator)
-
-    def read_and_set_semantic_id_list_element(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.semantic_id_list_element` and set it.
-        """
-        self.semantic_id_list_element = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_type_value_list_element(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.type_value_list_element` and set it.
-        """
-        self.type_value_list_element = _read_aas_submodel_elements_from_element_text(
-            element, iterator
-        )
-
-    def read_and_set_value_type_list_element(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.value_type_list_element` and set it.
-        """
-        self.value_type_list_element = _read_data_type_def_xsd_from_element_text(
-            element, iterator
-        )
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementList.value` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.SubmodelElement] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_submodel_element_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.value = result
-
-
-def _read_submodel_element_list_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.SubmodelElementList:
-    """
-    Read an instance of :py:class:`.types.SubmodelElementList`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForSubmodelElementList()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_SUBMODEL_ELEMENT_LIST.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.type_value_list_element is None:
-        raise DeserializationException(
-            "The required property 'typeValueListElement' is missing"
-        )
-
-    return aas_types.SubmodelElementList(
-        reader_and_setter.type_value_list_element,
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.order_relevant,
-        reader_and_setter.semantic_id_list_element,
-        reader_and_setter.value_type_list_element,
-        reader_and_setter.value,
-    )
-
-
-def _read_submodel_element_list_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.SubmodelElementList:
-    """
-    Read an instance of :py:class:`.types.SubmodelElementList` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "submodelElementList":
-        raise DeserializationException(
-            f"Expected the element with the tag 'submodelElementList', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_submodel_element_list_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForSubmodelElementCollection:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`SubmodelElementCollection`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`SubmodelElementCollection`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.value: Optional[List[aas_types.SubmodelElement]] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementCollection.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementCollection.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementCollection.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementCollection.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementCollection.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementCollection.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementCollection.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementCollection.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementCollection.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.SubmodelElementCollection.value` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.SubmodelElement] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_submodel_element_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.value = result
-
-
-def _read_submodel_element_collection_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.SubmodelElementCollection:
-    """
-    Read an instance of :py:class:`.types.SubmodelElementCollection`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForSubmodelElementCollection()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = (
-            _READ_AND_SET_DISPATCH_FOR_SUBMODEL_ELEMENT_COLLECTION.get(tag_wo_ns, None)
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    return aas_types.SubmodelElementCollection(
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.value,
-    )
-
-
-def _read_submodel_element_collection_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.SubmodelElementCollection:
-    """
-    Read an instance of :py:class:`.types.SubmodelElementCollection` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "submodelElementCollection":
-        raise DeserializationException(
-            f"Expected the element with the tag 'submodelElementCollection', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_submodel_element_collection_as_sequence(element, iterator)
-
-
-def _read_data_element_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.DataElement:
-    """
-    Read an instance of :py:class:`.types.DataElement` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_DATA_ELEMENT.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'DataElement', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForProperty:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Property`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Property`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.value_type: Optional[aas_types.DataTypeDefXSD] = None
-        self.value: Optional[str] = None
-        self.value_id: Optional[aas_types.Reference] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Property.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Property.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Property.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Property.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Property.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Property.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Property.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Property.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Property.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_value_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Property.value_type` and set it.
-        """
-        self.value_type = _read_data_type_def_xsd_from_element_text(element, iterator)
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Property.value` and set it.
-        """
-        self.value = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_value_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Property.value_id` and set it.
-        """
-        self.value_id = _read_reference_as_sequence(element, iterator)
-
-
-def _read_property_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Property:
-    """
-    Read an instance of :py:class:`.types.Property`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForProperty()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_PROPERTY.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.value_type is None:
-        raise DeserializationException("The required property 'valueType' is missing")
-
-    return aas_types.Property(
-        reader_and_setter.value_type,
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.value,
-        reader_and_setter.value_id,
-    )
-
-
-def _read_property_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Property:
-    """
-    Read an instance of :py:class:`.types.Property` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "property":
-        raise DeserializationException(
-            f"Expected the element with the tag 'property', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_property_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForMultiLanguageProperty:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`MultiLanguageProperty`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`MultiLanguageProperty`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.value: Optional[List[aas_types.LangStringTextType]] = None
-        self.value_id: Optional[aas_types.Reference] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.MultiLanguageProperty.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.MultiLanguageProperty.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.MultiLanguageProperty.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.MultiLanguageProperty.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.MultiLanguageProperty.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.MultiLanguageProperty.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.MultiLanguageProperty.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.MultiLanguageProperty.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.MultiLanguageProperty.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.MultiLanguageProperty.value` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.value = result
-
-    def read_and_set_value_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.MultiLanguageProperty.value_id` and set it.
-        """
-        self.value_id = _read_reference_as_sequence(element, iterator)
-
-
-def _read_multi_language_property_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.MultiLanguageProperty:
-    """
-    Read an instance of :py:class:`.types.MultiLanguageProperty`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForMultiLanguageProperty()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_MULTI_LANGUAGE_PROPERTY.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    return aas_types.MultiLanguageProperty(
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.value,
-        reader_and_setter.value_id,
-    )
-
-
-def _read_multi_language_property_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.MultiLanguageProperty:
-    """
-    Read an instance of :py:class:`.types.MultiLanguageProperty` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "multiLanguageProperty":
-        raise DeserializationException(
-            f"Expected the element with the tag 'multiLanguageProperty', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_multi_language_property_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForRange:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Range`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Range`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.value_type: Optional[aas_types.DataTypeDefXSD] = None
-        self.min: Optional[str] = None
-        self.max: Optional[str] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Range.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Range.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Range.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Range.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Range.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Range.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Range.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Range.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Range.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_value_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Range.value_type` and set it.
-        """
-        self.value_type = _read_data_type_def_xsd_from_element_text(element, iterator)
-
-    def read_and_set_min(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Range.min` and set it.
-        """
-        self.min = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_max(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Range.max` and set it.
-        """
-        self.max = _read_str_from_element_text(element, iterator)
-
-
-def _read_range_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Range:
-    """
-    Read an instance of :py:class:`.types.Range`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForRange()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_RANGE.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.value_type is None:
-        raise DeserializationException("The required property 'valueType' is missing")
-
-    return aas_types.Range(
-        reader_and_setter.value_type,
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.min,
-        reader_and_setter.max,
-    )
-
-
-def _read_range_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Range:
-    """
-    Read an instance of :py:class:`.types.Range` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "range":
-        raise DeserializationException(
-            f"Expected the element with the tag 'range', " f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_range_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForReferenceElement:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`ReferenceElement`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`ReferenceElement`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.value: Optional[aas_types.Reference] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ReferenceElement.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ReferenceElement.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ReferenceElement.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ReferenceElement.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ReferenceElement.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ReferenceElement.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ReferenceElement.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ReferenceElement.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ReferenceElement.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ReferenceElement.value` and set it.
-        """
-        self.value = _read_reference_as_sequence(element, iterator)
-
-
-def _read_reference_element_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ReferenceElement:
-    """
-    Read an instance of :py:class:`.types.ReferenceElement`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForReferenceElement()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_REFERENCE_ELEMENT.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    return aas_types.ReferenceElement(
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.value,
-    )
-
-
-def _read_reference_element_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ReferenceElement:
-    """
-    Read an instance of :py:class:`.types.ReferenceElement` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "referenceElement":
-        raise DeserializationException(
-            f"Expected the element with the tag 'referenceElement', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_reference_element_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForBlob:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Blob`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Blob`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.value: Optional[bytes] = None
-        self.content_type: Optional[str] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Blob.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Blob.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Blob.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Blob.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Blob.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Blob.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Blob.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Blob.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Blob.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Blob.value` and set it.
-        """
-        self.value = _read_bytes_from_element_text(element, iterator)
-
-    def read_and_set_content_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Blob.content_type` and set it.
-        """
-        self.content_type = _read_str_from_element_text(element, iterator)
-
-
-def _read_blob_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Blob:
-    """
-    Read an instance of :py:class:`.types.Blob`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForBlob()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_BLOB.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.content_type is None:
-        raise DeserializationException("The required property 'contentType' is missing")
-
-    return aas_types.Blob(
-        reader_and_setter.content_type,
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.value,
-    )
-
-
-def _read_blob_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Blob:
-    """
-    Read an instance of :py:class:`.types.Blob` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "blob":
-        raise DeserializationException(
-            f"Expected the element with the tag 'blob', " f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_blob_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForFile:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`File`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`File`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.value: Optional[str] = None
-        self.content_type: Optional[str] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.File.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.File.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.File.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.File.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.File.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.File.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.File.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.File.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.File.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.File.value` and set it.
-        """
-        self.value = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_content_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.File.content_type` and set it.
-        """
-        self.content_type = _read_str_from_element_text(element, iterator)
-
-
-def _read_file_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.File:
-    """
-    Read an instance of :py:class:`.types.File`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForFile()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_FILE.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.content_type is None:
-        raise DeserializationException("The required property 'contentType' is missing")
-
-    return aas_types.File(
-        reader_and_setter.content_type,
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.value,
-    )
-
-
-def _read_file_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.File:
-    """
-    Read an instance of :py:class:`.types.File` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "file":
-        raise DeserializationException(
-            f"Expected the element with the tag 'file', " f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_file_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForAnnotatedRelationshipElement:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`AnnotatedRelationshipElement`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`AnnotatedRelationshipElement`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.first: Optional[aas_types.Reference] = None
-        self.second: Optional[aas_types.Reference] = None
-        self.annotations: Optional[List[aas_types.DataElement]] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AnnotatedRelationshipElement.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AnnotatedRelationshipElement.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AnnotatedRelationshipElement.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AnnotatedRelationshipElement.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AnnotatedRelationshipElement.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AnnotatedRelationshipElement.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AnnotatedRelationshipElement.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AnnotatedRelationshipElement.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AnnotatedRelationshipElement.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_first(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AnnotatedRelationshipElement.first` and set it.
-        """
-        self.first = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_second(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AnnotatedRelationshipElement.second` and set it.
-        """
-        self.second = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_annotations(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.AnnotatedRelationshipElement.annotations` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.DataElement] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_data_element_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.annotations = result
-
-
-def _read_annotated_relationship_element_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AnnotatedRelationshipElement:
-    """
-    Read an instance of :py:class:`.types.AnnotatedRelationshipElement`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForAnnotatedRelationshipElement()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = (
-            _READ_AND_SET_DISPATCH_FOR_ANNOTATED_RELATIONSHIP_ELEMENT.get(
-                tag_wo_ns, None
-            )
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.first is None:
-        raise DeserializationException("The required property 'first' is missing")
-
-    if reader_and_setter.second is None:
-        raise DeserializationException("The required property 'second' is missing")
-
-    return aas_types.AnnotatedRelationshipElement(
-        reader_and_setter.first,
-        reader_and_setter.second,
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.annotations,
-    )
-
-
-def _read_annotated_relationship_element_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AnnotatedRelationshipElement:
-    """
-    Read an instance of :py:class:`.types.AnnotatedRelationshipElement` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "annotatedRelationshipElement":
-        raise DeserializationException(
-            f"Expected the element with the tag 'annotatedRelationshipElement', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_annotated_relationship_element_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForEntity:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Entity`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Entity`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.statements: Optional[List[aas_types.SubmodelElement]] = None
-        self.entity_type: Optional[aas_types.EntityType] = None
-        self.global_asset_id: Optional[str] = None
-        self.specific_asset_ids: Optional[List[aas_types.SpecificAssetID]] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_statements(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.statements` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.SubmodelElement] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_submodel_element_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.statements = result
-
-    def read_and_set_entity_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.entity_type` and set it.
-        """
-        self.entity_type = _read_entity_type_from_element_text(element, iterator)
-
-    def read_and_set_global_asset_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.global_asset_id` and set it.
-        """
-        self.global_asset_id = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_specific_asset_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Entity.specific_asset_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.SpecificAssetID] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_specific_asset_id_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.specific_asset_ids = result
-
-
-def _read_entity_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Entity:
-    """
-    Read an instance of :py:class:`.types.Entity`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForEntity()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_ENTITY.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.entity_type is None:
-        raise DeserializationException("The required property 'entityType' is missing")
-
-    return aas_types.Entity(
-        reader_and_setter.entity_type,
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.statements,
-        reader_and_setter.global_asset_id,
-        reader_and_setter.specific_asset_ids,
-    )
-
-
-def _read_entity_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Entity:
-    """
-    Read an instance of :py:class:`.types.Entity` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "entity":
-        raise DeserializationException(
-            f"Expected the element with the tag 'entity', " f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_entity_as_sequence(element, iterator)
-
-
-def _read_entity_type_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.EntityType:
-    """
-    Parse the text of :paramref:`element` as a literal of
-    :py:class:`.types.EntityType`, and read the corresponding
-    end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    literal = aas_stringification.entity_type_from_str(text)
-    if literal is None:
-        raise DeserializationException(
-            f"Not a valid string representation of " f"a literal of EntityType: {text}"
-        )
-
-    return literal
-
-
-def _read_direction_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Direction:
-    """
-    Parse the text of :paramref:`element` as a literal of
-    :py:class:`.types.Direction`, and read the corresponding
-    end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    literal = aas_stringification.direction_from_str(text)
-    if literal is None:
-        raise DeserializationException(
-            f"Not a valid string representation of " f"a literal of Direction: {text}"
-        )
-
-    return literal
-
-
-def _read_state_of_event_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.StateOfEvent:
-    """
-    Parse the text of :paramref:`element` as a literal of
-    :py:class:`.types.StateOfEvent`, and read the corresponding
-    end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    literal = aas_stringification.state_of_event_from_str(text)
-    if literal is None:
-        raise DeserializationException(
-            f"Not a valid string representation of "
-            f"a literal of StateOfEvent: {text}"
-        )
-
-    return literal
-
-
-class _ReaderAndSetterForEventPayload:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`EventPayload`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`EventPayload`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.source: Optional[aas_types.Reference] = None
-        self.source_semantic_id: Optional[aas_types.Reference] = None
-        self.observable_reference: Optional[aas_types.Reference] = None
-        self.observable_semantic_id: Optional[aas_types.Reference] = None
-        self.topic: Optional[str] = None
-        self.subject_id: Optional[aas_types.Reference] = None
-        self.time_stamp: Optional[str] = None
-        self.payload: Optional[bytes] = None
-
-    def read_and_set_source(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.EventPayload.source` and set it.
-        """
-        self.source = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_source_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.EventPayload.source_semantic_id` and set it.
-        """
-        self.source_semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_observable_reference(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.EventPayload.observable_reference` and set it.
-        """
-        self.observable_reference = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_observable_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.EventPayload.observable_semantic_id` and set it.
-        """
-        self.observable_semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_topic(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.EventPayload.topic` and set it.
-        """
-        self.topic = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_subject_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.EventPayload.subject_id` and set it.
-        """
-        self.subject_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_time_stamp(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.EventPayload.time_stamp` and set it.
-        """
-        self.time_stamp = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_payload(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.EventPayload.payload` and set it.
-        """
-        self.payload = _read_bytes_from_element_text(element, iterator)
-
-
-def _read_event_payload_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.EventPayload:
-    """
-    Read an instance of :py:class:`.types.EventPayload`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForEventPayload()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_EVENT_PAYLOAD.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.source is None:
-        raise DeserializationException("The required property 'source' is missing")
-
-    if reader_and_setter.observable_reference is None:
-        raise DeserializationException(
-            "The required property 'observableReference' is missing"
-        )
-
-    if reader_and_setter.time_stamp is None:
-        raise DeserializationException("The required property 'timeStamp' is missing")
-
-    return aas_types.EventPayload(
-        reader_and_setter.source,
-        reader_and_setter.observable_reference,
-        reader_and_setter.time_stamp,
-        reader_and_setter.source_semantic_id,
-        reader_and_setter.observable_semantic_id,
-        reader_and_setter.topic,
-        reader_and_setter.subject_id,
-        reader_and_setter.payload,
-    )
-
-
-def _read_event_payload_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.EventPayload:
-    """
-    Read an instance of :py:class:`.types.EventPayload` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "eventPayload":
-        raise DeserializationException(
-            f"Expected the element with the tag 'eventPayload', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_event_payload_as_sequence(element, iterator)
-
-
-def _read_event_element_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.EventElement:
-    """
-    Read an instance of :py:class:`.types.EventElement` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_EVENT_ELEMENT.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'EventElement', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForBasicEventElement:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`BasicEventElement`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`BasicEventElement`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.observed: Optional[aas_types.Reference] = None
-        self.direction: Optional[aas_types.Direction] = None
-        self.state: Optional[aas_types.StateOfEvent] = None
-        self.message_topic: Optional[str] = None
-        self.message_broker: Optional[aas_types.Reference] = None
-        self.last_update: Optional[str] = None
-        self.min_interval: Optional[str] = None
-        self.max_interval: Optional[str] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_observed(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.observed` and set it.
-        """
-        self.observed = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_direction(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.direction` and set it.
-        """
-        self.direction = _read_direction_from_element_text(element, iterator)
-
-    def read_and_set_state(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.state` and set it.
-        """
-        self.state = _read_state_of_event_from_element_text(element, iterator)
-
-    def read_and_set_message_topic(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.message_topic` and set it.
-        """
-        self.message_topic = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_message_broker(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.message_broker` and set it.
-        """
-        self.message_broker = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_last_update(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.last_update` and set it.
-        """
-        self.last_update = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_min_interval(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.min_interval` and set it.
-        """
-        self.min_interval = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_max_interval(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.BasicEventElement.max_interval` and set it.
-        """
-        self.max_interval = _read_str_from_element_text(element, iterator)
-
-
-def _read_basic_event_element_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.BasicEventElement:
-    """
-    Read an instance of :py:class:`.types.BasicEventElement`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForBasicEventElement()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_BASIC_EVENT_ELEMENT.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.observed is None:
-        raise DeserializationException("The required property 'observed' is missing")
-
-    if reader_and_setter.direction is None:
-        raise DeserializationException("The required property 'direction' is missing")
-
-    if reader_and_setter.state is None:
-        raise DeserializationException("The required property 'state' is missing")
-
-    return aas_types.BasicEventElement(
-        reader_and_setter.observed,
-        reader_and_setter.direction,
-        reader_and_setter.state,
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.message_topic,
-        reader_and_setter.message_broker,
-        reader_and_setter.last_update,
-        reader_and_setter.min_interval,
-        reader_and_setter.max_interval,
-    )
-
-
-def _read_basic_event_element_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.BasicEventElement:
-    """
-    Read an instance of :py:class:`.types.BasicEventElement` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "basicEventElement":
-        raise DeserializationException(
-            f"Expected the element with the tag 'basicEventElement', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_basic_event_element_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForOperation:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Operation`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Operation`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.input_variables: Optional[List[aas_types.OperationVariable]] = None
-        self.output_variables: Optional[List[aas_types.OperationVariable]] = None
-        self.inoutput_variables: Optional[List[aas_types.OperationVariable]] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Operation.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Operation.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Operation.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Operation.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Operation.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Operation.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Operation.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Operation.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Operation.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_input_variables(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Operation.input_variables` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.OperationVariable] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_operation_variable_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.input_variables = result
-
-    def read_and_set_output_variables(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Operation.output_variables` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.OperationVariable] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_operation_variable_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.output_variables = result
-
-    def read_and_set_inoutput_variables(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Operation.inoutput_variables` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.OperationVariable] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_operation_variable_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.inoutput_variables = result
-
-
-def _read_operation_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Operation:
-    """
-    Read an instance of :py:class:`.types.Operation`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForOperation()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_OPERATION.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    return aas_types.Operation(
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.input_variables,
-        reader_and_setter.output_variables,
-        reader_and_setter.inoutput_variables,
-    )
-
-
-def _read_operation_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Operation:
-    """
-    Read an instance of :py:class:`.types.Operation` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "operation":
-        raise DeserializationException(
-            f"Expected the element with the tag 'operation', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_operation_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForOperationVariable:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`OperationVariable`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`OperationVariable`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.value: Optional[aas_types.SubmodelElement] = None
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.OperationVariable.value` and set it.
-        """
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected a discriminator start element corresponding "
-                "to SubmodelElement, but got end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event != "start":
-            raise DeserializationException(
-                f"Expected a discriminator start element corresponding "
-                f"to SubmodelElement, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            result = _read_submodel_element_as_element(next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        _read_end_element(element, iterator)
-
-        self.value = result
-
-
-def _read_operation_variable_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.OperationVariable:
-    """
-    Read an instance of :py:class:`.types.OperationVariable`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForOperationVariable()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_OPERATION_VARIABLE.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.value is None:
-        raise DeserializationException("The required property 'value' is missing")
-
-    return aas_types.OperationVariable(reader_and_setter.value)
-
-
-def _read_operation_variable_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.OperationVariable:
-    """
-    Read an instance of :py:class:`.types.OperationVariable` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "operationVariable":
-        raise DeserializationException(
-            f"Expected the element with the tag 'operationVariable', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_operation_variable_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForCapability:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Capability`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Capability`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.semantic_id: Optional[aas_types.Reference] = None
-        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
-        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Capability.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Capability.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Capability.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Capability.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Capability.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Capability.semantic_id` and set it.
-        """
-        self.semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_supplemental_semantic_ids(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Capability.supplemental_semantic_ids` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.supplemental_semantic_ids = result
-
-    def read_and_set_qualifiers(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Capability.qualifiers` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Qualifier] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_qualifier_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.qualifiers = result
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Capability.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-
-def _read_capability_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Capability:
-    """
-    Read an instance of :py:class:`.types.Capability`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForCapability()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_CAPABILITY.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    return aas_types.Capability(
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.semantic_id,
-        reader_and_setter.supplemental_semantic_ids,
-        reader_and_setter.qualifiers,
-        reader_and_setter.embedded_data_specifications,
-    )
-
-
-def _read_capability_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Capability:
-    """
-    Read an instance of :py:class:`.types.Capability` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "capability":
-        raise DeserializationException(
-            f"Expected the element with the tag 'capability', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_capability_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForConceptDescription:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`ConceptDescription`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`ConceptDescription`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.extensions: Optional[List[aas_types.Extension]] = None
-        self.category: Optional[str] = None
-        self.id_short: Optional[str] = None
-        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
-        self.description: Optional[List[aas_types.LangStringTextType]] = None
-        self.administration: Optional[aas_types.AdministrativeInformation] = None
-        self.id: Optional[str] = None
-        self.embedded_data_specifications: Optional[
-            List[aas_types.EmbeddedDataSpecification]
-        ] = None
-        self.is_case_of: Optional[List[aas_types.Reference]] = None
-
-    def read_and_set_extensions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ConceptDescription.extensions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Extension] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_extension_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.extensions = result
-
-    def read_and_set_category(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ConceptDescription.category` and set it.
-        """
-        self.category = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_id_short(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ConceptDescription.id_short` and set it.
-        """
-        self.id_short = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_display_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ConceptDescription.display_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringNameType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_name_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.display_name = result
-
-    def read_and_set_description(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ConceptDescription.description` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringTextType] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_text_type_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.description = result
-
-    def read_and_set_administration(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ConceptDescription.administration` and set it.
-        """
-        self.administration = _read_administrative_information_as_sequence(
-            element, iterator
-        )
-
-    def read_and_set_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ConceptDescription.id` and set it.
-        """
-        self.id = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_embedded_data_specifications(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ConceptDescription.embedded_data_specifications` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.EmbeddedDataSpecification] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_embedded_data_specification_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.embedded_data_specifications = result
-
-    def read_and_set_is_case_of(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ConceptDescription.is_case_of` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Reference] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_reference_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.is_case_of = result
-
-
-def _read_concept_description_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ConceptDescription:
-    """
-    Read an instance of :py:class:`.types.ConceptDescription`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForConceptDescription()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_CONCEPT_DESCRIPTION.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.id is None:
-        raise DeserializationException("The required property 'id' is missing")
-
-    return aas_types.ConceptDescription(
-        reader_and_setter.id,
-        reader_and_setter.extensions,
-        reader_and_setter.category,
-        reader_and_setter.id_short,
-        reader_and_setter.display_name,
-        reader_and_setter.description,
-        reader_and_setter.administration,
-        reader_and_setter.embedded_data_specifications,
-        reader_and_setter.is_case_of,
-    )
-
-
-def _read_concept_description_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ConceptDescription:
-    """
-    Read an instance of :py:class:`.types.ConceptDescription` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "conceptDescription":
-        raise DeserializationException(
-            f"Expected the element with the tag 'conceptDescription', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_concept_description_as_sequence(element, iterator)
-
-
-def _read_reference_types_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ReferenceTypes:
-    """
-    Parse the text of :paramref:`element` as a literal of
-    :py:class:`.types.ReferenceTypes`, and read the corresponding
-    end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    literal = aas_stringification.reference_types_from_str(text)
-    if literal is None:
-        raise DeserializationException(
-            f"Not a valid string representation of "
-            f"a literal of ReferenceTypes: {text}"
-        )
-
-    return literal
-
-
-class _ReaderAndSetterForReference:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Reference`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Reference`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.type: Optional[aas_types.ReferenceTypes] = None
-        self.referred_semantic_id: Optional[aas_types.Reference] = None
-        self.keys: Optional[List[aas_types.Key]] = None
-
-    def read_and_set_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Reference.type` and set it.
-        """
-        self.type = _read_reference_types_from_element_text(element, iterator)
-
-    def read_and_set_referred_semantic_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Reference.referred_semantic_id` and set it.
-        """
-        self.referred_semantic_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_keys(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Reference.keys` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Key] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_key_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.keys = result
-
-
-def _read_reference_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Reference:
-    """
-    Read an instance of :py:class:`.types.Reference`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForReference()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_REFERENCE.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.type is None:
-        raise DeserializationException("The required property 'type' is missing")
-
-    if reader_and_setter.keys is None:
-        raise DeserializationException("The required property 'keys' is missing")
-
-    return aas_types.Reference(
-        reader_and_setter.type,
-        reader_and_setter.keys,
-        reader_and_setter.referred_semantic_id,
-    )
-
-
-def _read_reference_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Reference:
-    """
-    Read an instance of :py:class:`.types.Reference` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "reference":
-        raise DeserializationException(
-            f"Expected the element with the tag 'reference', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_reference_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForKey:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Key`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Key`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.type: Optional[aas_types.KeyTypes] = None
-        self.value: Optional[str] = None
-
-    def read_and_set_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Key.type` and set it.
-        """
-        self.type = _read_key_types_from_element_text(element, iterator)
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Key.value` and set it.
-        """
-        self.value = _read_str_from_element_text(element, iterator)
-
-
-def _read_key_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Key:
-    """
-    Read an instance of :py:class:`.types.Key`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForKey()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_KEY.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.type is None:
-        raise DeserializationException("The required property 'type' is missing")
-
-    if reader_and_setter.value is None:
-        raise DeserializationException("The required property 'value' is missing")
-
-    return aas_types.Key(reader_and_setter.type, reader_and_setter.value)
-
-
-def _read_key_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Key:
-    """
-    Read an instance of :py:class:`.types.Key` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "key":
-        raise DeserializationException(
-            f"Expected the element with the tag 'key', " f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_key_as_sequence(element, iterator)
-
-
-def _read_key_types_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.KeyTypes:
-    """
-    Parse the text of :paramref:`element` as a literal of
-    :py:class:`.types.KeyTypes`, and read the corresponding
-    end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    literal = aas_stringification.key_types_from_str(text)
-    if literal is None:
-        raise DeserializationException(
-            f"Not a valid string representation of " f"a literal of KeyTypes: {text}"
-        )
-
-    return literal
-
-
-def _read_data_type_def_xsd_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.DataTypeDefXSD:
-    """
-    Parse the text of :paramref:`element` as a literal of
-    :py:class:`.types.DataTypeDefXSD`, and read the corresponding
-    end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    literal = aas_stringification.data_type_def_xsd_from_str(text)
-    if literal is None:
-        raise DeserializationException(
-            f"Not a valid string representation of "
-            f"a literal of DataTypeDefXSD: {text}"
-        )
-
-    return literal
-
-
-def _read_abstract_lang_string_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.AbstractLangString:
-    """
-    Read an instance of :py:class:`.types.AbstractLangString` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_ABSTRACT_LANG_STRING.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'AbstractLangString', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForLangStringNameType:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`LangStringNameType`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`LangStringNameType`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.language: Optional[str] = None
-        self.text: Optional[str] = None
-
-    def read_and_set_language(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LangStringNameType.language` and set it.
-        """
-        self.language = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_text(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LangStringNameType.text` and set it.
-        """
-        self.text = _read_str_from_element_text(element, iterator)
-
-
-def _read_lang_string_name_type_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringNameType:
-    """
-    Read an instance of :py:class:`.types.LangStringNameType`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForLangStringNameType()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_LANG_STRING_NAME_TYPE.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.language is None:
-        raise DeserializationException("The required property 'language' is missing")
-
-    if reader_and_setter.text is None:
-        raise DeserializationException("The required property 'text' is missing")
-
-    return aas_types.LangStringNameType(
-        reader_and_setter.language, reader_and_setter.text
-    )
-
-
-def _read_lang_string_name_type_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringNameType:
-    """
-    Read an instance of :py:class:`.types.LangStringNameType` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "langStringNameType":
-        raise DeserializationException(
-            f"Expected the element with the tag 'langStringNameType', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_lang_string_name_type_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForLangStringTextType:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`LangStringTextType`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`LangStringTextType`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.language: Optional[str] = None
-        self.text: Optional[str] = None
-
-    def read_and_set_language(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LangStringTextType.language` and set it.
-        """
-        self.language = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_text(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LangStringTextType.text` and set it.
-        """
-        self.text = _read_str_from_element_text(element, iterator)
-
-
-def _read_lang_string_text_type_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringTextType:
-    """
-    Read an instance of :py:class:`.types.LangStringTextType`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForLangStringTextType()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_LANG_STRING_TEXT_TYPE.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.language is None:
-        raise DeserializationException("The required property 'language' is missing")
-
-    if reader_and_setter.text is None:
-        raise DeserializationException("The required property 'text' is missing")
-
-    return aas_types.LangStringTextType(
-        reader_and_setter.language, reader_and_setter.text
-    )
-
-
-def _read_lang_string_text_type_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringTextType:
-    """
-    Read an instance of :py:class:`.types.LangStringTextType` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "langStringTextType":
-        raise DeserializationException(
-            f"Expected the element with the tag 'langStringTextType', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_lang_string_text_type_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForEnvironment:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`Environment`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`Environment`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.asset_administration_shells: Optional[
-            List[aas_types.AssetAdministrationShell]
-        ] = None
-        self.submodels: Optional[List[aas_types.Submodel]] = None
-        self.concept_descriptions: Optional[List[aas_types.ConceptDescription]] = None
-
-    def read_and_set_asset_administration_shells(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Environment.asset_administration_shells` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.AssetAdministrationShell] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_asset_administration_shell_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.asset_administration_shells = result
-
-    def read_and_set_submodels(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Environment.submodels` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.Submodel] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_submodel_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.submodels = result
-
-    def read_and_set_concept_descriptions(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.Environment.concept_descriptions` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.ConceptDescription] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_concept_description_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.concept_descriptions = result
-
-
-def _read_environment_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Environment:
-    """
-    Read an instance of :py:class:`.types.Environment`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForEnvironment()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_ENVIRONMENT.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    return aas_types.Environment(
-        reader_and_setter.asset_administration_shells,
-        reader_and_setter.submodels,
-        reader_and_setter.concept_descriptions,
-    )
-
-
-def _read_environment_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.Environment:
-    """
-    Read an instance of :py:class:`.types.Environment` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "environment":
-        raise DeserializationException(
-            f"Expected the element with the tag 'environment', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_environment_as_sequence(element, iterator)
-
-
-def _read_data_specification_content_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.DataSpecificationContent:
-    """
-    Read an instance of :py:class:`.types.DataSpecificationContent` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-    read_as_sequence = _DISPATCH_FOR_DATA_SPECIFICATION_CONTENT.get(tag_wo_ns, None)
-
-    if read_as_sequence is None:
-        raise DeserializationException(
-            f"Expected the element tag to be a valid model type "
-            f"of a concrete instance of 'DataSpecificationContent', "
-            f"but got tag {tag_wo_ns!r}"
-        )
-
-    return read_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForEmbeddedDataSpecification:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`EmbeddedDataSpecification`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`EmbeddedDataSpecification`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.data_specification: Optional[aas_types.Reference] = None
-        self.data_specification_content: Optional[
-            aas_types.DataSpecificationContent
-        ] = None
-
-    def read_and_set_data_specification(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.EmbeddedDataSpecification.data_specification` and set it.
-        """
-        self.data_specification = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_data_specification_content(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.EmbeddedDataSpecification.data_specification_content` and set it.
-        """
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected a discriminator start element corresponding "
-                "to DataSpecificationContent, but got end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event != "start":
-            raise DeserializationException(
-                f"Expected a discriminator start element corresponding "
-                f"to DataSpecificationContent, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            result = _read_data_specification_content_as_element(next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        _read_end_element(element, iterator)
-
-        self.data_specification_content = result
-
-
-def _read_embedded_data_specification_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.EmbeddedDataSpecification:
-    """
-    Read an instance of :py:class:`.types.EmbeddedDataSpecification`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForEmbeddedDataSpecification()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = (
-            _READ_AND_SET_DISPATCH_FOR_EMBEDDED_DATA_SPECIFICATION.get(tag_wo_ns, None)
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.data_specification is None:
-        raise DeserializationException(
-            "The required property 'dataSpecification' is missing"
-        )
-
-    if reader_and_setter.data_specification_content is None:
-        raise DeserializationException(
-            "The required property 'dataSpecificationContent' is missing"
-        )
-
-    return aas_types.EmbeddedDataSpecification(
-        reader_and_setter.data_specification,
-        reader_and_setter.data_specification_content,
-    )
-
-
-def _read_embedded_data_specification_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.EmbeddedDataSpecification:
-    """
-    Read an instance of :py:class:`.types.EmbeddedDataSpecification` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "embeddedDataSpecification":
-        raise DeserializationException(
-            f"Expected the element with the tag 'embeddedDataSpecification', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_embedded_data_specification_as_sequence(element, iterator)
-
-
-def _read_data_type_iec_61360_from_element_text(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.DataTypeIEC61360:
-    """
-    Parse the text of :paramref:`element` as a literal of
-    :py:class:`.types.DataTypeIEC61360`, and read the corresponding
-    end element from :paramref:`iterator`.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed value
-    """
-    text = _read_text_from_element(element, iterator)
-
-    literal = aas_stringification.data_type_iec_61360_from_str(text)
-    if literal is None:
-        raise DeserializationException(
-            f"Not a valid string representation of "
-            f"a literal of DataTypeIEC61360: {text}"
-        )
-
-    return literal
-
-
-class _ReaderAndSetterForLevelType:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`LevelType`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`LevelType`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.min: Optional[bool] = None
-        self.nom: Optional[bool] = None
-        self.typ: Optional[bool] = None
-        self.max: Optional[bool] = None
-
-    def read_and_set_min(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LevelType.min` and set it.
-        """
-        self.min = _read_bool_from_element_text(element, iterator)
-
-    def read_and_set_nom(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LevelType.nom` and set it.
-        """
-        self.nom = _read_bool_from_element_text(element, iterator)
-
-    def read_and_set_typ(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LevelType.typ` and set it.
-        """
-        self.typ = _read_bool_from_element_text(element, iterator)
-
-    def read_and_set_max(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LevelType.max` and set it.
-        """
-        self.max = _read_bool_from_element_text(element, iterator)
-
-
-def _read_level_type_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LevelType:
-    """
-    Read an instance of :py:class:`.types.LevelType`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForLevelType()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_LEVEL_TYPE.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.min is None:
-        raise DeserializationException("The required property 'min' is missing")
-
-    if reader_and_setter.nom is None:
-        raise DeserializationException("The required property 'nom' is missing")
-
-    if reader_and_setter.typ is None:
-        raise DeserializationException("The required property 'typ' is missing")
-
-    if reader_and_setter.max is None:
-        raise DeserializationException("The required property 'max' is missing")
-
-    return aas_types.LevelType(
-        reader_and_setter.min,
-        reader_and_setter.nom,
-        reader_and_setter.typ,
-        reader_and_setter.max,
-    )
-
-
-def _read_level_type_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LevelType:
-    """
-    Read an instance of :py:class:`.types.LevelType` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "levelType":
-        raise DeserializationException(
-            f"Expected the element with the tag 'levelType', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_level_type_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForValueReferencePair:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`ValueReferencePair`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`ValueReferencePair`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.value: Optional[str] = None
-        self.value_id: Optional[aas_types.Reference] = None
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ValueReferencePair.value` and set it.
-        """
-        self.value = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_value_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ValueReferencePair.value_id` and set it.
-        """
-        self.value_id = _read_reference_as_sequence(element, iterator)
-
-
-def _read_value_reference_pair_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ValueReferencePair:
-    """
-    Read an instance of :py:class:`.types.ValueReferencePair`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForValueReferencePair()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_VALUE_REFERENCE_PAIR.get(
-            tag_wo_ns, None
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.value is None:
-        raise DeserializationException("The required property 'value' is missing")
-
-    if reader_and_setter.value_id is None:
-        raise DeserializationException("The required property 'valueId' is missing")
-
-    return aas_types.ValueReferencePair(
-        reader_and_setter.value, reader_and_setter.value_id
-    )
-
-
-def _read_value_reference_pair_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ValueReferencePair:
-    """
-    Read an instance of :py:class:`.types.ValueReferencePair` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "valueReferencePair":
-        raise DeserializationException(
-            f"Expected the element with the tag 'valueReferencePair', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_value_reference_pair_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForValueList:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`ValueList`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`ValueList`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.value_reference_pairs: Optional[List[aas_types.ValueReferencePair]] = None
-
-    def read_and_set_value_reference_pairs(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.ValueList.value_reference_pairs` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.ValueReferencePair] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_value_reference_pair_as_element(next_element, iterator)
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.value_reference_pairs = result
-
-
-def _read_value_list_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ValueList:
-    """
-    Read an instance of :py:class:`.types.ValueList`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForValueList()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_VALUE_LIST.get(tag_wo_ns, None)
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.value_reference_pairs is None:
-        raise DeserializationException(
-            "The required property 'valueReferencePairs' is missing"
-        )
-
-    return aas_types.ValueList(reader_and_setter.value_reference_pairs)
-
-
-def _read_value_list_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.ValueList:
-    """
-    Read an instance of :py:class:`.types.ValueList` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "valueList":
-        raise DeserializationException(
-            f"Expected the element with the tag 'valueList', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_value_list_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForLangStringPreferredNameTypeIEC61360:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`LangStringPreferredNameTypeIEC61360`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`LangStringPreferredNameTypeIEC61360`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.language: Optional[str] = None
-        self.text: Optional[str] = None
-
-    def read_and_set_language(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LangStringPreferredNameTypeIEC61360.language` and set it.
-        """
-        self.language = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_text(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LangStringPreferredNameTypeIEC61360.text` and set it.
-        """
-        self.text = _read_str_from_element_text(element, iterator)
-
-
-def _read_lang_string_preferred_name_type_iec_61360_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringPreferredNameTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForLangStringPreferredNameTypeIEC61360()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = (
-            _READ_AND_SET_DISPATCH_FOR_LANG_STRING_PREFERRED_NAME_TYPE_IEC_61360.get(
-                tag_wo_ns, None
-            )
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.language is None:
-        raise DeserializationException("The required property 'language' is missing")
-
-    if reader_and_setter.text is None:
-        raise DeserializationException("The required property 'text' is missing")
-
-    return aas_types.LangStringPreferredNameTypeIEC61360(
-        reader_and_setter.language, reader_and_setter.text
-    )
-
-
-def _read_lang_string_preferred_name_type_iec_61360_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringPreferredNameTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "langStringPreferredNameTypeIec61360":
-        raise DeserializationException(
-            f"Expected the element with the tag 'langStringPreferredNameTypeIec61360', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_lang_string_preferred_name_type_iec_61360_as_sequence(
-        element, iterator
-    )
-
-
-class _ReaderAndSetterForLangStringShortNameTypeIEC61360:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`LangStringShortNameTypeIEC61360`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`LangStringShortNameTypeIEC61360`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.language: Optional[str] = None
-        self.text: Optional[str] = None
-
-    def read_and_set_language(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LangStringShortNameTypeIEC61360.language` and set it.
-        """
-        self.language = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_text(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LangStringShortNameTypeIEC61360.text` and set it.
-        """
-        self.text = _read_str_from_element_text(element, iterator)
-
-
-def _read_lang_string_short_name_type_iec_61360_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringShortNameTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringShortNameTypeIEC61360`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForLangStringShortNameTypeIEC61360()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = (
-            _READ_AND_SET_DISPATCH_FOR_LANG_STRING_SHORT_NAME_TYPE_IEC_61360.get(
-                tag_wo_ns, None
-            )
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.language is None:
-        raise DeserializationException("The required property 'language' is missing")
-
-    if reader_and_setter.text is None:
-        raise DeserializationException("The required property 'text' is missing")
-
-    return aas_types.LangStringShortNameTypeIEC61360(
-        reader_and_setter.language, reader_and_setter.text
-    )
-
-
-def _read_lang_string_short_name_type_iec_61360_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringShortNameTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringShortNameTypeIEC61360` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "langStringShortNameTypeIec61360":
-        raise DeserializationException(
-            f"Expected the element with the tag 'langStringShortNameTypeIec61360', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_lang_string_short_name_type_iec_61360_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForLangStringDefinitionTypeIEC61360:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`LangStringDefinitionTypeIEC61360`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`LangStringDefinitionTypeIEC61360`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.language: Optional[str] = None
-        self.text: Optional[str] = None
-
-    def read_and_set_language(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LangStringDefinitionTypeIEC61360.language` and set it.
-        """
-        self.language = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_text(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.LangStringDefinitionTypeIEC61360.text` and set it.
-        """
-        self.text = _read_str_from_element_text(element, iterator)
-
-
-def _read_lang_string_definition_type_iec_61360_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringDefinitionTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringDefinitionTypeIEC61360`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForLangStringDefinitionTypeIEC61360()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = (
-            _READ_AND_SET_DISPATCH_FOR_LANG_STRING_DEFINITION_TYPE_IEC_61360.get(
-                tag_wo_ns, None
-            )
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.language is None:
-        raise DeserializationException("The required property 'language' is missing")
-
-    if reader_and_setter.text is None:
-        raise DeserializationException("The required property 'text' is missing")
-
-    return aas_types.LangStringDefinitionTypeIEC61360(
-        reader_and_setter.language, reader_and_setter.text
-    )
-
-
-def _read_lang_string_definition_type_iec_61360_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.LangStringDefinitionTypeIEC61360:
-    """
-    Read an instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "langStringDefinitionTypeIec61360":
-        raise DeserializationException(
-            f"Expected the element with the tag 'langStringDefinitionTypeIec61360', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_lang_string_definition_type_iec_61360_as_sequence(element, iterator)
-
-
-class _ReaderAndSetterForDataSpecificationIEC61360:
-    """
-    Provide a buffer for reading and setting the properties for the class
-    :py:class:`DataSpecificationIEC61360`.
-
-    The properties correspond to the constructor arguments of
-    :py:class:`DataSpecificationIEC61360`. We use this buffer to facilitate dispatching when
-    parsing the properties in a streaming fashion.
-    """
-
-    def __init__(self) -> None:
-        """Initialize with all the properties unset."""
-        self.preferred_name: Optional[
-            List[aas_types.LangStringPreferredNameTypeIEC61360]
-        ] = None
-        self.short_name: Optional[
-            List[aas_types.LangStringShortNameTypeIEC61360]
-        ] = None
-        self.unit: Optional[str] = None
-        self.unit_id: Optional[aas_types.Reference] = None
-        self.source_of_definition: Optional[str] = None
-        self.symbol: Optional[str] = None
-        self.data_type: Optional[aas_types.DataTypeIEC61360] = None
-        self.definition: Optional[
-            List[aas_types.LangStringDefinitionTypeIEC61360]
-        ] = None
-        self.value_format: Optional[str] = None
-        self.value_list: Optional[aas_types.ValueList] = None
-        self.value: Optional[str] = None
-        self.level_type: Optional[aas_types.LevelType] = None
-
-    def read_and_set_preferred_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.DataSpecificationIEC61360.preferred_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringPreferredNameTypeIEC61360] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_preferred_name_type_iec_61360_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.preferred_name = result
-
-    def read_and_set_short_name(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.DataSpecificationIEC61360.short_name` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringShortNameTypeIEC61360] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_short_name_type_iec_61360_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.short_name = result
-
-    def read_and_set_unit(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.DataSpecificationIEC61360.unit` and set it.
-        """
-        self.unit = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_unit_id(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.DataSpecificationIEC61360.unit_id` and set it.
-        """
-        self.unit_id = _read_reference_as_sequence(element, iterator)
-
-    def read_and_set_source_of_definition(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.DataSpecificationIEC61360.source_of_definition` and set it.
-        """
-        self.source_of_definition = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_symbol(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.DataSpecificationIEC61360.symbol` and set it.
-        """
-        self.symbol = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_data_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.DataSpecificationIEC61360.data_type` and set it.
-        """
-        self.data_type = _read_data_type_iec_61360_from_element_text(element, iterator)
-
-    def read_and_set_definition(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.DataSpecificationIEC61360.definition` and set it.
-        """
-        if element.text is not None and len(element.text.strip()) != 0:
-            raise DeserializationException(
-                f"Expected only item elements and whitespace text, "
-                f"but got text: {element.text!r}"
-            )
-
-        result: List[aas_types.LangStringDefinitionTypeIEC61360] = []
-
-        item_i = 0
-
-        while True:
-            next_event_element = next(iterator, None)
-            if next_event_element is None:
-                raise DeserializationException(
-                    "Expected one or more items from a list or the end element, "
-                    "but got end-of-input"
-                )
-
-            next_event, next_element = next_event_element
-            if next_event == "end" and next_element.tag == element.tag:
-                # We reached the end of the list.
-                break
-
-            if next_event != "start":
-                raise DeserializationException(
-                    "Expected a start element corresponding to an item, "
-                    f"but got event {next_event!r} and element {next_element.tag!r}"
-                )
-
-            try:
-                item = _read_lang_string_definition_type_iec_61360_as_element(
-                    next_element, iterator
-                )
-            except DeserializationException as exception:
-                exception.path._prepend(IndexSegment(next_element, item_i))
-                raise
-
-            result.append(item)
-            item_i += 1
-
-        self.definition = result
-
-    def read_and_set_value_format(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.DataSpecificationIEC61360.value_format` and set it.
-        """
-        self.value_format = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_value_list(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.DataSpecificationIEC61360.value_list` and set it.
-        """
-        self.value_list = _read_value_list_as_sequence(element, iterator)
-
-    def read_and_set_value(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.DataSpecificationIEC61360.value` and set it.
-        """
-        self.value = _read_str_from_element_text(element, iterator)
-
-    def read_and_set_level_type(
-        self, element: Element, iterator: Iterator[Tuple[str, Element]]
-    ) -> None:
-        """
-        Read :paramref:`element` as the property
-        :py:attr:`.types.DataSpecificationIEC61360.level_type` and set it.
-        """
-        self.level_type = _read_level_type_as_sequence(element, iterator)
-
-
-def _read_data_specification_iec_61360_as_sequence(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.DataSpecificationIEC61360:
-    """
-    Read an instance of :py:class:`.types.DataSpecificationIEC61360`
-    as a sequence of XML-encoded properties.
-
-    The end element corresponding to the :paramref:`element` will be
-    read as well.
-
-    :param element: start element, parent of the sequence
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    if element.text is not None and len(element.text.strip()) != 0:
-        raise DeserializationException(
-            f"Expected only XML elements representing the properties and whitespace text, "
-            f"but got text: {element.text!r}"
-        )
-
-    _raise_if_has_tail_or_attrib(element)
-
-    reader_and_setter = _ReaderAndSetterForDataSpecificationIEC61360()
-
-    while True:
-        next_event_element = next(iterator, None)
-        if next_event_element is None:
-            raise DeserializationException(
-                "Expected one or more XML-encoded properties or the end element, "
-                "but got the end-of-input"
-            )
-
-        next_event, next_element = next_event_element
-        if next_event == "end" and next_element.tag == element.tag:
-            # We reached the end element enclosing the sequence.
-            break
-
-        if next_event != "start":
-            raise DeserializationException(
-                "Expected a start element corresponding to a property, "
-                f"but got event {next_event!r} and element {next_element.tag!r}"
-            )
-
-        try:
-            tag_wo_ns = _parse_element_tag(next_element)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-        read_and_set_method = (
-            _READ_AND_SET_DISPATCH_FOR_DATA_SPECIFICATION_IEC_61360.get(tag_wo_ns, None)
-        )
-        if read_and_set_method is None:
-            an_exception = DeserializationException(
-                f"Expected an element representing a property, "
-                f"but got an element with unexpected tag: {tag_wo_ns!r}"
-            )
-            an_exception.path._prepend(ElementSegment(next_element))
-            raise an_exception
-
-        try:
-            read_and_set_method(reader_and_setter, next_element, iterator)
-        except DeserializationException as exception:
-            exception.path._prepend(ElementSegment(next_element))
-            raise
-
-    if reader_and_setter.preferred_name is None:
-        raise DeserializationException(
-            "The required property 'preferredName' is missing"
-        )
-
-    return aas_types.DataSpecificationIEC61360(
-        reader_and_setter.preferred_name,
-        reader_and_setter.short_name,
-        reader_and_setter.unit,
-        reader_and_setter.unit_id,
-        reader_and_setter.source_of_definition,
-        reader_and_setter.symbol,
-        reader_and_setter.data_type,
-        reader_and_setter.definition,
-        reader_and_setter.value_format,
-        reader_and_setter.value_list,
-        reader_and_setter.value,
-        reader_and_setter.level_type,
-    )
-
-
-def _read_data_specification_iec_61360_as_element(
-    element: Element, iterator: Iterator[Tuple[str, Element]]
-) -> aas_types.DataSpecificationIEC61360:
-    """
-    Read an instance of :py:class:`.types.DataSpecificationIEC61360` from
-    :paramref:`iterator`, including the end element.
-
-    :param element: start element
-    :param iterator:
-        Input stream of ``(event, element)`` coming from
-        :py:func:`xml.etree.ElementTree.iterparse` with the argument
-        ``events=["start", "end"]``
-    :raise: :py:class:`DeserializationException` if unexpected input
-    :return: parsed instance
-    """
-    tag_wo_ns = _parse_element_tag(element)
-
-    if tag_wo_ns != "dataSpecificationIec61360":
-        raise DeserializationException(
-            f"Expected the element with the tag 'dataSpecificationIec61360', "
-            f"but got tag: {tag_wo_ns}"
-        )
-
-    return _read_data_specification_iec_61360_as_sequence(element, iterator)
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to concrete descendants of HasSemantics
-_DISPATCH_FOR_HAS_SEMANTICS: Mapping[
-    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.HasSemantics]
-] = {
-    "relationshipElement": _read_relationship_element_as_sequence,
-    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
-    "basicEventElement": _read_basic_event_element_as_sequence,
-    "blob": _read_blob_as_sequence,
-    "capability": _read_capability_as_sequence,
-    "entity": _read_entity_as_sequence,
-    "extension": _read_extension_as_sequence,
-    "file": _read_file_as_sequence,
-    "multiLanguageProperty": _read_multi_language_property_as_sequence,
-    "operation": _read_operation_as_sequence,
-    "property": _read_property_as_sequence,
-    "qualifier": _read_qualifier_as_sequence,
-    "range": _read_range_as_sequence,
-    "referenceElement": _read_reference_element_as_sequence,
-    "specificAssetId": _read_specific_asset_id_as_sequence,
-    "submodel": _read_submodel_as_sequence,
-    "submodelElementCollection": _read_submodel_element_collection_as_sequence,
-    "submodelElementList": _read_submodel_element_list_as_sequence,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForExtension`
-_READ_AND_SET_DISPATCH_FOR_EXTENSION: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForExtension, Element, Iterator[Tuple[str, Element]]], None
-    ],
-] = {
-    "semanticId": _ReaderAndSetterForExtension.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForExtension.read_and_set_supplemental_semantic_ids,
-    "name": _ReaderAndSetterForExtension.read_and_set_name,
-    "valueType": _ReaderAndSetterForExtension.read_and_set_value_type,
-    "value": _ReaderAndSetterForExtension.read_and_set_value,
-    "refersTo": _ReaderAndSetterForExtension.read_and_set_refers_to,
-}
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to concrete descendants of HasExtensions
-_DISPATCH_FOR_HAS_EXTENSIONS: Mapping[
-    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.HasExtensions]
-] = {
-    "relationshipElement": _read_relationship_element_as_sequence,
-    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
-    "assetAdministrationShell": _read_asset_administration_shell_as_sequence,
-    "basicEventElement": _read_basic_event_element_as_sequence,
-    "blob": _read_blob_as_sequence,
-    "capability": _read_capability_as_sequence,
-    "conceptDescription": _read_concept_description_as_sequence,
-    "entity": _read_entity_as_sequence,
-    "file": _read_file_as_sequence,
-    "multiLanguageProperty": _read_multi_language_property_as_sequence,
-    "operation": _read_operation_as_sequence,
-    "property": _read_property_as_sequence,
-    "range": _read_range_as_sequence,
-    "referenceElement": _read_reference_element_as_sequence,
-    "submodel": _read_submodel_as_sequence,
-    "submodelElementCollection": _read_submodel_element_collection_as_sequence,
-    "submodelElementList": _read_submodel_element_list_as_sequence,
-}
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to concrete descendants of Referable
-_DISPATCH_FOR_REFERABLE: Mapping[
-    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.Referable]
-] = {
-    "relationshipElement": _read_relationship_element_as_sequence,
-    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
-    "assetAdministrationShell": _read_asset_administration_shell_as_sequence,
-    "basicEventElement": _read_basic_event_element_as_sequence,
-    "blob": _read_blob_as_sequence,
-    "capability": _read_capability_as_sequence,
-    "conceptDescription": _read_concept_description_as_sequence,
-    "entity": _read_entity_as_sequence,
-    "file": _read_file_as_sequence,
-    "multiLanguageProperty": _read_multi_language_property_as_sequence,
-    "operation": _read_operation_as_sequence,
-    "property": _read_property_as_sequence,
-    "range": _read_range_as_sequence,
-    "referenceElement": _read_reference_element_as_sequence,
-    "submodel": _read_submodel_as_sequence,
-    "submodelElementCollection": _read_submodel_element_collection_as_sequence,
-    "submodelElementList": _read_submodel_element_list_as_sequence,
-}
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to concrete descendants of Identifiable
-_DISPATCH_FOR_IDENTIFIABLE: Mapping[
-    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.Identifiable]
-] = {
-    "assetAdministrationShell": _read_asset_administration_shell_as_sequence,
-    "conceptDescription": _read_concept_description_as_sequence,
-    "submodel": _read_submodel_as_sequence,
-}
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to concrete descendants of HasKind
-_DISPATCH_FOR_HAS_KIND: Mapping[
-    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.HasKind]
-] = {
-    "submodel": _read_submodel_as_sequence,
-}
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to concrete descendants of HasDataSpecification
-_DISPATCH_FOR_HAS_DATA_SPECIFICATION: Mapping[
-    str,
-    Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.HasDataSpecification],
-] = {
-    "administrativeInformation": _read_administrative_information_as_sequence,
-    "relationshipElement": _read_relationship_element_as_sequence,
-    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
-    "assetAdministrationShell": _read_asset_administration_shell_as_sequence,
-    "basicEventElement": _read_basic_event_element_as_sequence,
-    "blob": _read_blob_as_sequence,
-    "capability": _read_capability_as_sequence,
-    "conceptDescription": _read_concept_description_as_sequence,
-    "entity": _read_entity_as_sequence,
-    "file": _read_file_as_sequence,
-    "multiLanguageProperty": _read_multi_language_property_as_sequence,
-    "operation": _read_operation_as_sequence,
-    "property": _read_property_as_sequence,
-    "range": _read_range_as_sequence,
-    "referenceElement": _read_reference_element_as_sequence,
-    "submodel": _read_submodel_as_sequence,
-    "submodelElementCollection": _read_submodel_element_collection_as_sequence,
-    "submodelElementList": _read_submodel_element_list_as_sequence,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForAdministrativeInformation`
-_READ_AND_SET_DISPATCH_FOR_ADMINISTRATIVE_INFORMATION: Mapping[
-    str,
-    Callable[
-        [
-            _ReaderAndSetterForAdministrativeInformation,
-            Element,
-            Iterator[Tuple[str, Element]],
-        ],
-        None,
-    ],
-] = {
-    "embeddedDataSpecifications": _ReaderAndSetterForAdministrativeInformation.read_and_set_embedded_data_specifications,
-    "version": _ReaderAndSetterForAdministrativeInformation.read_and_set_version,
-    "revision": _ReaderAndSetterForAdministrativeInformation.read_and_set_revision,
-    "creator": _ReaderAndSetterForAdministrativeInformation.read_and_set_creator,
-    "templateId": _ReaderAndSetterForAdministrativeInformation.read_and_set_template_id,
-}
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to concrete descendants of Qualifiable
-_DISPATCH_FOR_QUALIFIABLE: Mapping[
-    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.Qualifiable]
-] = {
-    "relationshipElement": _read_relationship_element_as_sequence,
-    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
-    "basicEventElement": _read_basic_event_element_as_sequence,
-    "blob": _read_blob_as_sequence,
-    "capability": _read_capability_as_sequence,
-    "entity": _read_entity_as_sequence,
-    "file": _read_file_as_sequence,
-    "multiLanguageProperty": _read_multi_language_property_as_sequence,
-    "operation": _read_operation_as_sequence,
-    "property": _read_property_as_sequence,
-    "range": _read_range_as_sequence,
-    "referenceElement": _read_reference_element_as_sequence,
-    "submodel": _read_submodel_as_sequence,
-    "submodelElementCollection": _read_submodel_element_collection_as_sequence,
-    "submodelElementList": _read_submodel_element_list_as_sequence,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForQualifier`
-_READ_AND_SET_DISPATCH_FOR_QUALIFIER: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForQualifier, Element, Iterator[Tuple[str, Element]]], None
-    ],
-] = {
-    "semanticId": _ReaderAndSetterForQualifier.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForQualifier.read_and_set_supplemental_semantic_ids,
-    "kind": _ReaderAndSetterForQualifier.read_and_set_kind,
-    "type": _ReaderAndSetterForQualifier.read_and_set_type,
-    "valueType": _ReaderAndSetterForQualifier.read_and_set_value_type,
-    "value": _ReaderAndSetterForQualifier.read_and_set_value,
-    "valueId": _ReaderAndSetterForQualifier.read_and_set_value_id,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForAssetAdministrationShell`
-_READ_AND_SET_DISPATCH_FOR_ASSET_ADMINISTRATION_SHELL: Mapping[
-    str,
-    Callable[
-        [
-            _ReaderAndSetterForAssetAdministrationShell,
-            Element,
-            Iterator[Tuple[str, Element]],
-        ],
-        None,
-    ],
-] = {
-    "extensions": _ReaderAndSetterForAssetAdministrationShell.read_and_set_extensions,
-    "category": _ReaderAndSetterForAssetAdministrationShell.read_and_set_category,
-    "idShort": _ReaderAndSetterForAssetAdministrationShell.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForAssetAdministrationShell.read_and_set_display_name,
-    "description": _ReaderAndSetterForAssetAdministrationShell.read_and_set_description,
-    "administration": _ReaderAndSetterForAssetAdministrationShell.read_and_set_administration,
-    "id": _ReaderAndSetterForAssetAdministrationShell.read_and_set_id,
-    "embeddedDataSpecifications": _ReaderAndSetterForAssetAdministrationShell.read_and_set_embedded_data_specifications,
-    "derivedFrom": _ReaderAndSetterForAssetAdministrationShell.read_and_set_derived_from,
-    "assetInformation": _ReaderAndSetterForAssetAdministrationShell.read_and_set_asset_information,
-    "submodels": _ReaderAndSetterForAssetAdministrationShell.read_and_set_submodels,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForAssetInformation`
-_READ_AND_SET_DISPATCH_FOR_ASSET_INFORMATION: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForAssetInformation, Element, Iterator[Tuple[str, Element]]],
-        None,
-    ],
-] = {
-    "assetKind": _ReaderAndSetterForAssetInformation.read_and_set_asset_kind,
-    "globalAssetId": _ReaderAndSetterForAssetInformation.read_and_set_global_asset_id,
-    "specificAssetIds": _ReaderAndSetterForAssetInformation.read_and_set_specific_asset_ids,
-    "assetType": _ReaderAndSetterForAssetInformation.read_and_set_asset_type,
-    "defaultThumbnail": _ReaderAndSetterForAssetInformation.read_and_set_default_thumbnail,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForResource`
-_READ_AND_SET_DISPATCH_FOR_RESOURCE: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForResource, Element, Iterator[Tuple[str, Element]]], None
-    ],
-] = {
-    "path": _ReaderAndSetterForResource.read_and_set_path,
-    "contentType": _ReaderAndSetterForResource.read_and_set_content_type,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForSpecificAssetID`
-_READ_AND_SET_DISPATCH_FOR_SPECIFIC_ASSET_ID: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForSpecificAssetID, Element, Iterator[Tuple[str, Element]]],
-        None,
-    ],
-] = {
-    "semanticId": _ReaderAndSetterForSpecificAssetID.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForSpecificAssetID.read_and_set_supplemental_semantic_ids,
-    "name": _ReaderAndSetterForSpecificAssetID.read_and_set_name,
-    "value": _ReaderAndSetterForSpecificAssetID.read_and_set_value,
-    "externalSubjectId": _ReaderAndSetterForSpecificAssetID.read_and_set_external_subject_id,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForSubmodel`
-_READ_AND_SET_DISPATCH_FOR_SUBMODEL: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForSubmodel, Element, Iterator[Tuple[str, Element]]], None
-    ],
-] = {
-    "extensions": _ReaderAndSetterForSubmodel.read_and_set_extensions,
-    "category": _ReaderAndSetterForSubmodel.read_and_set_category,
-    "idShort": _ReaderAndSetterForSubmodel.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForSubmodel.read_and_set_display_name,
-    "description": _ReaderAndSetterForSubmodel.read_and_set_description,
-    "administration": _ReaderAndSetterForSubmodel.read_and_set_administration,
-    "id": _ReaderAndSetterForSubmodel.read_and_set_id,
-    "kind": _ReaderAndSetterForSubmodel.read_and_set_kind,
-    "semanticId": _ReaderAndSetterForSubmodel.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForSubmodel.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForSubmodel.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForSubmodel.read_and_set_embedded_data_specifications,
-    "submodelElements": _ReaderAndSetterForSubmodel.read_and_set_submodel_elements,
-}
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to concrete descendants of SubmodelElement
-_DISPATCH_FOR_SUBMODEL_ELEMENT: Mapping[
-    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.SubmodelElement]
-] = {
-    "relationshipElement": _read_relationship_element_as_sequence,
-    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
-    "basicEventElement": _read_basic_event_element_as_sequence,
-    "blob": _read_blob_as_sequence,
-    "capability": _read_capability_as_sequence,
-    "entity": _read_entity_as_sequence,
-    "file": _read_file_as_sequence,
-    "multiLanguageProperty": _read_multi_language_property_as_sequence,
-    "operation": _read_operation_as_sequence,
-    "property": _read_property_as_sequence,
-    "range": _read_range_as_sequence,
-    "referenceElement": _read_reference_element_as_sequence,
-    "submodelElementCollection": _read_submodel_element_collection_as_sequence,
-    "submodelElementList": _read_submodel_element_list_as_sequence,
-}
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to RelationshipElement and its concrete descendants
-_DISPATCH_FOR_RELATIONSHIP_ELEMENT: Mapping[
-    str,
-    Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.RelationshipElement],
-] = {
-    "relationshipElement": _read_relationship_element_as_sequence,
-    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForRelationshipElement`
-_READ_AND_SET_DISPATCH_FOR_RELATIONSHIP_ELEMENT: Mapping[
-    str,
-    Callable[
-        [
-            _ReaderAndSetterForRelationshipElement,
-            Element,
-            Iterator[Tuple[str, Element]],
-        ],
-        None,
-    ],
-] = {
-    "extensions": _ReaderAndSetterForRelationshipElement.read_and_set_extensions,
-    "category": _ReaderAndSetterForRelationshipElement.read_and_set_category,
-    "idShort": _ReaderAndSetterForRelationshipElement.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForRelationshipElement.read_and_set_display_name,
-    "description": _ReaderAndSetterForRelationshipElement.read_and_set_description,
-    "semanticId": _ReaderAndSetterForRelationshipElement.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForRelationshipElement.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForRelationshipElement.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForRelationshipElement.read_and_set_embedded_data_specifications,
-    "first": _ReaderAndSetterForRelationshipElement.read_and_set_first,
-    "second": _ReaderAndSetterForRelationshipElement.read_and_set_second,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForSubmodelElementList`
-_READ_AND_SET_DISPATCH_FOR_SUBMODEL_ELEMENT_LIST: Mapping[
-    str,
-    Callable[
-        [
-            _ReaderAndSetterForSubmodelElementList,
-            Element,
-            Iterator[Tuple[str, Element]],
-        ],
-        None,
-    ],
-] = {
-    "extensions": _ReaderAndSetterForSubmodelElementList.read_and_set_extensions,
-    "category": _ReaderAndSetterForSubmodelElementList.read_and_set_category,
-    "idShort": _ReaderAndSetterForSubmodelElementList.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForSubmodelElementList.read_and_set_display_name,
-    "description": _ReaderAndSetterForSubmodelElementList.read_and_set_description,
-    "semanticId": _ReaderAndSetterForSubmodelElementList.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForSubmodelElementList.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForSubmodelElementList.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForSubmodelElementList.read_and_set_embedded_data_specifications,
-    "orderRelevant": _ReaderAndSetterForSubmodelElementList.read_and_set_order_relevant,
-    "semanticIdListElement": _ReaderAndSetterForSubmodelElementList.read_and_set_semantic_id_list_element,
-    "typeValueListElement": _ReaderAndSetterForSubmodelElementList.read_and_set_type_value_list_element,
-    "valueTypeListElement": _ReaderAndSetterForSubmodelElementList.read_and_set_value_type_list_element,
-    "value": _ReaderAndSetterForSubmodelElementList.read_and_set_value,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForSubmodelElementCollection`
-_READ_AND_SET_DISPATCH_FOR_SUBMODEL_ELEMENT_COLLECTION: Mapping[
-    str,
-    Callable[
-        [
-            _ReaderAndSetterForSubmodelElementCollection,
-            Element,
-            Iterator[Tuple[str, Element]],
-        ],
-        None,
-    ],
-] = {
-    "extensions": _ReaderAndSetterForSubmodelElementCollection.read_and_set_extensions,
-    "category": _ReaderAndSetterForSubmodelElementCollection.read_and_set_category,
-    "idShort": _ReaderAndSetterForSubmodelElementCollection.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForSubmodelElementCollection.read_and_set_display_name,
-    "description": _ReaderAndSetterForSubmodelElementCollection.read_and_set_description,
-    "semanticId": _ReaderAndSetterForSubmodelElementCollection.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForSubmodelElementCollection.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForSubmodelElementCollection.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForSubmodelElementCollection.read_and_set_embedded_data_specifications,
-    "value": _ReaderAndSetterForSubmodelElementCollection.read_and_set_value,
-}
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to concrete descendants of DataElement
-_DISPATCH_FOR_DATA_ELEMENT: Mapping[
-    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.DataElement]
-] = {
-    "blob": _read_blob_as_sequence,
-    "file": _read_file_as_sequence,
-    "multiLanguageProperty": _read_multi_language_property_as_sequence,
-    "property": _read_property_as_sequence,
-    "range": _read_range_as_sequence,
-    "referenceElement": _read_reference_element_as_sequence,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForProperty`
-_READ_AND_SET_DISPATCH_FOR_PROPERTY: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForProperty, Element, Iterator[Tuple[str, Element]]], None
-    ],
-] = {
-    "extensions": _ReaderAndSetterForProperty.read_and_set_extensions,
-    "category": _ReaderAndSetterForProperty.read_and_set_category,
-    "idShort": _ReaderAndSetterForProperty.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForProperty.read_and_set_display_name,
-    "description": _ReaderAndSetterForProperty.read_and_set_description,
-    "semanticId": _ReaderAndSetterForProperty.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForProperty.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForProperty.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForProperty.read_and_set_embedded_data_specifications,
-    "valueType": _ReaderAndSetterForProperty.read_and_set_value_type,
-    "value": _ReaderAndSetterForProperty.read_and_set_value,
-    "valueId": _ReaderAndSetterForProperty.read_and_set_value_id,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForMultiLanguageProperty`
-_READ_AND_SET_DISPATCH_FOR_MULTI_LANGUAGE_PROPERTY: Mapping[
-    str,
-    Callable[
-        [
-            _ReaderAndSetterForMultiLanguageProperty,
-            Element,
-            Iterator[Tuple[str, Element]],
-        ],
-        None,
-    ],
-] = {
-    "extensions": _ReaderAndSetterForMultiLanguageProperty.read_and_set_extensions,
-    "category": _ReaderAndSetterForMultiLanguageProperty.read_and_set_category,
-    "idShort": _ReaderAndSetterForMultiLanguageProperty.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForMultiLanguageProperty.read_and_set_display_name,
-    "description": _ReaderAndSetterForMultiLanguageProperty.read_and_set_description,
-    "semanticId": _ReaderAndSetterForMultiLanguageProperty.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForMultiLanguageProperty.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForMultiLanguageProperty.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForMultiLanguageProperty.read_and_set_embedded_data_specifications,
-    "value": _ReaderAndSetterForMultiLanguageProperty.read_and_set_value,
-    "valueId": _ReaderAndSetterForMultiLanguageProperty.read_and_set_value_id,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForRange`
-_READ_AND_SET_DISPATCH_FOR_RANGE: Mapping[
-    str,
-    Callable[[_ReaderAndSetterForRange, Element, Iterator[Tuple[str, Element]]], None],
-] = {
-    "extensions": _ReaderAndSetterForRange.read_and_set_extensions,
-    "category": _ReaderAndSetterForRange.read_and_set_category,
-    "idShort": _ReaderAndSetterForRange.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForRange.read_and_set_display_name,
-    "description": _ReaderAndSetterForRange.read_and_set_description,
-    "semanticId": _ReaderAndSetterForRange.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForRange.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForRange.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForRange.read_and_set_embedded_data_specifications,
-    "valueType": _ReaderAndSetterForRange.read_and_set_value_type,
-    "min": _ReaderAndSetterForRange.read_and_set_min,
-    "max": _ReaderAndSetterForRange.read_and_set_max,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForReferenceElement`
-_READ_AND_SET_DISPATCH_FOR_REFERENCE_ELEMENT: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForReferenceElement, Element, Iterator[Tuple[str, Element]]],
-        None,
-    ],
-] = {
-    "extensions": _ReaderAndSetterForReferenceElement.read_and_set_extensions,
-    "category": _ReaderAndSetterForReferenceElement.read_and_set_category,
-    "idShort": _ReaderAndSetterForReferenceElement.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForReferenceElement.read_and_set_display_name,
-    "description": _ReaderAndSetterForReferenceElement.read_and_set_description,
-    "semanticId": _ReaderAndSetterForReferenceElement.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForReferenceElement.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForReferenceElement.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForReferenceElement.read_and_set_embedded_data_specifications,
-    "value": _ReaderAndSetterForReferenceElement.read_and_set_value,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForBlob`
-_READ_AND_SET_DISPATCH_FOR_BLOB: Mapping[
-    str,
-    Callable[[_ReaderAndSetterForBlob, Element, Iterator[Tuple[str, Element]]], None],
-] = {
-    "extensions": _ReaderAndSetterForBlob.read_and_set_extensions,
-    "category": _ReaderAndSetterForBlob.read_and_set_category,
-    "idShort": _ReaderAndSetterForBlob.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForBlob.read_and_set_display_name,
-    "description": _ReaderAndSetterForBlob.read_and_set_description,
-    "semanticId": _ReaderAndSetterForBlob.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForBlob.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForBlob.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForBlob.read_and_set_embedded_data_specifications,
-    "value": _ReaderAndSetterForBlob.read_and_set_value,
-    "contentType": _ReaderAndSetterForBlob.read_and_set_content_type,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForFile`
-_READ_AND_SET_DISPATCH_FOR_FILE: Mapping[
-    str,
-    Callable[[_ReaderAndSetterForFile, Element, Iterator[Tuple[str, Element]]], None],
-] = {
-    "extensions": _ReaderAndSetterForFile.read_and_set_extensions,
-    "category": _ReaderAndSetterForFile.read_and_set_category,
-    "idShort": _ReaderAndSetterForFile.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForFile.read_and_set_display_name,
-    "description": _ReaderAndSetterForFile.read_and_set_description,
-    "semanticId": _ReaderAndSetterForFile.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForFile.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForFile.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForFile.read_and_set_embedded_data_specifications,
-    "value": _ReaderAndSetterForFile.read_and_set_value,
-    "contentType": _ReaderAndSetterForFile.read_and_set_content_type,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForAnnotatedRelationshipElement`
-_READ_AND_SET_DISPATCH_FOR_ANNOTATED_RELATIONSHIP_ELEMENT: Mapping[
-    str,
-    Callable[
-        [
-            _ReaderAndSetterForAnnotatedRelationshipElement,
-            Element,
-            Iterator[Tuple[str, Element]],
-        ],
-        None,
-    ],
-] = {
-    "extensions": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_extensions,
-    "category": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_category,
-    "idShort": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_display_name,
-    "description": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_description,
-    "semanticId": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_embedded_data_specifications,
-    "first": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_first,
-    "second": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_second,
-    "annotations": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_annotations,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForEntity`
-_READ_AND_SET_DISPATCH_FOR_ENTITY: Mapping[
-    str,
-    Callable[[_ReaderAndSetterForEntity, Element, Iterator[Tuple[str, Element]]], None],
-] = {
-    "extensions": _ReaderAndSetterForEntity.read_and_set_extensions,
-    "category": _ReaderAndSetterForEntity.read_and_set_category,
-    "idShort": _ReaderAndSetterForEntity.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForEntity.read_and_set_display_name,
-    "description": _ReaderAndSetterForEntity.read_and_set_description,
-    "semanticId": _ReaderAndSetterForEntity.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForEntity.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForEntity.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForEntity.read_and_set_embedded_data_specifications,
-    "statements": _ReaderAndSetterForEntity.read_and_set_statements,
-    "entityType": _ReaderAndSetterForEntity.read_and_set_entity_type,
-    "globalAssetId": _ReaderAndSetterForEntity.read_and_set_global_asset_id,
-    "specificAssetIds": _ReaderAndSetterForEntity.read_and_set_specific_asset_ids,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForEventPayload`
-_READ_AND_SET_DISPATCH_FOR_EVENT_PAYLOAD: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForEventPayload, Element, Iterator[Tuple[str, Element]]], None
-    ],
-] = {
-    "source": _ReaderAndSetterForEventPayload.read_and_set_source,
-    "sourceSemanticId": _ReaderAndSetterForEventPayload.read_and_set_source_semantic_id,
-    "observableReference": _ReaderAndSetterForEventPayload.read_and_set_observable_reference,
-    "observableSemanticId": _ReaderAndSetterForEventPayload.read_and_set_observable_semantic_id,
-    "topic": _ReaderAndSetterForEventPayload.read_and_set_topic,
-    "subjectId": _ReaderAndSetterForEventPayload.read_and_set_subject_id,
-    "timeStamp": _ReaderAndSetterForEventPayload.read_and_set_time_stamp,
-    "payload": _ReaderAndSetterForEventPayload.read_and_set_payload,
-}
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to concrete descendants of EventElement
-_DISPATCH_FOR_EVENT_ELEMENT: Mapping[
-    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.EventElement]
-] = {
-    "basicEventElement": _read_basic_event_element_as_sequence,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForBasicEventElement`
-_READ_AND_SET_DISPATCH_FOR_BASIC_EVENT_ELEMENT: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForBasicEventElement, Element, Iterator[Tuple[str, Element]]],
-        None,
-    ],
-] = {
-    "extensions": _ReaderAndSetterForBasicEventElement.read_and_set_extensions,
-    "category": _ReaderAndSetterForBasicEventElement.read_and_set_category,
-    "idShort": _ReaderAndSetterForBasicEventElement.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForBasicEventElement.read_and_set_display_name,
-    "description": _ReaderAndSetterForBasicEventElement.read_and_set_description,
-    "semanticId": _ReaderAndSetterForBasicEventElement.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForBasicEventElement.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForBasicEventElement.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForBasicEventElement.read_and_set_embedded_data_specifications,
-    "observed": _ReaderAndSetterForBasicEventElement.read_and_set_observed,
-    "direction": _ReaderAndSetterForBasicEventElement.read_and_set_direction,
-    "state": _ReaderAndSetterForBasicEventElement.read_and_set_state,
-    "messageTopic": _ReaderAndSetterForBasicEventElement.read_and_set_message_topic,
-    "messageBroker": _ReaderAndSetterForBasicEventElement.read_and_set_message_broker,
-    "lastUpdate": _ReaderAndSetterForBasicEventElement.read_and_set_last_update,
-    "minInterval": _ReaderAndSetterForBasicEventElement.read_and_set_min_interval,
-    "maxInterval": _ReaderAndSetterForBasicEventElement.read_and_set_max_interval,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForOperation`
-_READ_AND_SET_DISPATCH_FOR_OPERATION: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForOperation, Element, Iterator[Tuple[str, Element]]], None
-    ],
-] = {
-    "extensions": _ReaderAndSetterForOperation.read_and_set_extensions,
-    "category": _ReaderAndSetterForOperation.read_and_set_category,
-    "idShort": _ReaderAndSetterForOperation.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForOperation.read_and_set_display_name,
-    "description": _ReaderAndSetterForOperation.read_and_set_description,
-    "semanticId": _ReaderAndSetterForOperation.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForOperation.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForOperation.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForOperation.read_and_set_embedded_data_specifications,
-    "inputVariables": _ReaderAndSetterForOperation.read_and_set_input_variables,
-    "outputVariables": _ReaderAndSetterForOperation.read_and_set_output_variables,
-    "inoutputVariables": _ReaderAndSetterForOperation.read_and_set_inoutput_variables,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForOperationVariable`
-_READ_AND_SET_DISPATCH_FOR_OPERATION_VARIABLE: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForOperationVariable, Element, Iterator[Tuple[str, Element]]],
-        None,
-    ],
-] = {
-    "value": _ReaderAndSetterForOperationVariable.read_and_set_value,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForCapability`
-_READ_AND_SET_DISPATCH_FOR_CAPABILITY: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForCapability, Element, Iterator[Tuple[str, Element]]], None
-    ],
-] = {
-    "extensions": _ReaderAndSetterForCapability.read_and_set_extensions,
-    "category": _ReaderAndSetterForCapability.read_and_set_category,
-    "idShort": _ReaderAndSetterForCapability.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForCapability.read_and_set_display_name,
-    "description": _ReaderAndSetterForCapability.read_and_set_description,
-    "semanticId": _ReaderAndSetterForCapability.read_and_set_semantic_id,
-    "supplementalSemanticIds": _ReaderAndSetterForCapability.read_and_set_supplemental_semantic_ids,
-    "qualifiers": _ReaderAndSetterForCapability.read_and_set_qualifiers,
-    "embeddedDataSpecifications": _ReaderAndSetterForCapability.read_and_set_embedded_data_specifications,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForConceptDescription`
-_READ_AND_SET_DISPATCH_FOR_CONCEPT_DESCRIPTION: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForConceptDescription, Element, Iterator[Tuple[str, Element]]],
-        None,
-    ],
-] = {
-    "extensions": _ReaderAndSetterForConceptDescription.read_and_set_extensions,
-    "category": _ReaderAndSetterForConceptDescription.read_and_set_category,
-    "idShort": _ReaderAndSetterForConceptDescription.read_and_set_id_short,
-    "displayName": _ReaderAndSetterForConceptDescription.read_and_set_display_name,
-    "description": _ReaderAndSetterForConceptDescription.read_and_set_description,
-    "administration": _ReaderAndSetterForConceptDescription.read_and_set_administration,
-    "id": _ReaderAndSetterForConceptDescription.read_and_set_id,
-    "embeddedDataSpecifications": _ReaderAndSetterForConceptDescription.read_and_set_embedded_data_specifications,
-    "isCaseOf": _ReaderAndSetterForConceptDescription.read_and_set_is_case_of,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForReference`
-_READ_AND_SET_DISPATCH_FOR_REFERENCE: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForReference, Element, Iterator[Tuple[str, Element]]], None
-    ],
-] = {
-    "type": _ReaderAndSetterForReference.read_and_set_type,
-    "referredSemanticId": _ReaderAndSetterForReference.read_and_set_referred_semantic_id,
-    "keys": _ReaderAndSetterForReference.read_and_set_keys,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForKey`
-_READ_AND_SET_DISPATCH_FOR_KEY: Mapping[
-    str,
-    Callable[[_ReaderAndSetterForKey, Element, Iterator[Tuple[str, Element]]], None],
-] = {
-    "type": _ReaderAndSetterForKey.read_and_set_type,
-    "value": _ReaderAndSetterForKey.read_and_set_value,
-}
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to concrete descendants of AbstractLangString
-_DISPATCH_FOR_ABSTRACT_LANG_STRING: Mapping[
-    str,
-    Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.AbstractLangString],
-] = {
-    "langStringDefinitionTypeIec61360": _read_lang_string_definition_type_iec_61360_as_sequence,
-    "langStringNameType": _read_lang_string_name_type_as_sequence,
-    "langStringPreferredNameTypeIec61360": _read_lang_string_preferred_name_type_iec_61360_as_sequence,
-    "langStringShortNameTypeIec61360": _read_lang_string_short_name_type_iec_61360_as_sequence,
-    "langStringTextType": _read_lang_string_text_type_as_sequence,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForLangStringNameType`
-_READ_AND_SET_DISPATCH_FOR_LANG_STRING_NAME_TYPE: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForLangStringNameType, Element, Iterator[Tuple[str, Element]]],
-        None,
-    ],
-] = {
-    "language": _ReaderAndSetterForLangStringNameType.read_and_set_language,
-    "text": _ReaderAndSetterForLangStringNameType.read_and_set_text,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForLangStringTextType`
-_READ_AND_SET_DISPATCH_FOR_LANG_STRING_TEXT_TYPE: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForLangStringTextType, Element, Iterator[Tuple[str, Element]]],
-        None,
-    ],
-] = {
-    "language": _ReaderAndSetterForLangStringTextType.read_and_set_language,
-    "text": _ReaderAndSetterForLangStringTextType.read_and_set_text,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForEnvironment`
-_READ_AND_SET_DISPATCH_FOR_ENVIRONMENT: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForEnvironment, Element, Iterator[Tuple[str, Element]]], None
-    ],
-] = {
-    "assetAdministrationShells": _ReaderAndSetterForEnvironment.read_and_set_asset_administration_shells,
-    "submodels": _ReaderAndSetterForEnvironment.read_and_set_submodels,
-    "conceptDescriptions": _ReaderAndSetterForEnvironment.read_and_set_concept_descriptions,
-}
-
-
-#: Dispatch XML class names to read-as-sequence functions
-#: corresponding to concrete descendants of DataSpecificationContent
-_DISPATCH_FOR_DATA_SPECIFICATION_CONTENT: Mapping[
-    str,
-    Callable[
-        [Element, Iterator[Tuple[str, Element]]], aas_types.DataSpecificationContent
-    ],
-] = {
-    "dataSpecificationIec61360": _read_data_specification_iec_61360_as_sequence,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForEmbeddedDataSpecification`
-_READ_AND_SET_DISPATCH_FOR_EMBEDDED_DATA_SPECIFICATION: Mapping[
-    str,
-    Callable[
-        [
-            _ReaderAndSetterForEmbeddedDataSpecification,
-            Element,
-            Iterator[Tuple[str, Element]],
-        ],
-        None,
-    ],
-] = {
-    "dataSpecification": _ReaderAndSetterForEmbeddedDataSpecification.read_and_set_data_specification,
-    "dataSpecificationContent": _ReaderAndSetterForEmbeddedDataSpecification.read_and_set_data_specification_content,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForLevelType`
-_READ_AND_SET_DISPATCH_FOR_LEVEL_TYPE: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForLevelType, Element, Iterator[Tuple[str, Element]]], None
-    ],
-] = {
-    "min": _ReaderAndSetterForLevelType.read_and_set_min,
-    "nom": _ReaderAndSetterForLevelType.read_and_set_nom,
-    "typ": _ReaderAndSetterForLevelType.read_and_set_typ,
-    "max": _ReaderAndSetterForLevelType.read_and_set_max,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForValueReferencePair`
-_READ_AND_SET_DISPATCH_FOR_VALUE_REFERENCE_PAIR: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForValueReferencePair, Element, Iterator[Tuple[str, Element]]],
-        None,
-    ],
-] = {
-    "value": _ReaderAndSetterForValueReferencePair.read_and_set_value,
-    "valueId": _ReaderAndSetterForValueReferencePair.read_and_set_value_id,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForValueList`
-_READ_AND_SET_DISPATCH_FOR_VALUE_LIST: Mapping[
-    str,
-    Callable[
-        [_ReaderAndSetterForValueList, Element, Iterator[Tuple[str, Element]]], None
-    ],
-] = {
-    "valueReferencePairs": _ReaderAndSetterForValueList.read_and_set_value_reference_pairs,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForLangStringPreferredNameTypeIEC61360`
-_READ_AND_SET_DISPATCH_FOR_LANG_STRING_PREFERRED_NAME_TYPE_IEC_61360: Mapping[
-    str,
-    Callable[
-        [
-            _ReaderAndSetterForLangStringPreferredNameTypeIEC61360,
-            Element,
-            Iterator[Tuple[str, Element]],
-        ],
-        None,
-    ],
-] = {
-    "language": _ReaderAndSetterForLangStringPreferredNameTypeIEC61360.read_and_set_language,
-    "text": _ReaderAndSetterForLangStringPreferredNameTypeIEC61360.read_and_set_text,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForLangStringShortNameTypeIEC61360`
-_READ_AND_SET_DISPATCH_FOR_LANG_STRING_SHORT_NAME_TYPE_IEC_61360: Mapping[
-    str,
-    Callable[
-        [
-            _ReaderAndSetterForLangStringShortNameTypeIEC61360,
-            Element,
-            Iterator[Tuple[str, Element]],
-        ],
-        None,
-    ],
-] = {
-    "language": _ReaderAndSetterForLangStringShortNameTypeIEC61360.read_and_set_language,
-    "text": _ReaderAndSetterForLangStringShortNameTypeIEC61360.read_and_set_text,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForLangStringDefinitionTypeIEC61360`
-_READ_AND_SET_DISPATCH_FOR_LANG_STRING_DEFINITION_TYPE_IEC_61360: Mapping[
-    str,
-    Callable[
-        [
-            _ReaderAndSetterForLangStringDefinitionTypeIEC61360,
-            Element,
-            Iterator[Tuple[str, Element]],
-        ],
-        None,
-    ],
-] = {
-    "language": _ReaderAndSetterForLangStringDefinitionTypeIEC61360.read_and_set_language,
-    "text": _ReaderAndSetterForLangStringDefinitionTypeIEC61360.read_and_set_text,
-}
-
-
-#: Dispatch XML property name to read & set method in
-#: :py:class:`_ReaderAndSetterForDataSpecificationIEC61360`
-_READ_AND_SET_DISPATCH_FOR_DATA_SPECIFICATION_IEC_61360: Mapping[
-    str,
-    Callable[
-        [
-            _ReaderAndSetterForDataSpecificationIEC61360,
-            Element,
-            Iterator[Tuple[str, Element]],
-        ],
-        None,
-    ],
-] = {
-    "preferredName": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_preferred_name,
-    "shortName": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_short_name,
-    "unit": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_unit,
-    "unitId": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_unit_id,
-    "sourceOfDefinition": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_source_of_definition,
-    "symbol": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_symbol,
-    "dataType": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_data_type,
-    "definition": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_definition,
-    "valueFormat": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_value_format,
-    "valueList": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_value_list,
-    "value": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_value,
-    "levelType": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_level_type,
-}
-
-
-# endregion
-
-
-# region Serialization
-
-
-class _Serializer(aas_types.AbstractVisitor):
-    """Encode instances as XML and write them to :py:attr:`~stream`."""
-
-    #: Stream to be written to when we visit the instances
-    stream: Final[TextIO]
-
-    #: Method pointer to be invoked for writing the start element with or without
-    #: specifying a namespace (depending on the state of the serializer)
-    _write_start_element: Callable[[str], None]
-
-    #: Method pointer to be invoked for writing an empty element with or without
-    #: specifying a namespace (depending on the state of the serializer)
-    _write_empty_element: Callable[[str], None]
-
-    # NOTE (mristin, 2022-10-14):
-    # The serialization procedure is quite rigid. We leverage the specifics of
-    # the serialization procedure to optimize the code a bit.
-    #
-    # Namely, we model the writing of the XML elements as a state machine.
-    # The namespace is only specified for the very first element. All the subsequent
-    # elements will *not* have the namespace specified. We implement that behavior by
-    # using pointers to methods, as Python treats the methods as first-class citizens.
-    #
-    # The ``_write_start_element`` will point to
-    # ``_write_first_start_element_with_namespace`` on the *first* invocation.
-    # Afterwards, it will be redirected to ``_write_start_element_without_namespace``.
-    #
-    # Analogously for ``_write_empty_element``.
-    #
-    # Please see the implementation for the details, but this should give you at least
-    # a rough overview.
-
-    def _write_first_start_element_with_namespace(self, name: str) -> None:
-        """
-        Write the start element with the tag name :paramref:`name` and specify
-        its namespace.
-
-        The :py:attr:`~_write_start_element` is set to
-        :py:meth:`~_write_start_element_without_namespace` after the first invocation
-        of this method.
-
-        :param name: of the element tag. Expected to contain no XML special characters.
-        """
-        self.stream.write(f'<{name} xmlns="{NAMESPACE}">')
-
-        # NOTE (mristin, 2022-10-14):
-        # Any subsequence call to `_write_start_element` or `_write_empty_element`
-        # should not specify the namespace of the element as we specified now already
-        # specified it.
-        self._write_start_element = self._write_start_element_without_namespace
-        self._write_empty_element = self._write_empty_element_without_namespace
-
-    def _write_start_element_without_namespace(self, name: str) -> None:
-        """
-        Write the start element with the tag name :paramref:`name`.
-
-        The first element, written *before* this one, is expected to have been
-        already written with the namespace specified.
-
-        :param name: of the element tag. Expected to contain no XML special characters.
-        """
-        self.stream.write(f"<{name}>")
-
-    def _escape_and_write_text(self, text: str) -> None:
-        """
-        Escape :paramref:`text` for XML and write it.
-
-        :param text: to be escaped and written
-        """
-        # NOTE (mristin, 2022-10-14):
-        # We ran ``timeit`` on manual code which escaped XML special characters with
-        # a dictionary, and on another snippet which called three ``.replace()``.
-        # The code with ``.replace()`` was an order of magnitude faster on our computers.
-        self.stream.write(
-            text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
-        )
-
-    def _write_end_element(self, name: str) -> None:
-        """
-        Write the end element with the tag name :paramref:`name`.
-
-        :param name: of the element tag. Expected to contain no XML special characters.
-        """
-        self.stream.write(f"</{name}>")
-
-    def _write_first_empty_element_with_namespace(self, name: str) -> None:
-        """
-        Write the first (and only) empty element with the tag name :paramref:`name`.
-
-        No elements are expected to be written to the stream afterwards. The element
-        includes the namespace specification.
-
-        :param name: of the element tag. Expected to contain no XML special characters.
-        """
-        self.stream.write(f'<{name} xmlns="{NAMESPACE}"/>')
-        self._write_empty_element = self._rase_if_write_element_called_again
-        self._write_start_element = self._rase_if_write_element_called_again
-
-    def _rase_if_write_element_called_again(self, name: str) -> None:
-        raise AssertionError(
-            f"We expected to call ``_write_first_empty_element_with_namespace`` "
-            f"only once. This is an unexpected second call for writing "
-            f"an (empty or non-empty) element with the tag name: {name!r}"
-        )
-
-    def _write_empty_element_without_namespace(self, name: str) -> None:
-        """
-        Write the empty element with the tag name :paramref:`name`.
-
-        The call to this method is expected to occur *after* the enclosing element with
-        a specified namespace has been written.
-
-        :param name: of the element tag. Expected to contain no XML special characters.
-        """
-        self.stream.write(f"<{name}/>")
-
-    def _write_bool_property(self, name: str, value: bool) -> None:
-        """
-        Write the :paramref:`value` of a boolean property enclosed in
-        the :paramref:`name` element.
-
-        :param name: of the corresponding element tag
-        :param value: of the property
-        """
-        self._write_start_element(name)
-        self.stream.write("true" if value else "false")
-        self._write_end_element(name)
-
-    def _write_int_property(self, name: str, value: int) -> None:
-        """
-        Write the :paramref:`value` of an integer property enclosed in
-        the :paramref:`name` element.
-
-        :param name: of the corresponding element tag
-        :param value: of the property
-        """
-        self._write_start_element(name)
-        self.stream.write(str(value))
-        self._write_end_element(name)
-
-    def _write_float_property(self, name: str, value: float) -> None:
-        """
-        Write the :paramref:`value` of a floating-point property enclosed in
-        the :paramref:`name` element.
-
-        :param name: of the corresponding element tag
-        :param value: of the property
-        """
-        self._write_start_element(name)
-
-        if value == math.inf:
-            self.stream.write("INF")
-        elif value == -math.inf:
-            self.stream.write("-INF")
-        elif math.isnan(value):
-            self.stream.write("NaN")
-        elif value == 0:
-            if math.copysign(1.0, value) < 0.0:
-                self.stream.write("-0.0")
-            else:
-                self.stream.write("0.0")
-        else:
-            self.stream.write(str(value))
-
-    def _write_str_property(self, name: str, value: str) -> None:
-        """
-        Write the :paramref:`value` of a string property enclosed in
-        the :paramref:`name` element.
-
-        :param name: of the corresponding element tag
-        :param value: of the property
-        """
-        self._write_start_element(name)
-        self._escape_and_write_text(value)
-        self._write_end_element(name)
-
-    def _write_bytes_property(self, name: str, value: bytes) -> None:
-        """
-        Write the :paramref:`value` of a binary-content property enclosed in
-        the :paramref:`name` element.
-
-        :param name: of the corresponding element tag
-        :param value: of the property
-        """
-        self._write_start_element(name)
-
-        # NOTE (mristin, 2022-10-14):
-        # We need to decode the result of the base64-encoding to ASCII since we are
-        # writing to an XML *text* stream. ``base64.b64encode(.)`` gives us bytes,
-        # not a string.
-        encoded = base64.b64encode(value).decode("ascii")
-
-        # NOTE (mristin, 2022-10-14):
-        # Base64 alphabet excludes ``<``, ``>`` and ``&``, so we can directly
-        # write the ``encoded`` content to the stream as XML text.
-        #
-        # See: https://datatracker.ietf.org/doc/html/rfc4648#section-4
-        self.stream.write(encoded)
-        self._write_end_element(name)
-
-    def __init__(self, stream: TextIO) -> None:
-        """
-        Initialize the visitor to write to :paramref:`stream`.
-
-        The first element will include the :py:attr:`~.NAMESPACE`. Every other
-        element will not have the namespace specified.
-
-        :param stream: where to write to
-        """
-        self.stream = stream
-        self._write_start_element = self._write_first_start_element_with_namespace
-        self._write_empty_element = self._write_first_empty_element_with_namespace
-
-    def _write_extension_as_sequence(self, that: aas_types.Extension) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for an_item in that.supplemental_semantic_ids:
-                    self.visit(an_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        self._write_str_property("name", that.name)
-
-        if that.value_type is not None:
-            self._write_str_property("valueType", that.value_type.value)
-
-        if that.value is not None:
-            self._write_str_property("value", that.value)
-
-        if that.refers_to is not None:
-            if len(that.refers_to) == 0:
-                self._write_empty_element("refersTo")
-            else:
-                self._write_start_element("refersTo")
-                for another_item in that.refers_to:
-                    self.visit(another_item)
-                self._write_end_element("refersTo")
-
-    def visit_extension(self, that: aas_types.Extension) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("extension")
-        self._write_extension_as_sequence(that)
-        self._write_end_element("extension")
-
-    def _write_administrative_information_as_sequence(
-        self, that: aas_types.AdministrativeInformation
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for an_item in that.embedded_data_specifications:
-                    self.visit(an_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        if that.version is not None:
-            self._write_str_property("version", that.version)
-
-        if that.revision is not None:
-            self._write_str_property("revision", that.revision)
-
-        if that.creator is not None:
-            self._write_start_element("creator")
-            self._write_reference_as_sequence(that.creator)
-            self._write_end_element("creator")
-
-        if that.template_id is not None:
-            self._write_str_property("templateId", that.template_id)
-
-    def visit_administrative_information(
-        self, that: aas_types.AdministrativeInformation
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        # We optimize for the case where all the optional properties are not set,
-        # so that we can simply output an empty element.
-        if (
-            that.embedded_data_specifications is None
-            and that.version is None
-            and that.revision is None
-            and that.creator is None
-            and that.template_id is None
-        ):
-            self._write_empty_element("administrativeInformation")
-        else:
-            self._write_start_element("administrativeInformation")
-            self._write_administrative_information_as_sequence(that)
-            self._write_end_element("administrativeInformation")
-
-    def _write_qualifier_as_sequence(self, that: aas_types.Qualifier) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for an_item in that.supplemental_semantic_ids:
-                    self.visit(an_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.kind is not None:
-            self._write_str_property("kind", that.kind.value)
-
-        self._write_str_property("type", that.type)
-
-        self._write_str_property("valueType", that.value_type.value)
-
-        if that.value is not None:
-            self._write_str_property("value", that.value)
-
-        if that.value_id is not None:
-            self._write_start_element("valueId")
-            self._write_reference_as_sequence(that.value_id)
-            self._write_end_element("valueId")
-
-    def visit_qualifier(self, that: aas_types.Qualifier) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("qualifier")
-        self._write_qualifier_as_sequence(that)
-        self._write_end_element("qualifier")
-
-    def _write_asset_administration_shell_as_sequence(
-        self, that: aas_types.AssetAdministrationShell
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.administration is not None:
-            the_administration = that.administration
-            # We optimize for the case where all the optional properties are not set,
-            # so that we can simply output an empty element.
-            if (
-                the_administration.embedded_data_specifications is None
-                and the_administration.version is None
-                and the_administration.revision is None
-                and the_administration.creator is None
-                and the_administration.template_id is None
-            ):
-                self._write_empty_element("administration")
-            else:
-                self._write_start_element("administration")
-                self._write_administrative_information_as_sequence(the_administration)
-                self._write_end_element("administration")
-
-        self._write_str_property("id", that.id)
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        if that.derived_from is not None:
-            self._write_start_element("derivedFrom")
-            self._write_reference_as_sequence(that.derived_from)
-            self._write_end_element("derivedFrom")
-
-        self._write_start_element("assetInformation")
-        self._write_asset_information_as_sequence(that.asset_information)
-        self._write_end_element("assetInformation")
-
-        if that.submodels is not None:
-            if len(that.submodels) == 0:
-                self._write_empty_element("submodels")
-            else:
-                self._write_start_element("submodels")
-                for yet_yet_yet_another_item in that.submodels:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("submodels")
-
-    def visit_asset_administration_shell(
-        self, that: aas_types.AssetAdministrationShell
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("assetAdministrationShell")
-        self._write_asset_administration_shell_as_sequence(that)
-        self._write_end_element("assetAdministrationShell")
-
-    def _write_asset_information_as_sequence(
-        self, that: aas_types.AssetInformation
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_str_property("assetKind", that.asset_kind.value)
-
-        if that.global_asset_id is not None:
-            self._write_str_property("globalAssetId", that.global_asset_id)
-
-        if that.specific_asset_ids is not None:
-            if len(that.specific_asset_ids) == 0:
-                self._write_empty_element("specificAssetIds")
-            else:
-                self._write_start_element("specificAssetIds")
-                for an_item in that.specific_asset_ids:
-                    self.visit(an_item)
-                self._write_end_element("specificAssetIds")
-
-        if that.asset_type is not None:
-            self._write_str_property("assetType", that.asset_type)
-
-        if that.default_thumbnail is not None:
-            self._write_start_element("defaultThumbnail")
-            self._write_resource_as_sequence(that.default_thumbnail)
-            self._write_end_element("defaultThumbnail")
-
-    def visit_asset_information(self, that: aas_types.AssetInformation) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("assetInformation")
-        self._write_asset_information_as_sequence(that)
-        self._write_end_element("assetInformation")
-
-    def _write_resource_as_sequence(self, that: aas_types.Resource) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_str_property("path", that.path)
-
-        if that.content_type is not None:
-            self._write_str_property("contentType", that.content_type)
-
-    def visit_resource(self, that: aas_types.Resource) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("resource")
-        self._write_resource_as_sequence(that)
-        self._write_end_element("resource")
-
-    def _write_specific_asset_id_as_sequence(
-        self, that: aas_types.SpecificAssetID
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for an_item in that.supplemental_semantic_ids:
-                    self.visit(an_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        self._write_str_property("name", that.name)
-
-        self._write_str_property("value", that.value)
-
-        if that.external_subject_id is not None:
-            self._write_start_element("externalSubjectId")
-            self._write_reference_as_sequence(that.external_subject_id)
-            self._write_end_element("externalSubjectId")
-
-    def visit_specific_asset_id(self, that: aas_types.SpecificAssetID) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("specificAssetId")
-        self._write_specific_asset_id_as_sequence(that)
-        self._write_end_element("specificAssetId")
-
-    def _write_submodel_as_sequence(self, that: aas_types.Submodel) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.administration is not None:
-            the_administration = that.administration
-            # We optimize for the case where all the optional properties are not set,
-            # so that we can simply output an empty element.
-            if (
-                the_administration.embedded_data_specifications is None
-                and the_administration.version is None
-                and the_administration.revision is None
-                and the_administration.creator is None
-                and the_administration.template_id is None
-            ):
-                self._write_empty_element("administration")
-            else:
-                self._write_start_element("administration")
-                self._write_administrative_information_as_sequence(the_administration)
-                self._write_end_element("administration")
-
-        self._write_str_property("id", that.id)
-
-        if that.kind is not None:
-            self._write_str_property("kind", that.kind.value)
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        if that.submodel_elements is not None:
-            if len(that.submodel_elements) == 0:
-                self._write_empty_element("submodelElements")
-            else:
-                self._write_start_element("submodelElements")
-                for yet_yet_yet_yet_yet_another_item in that.submodel_elements:
-                    self.visit(yet_yet_yet_yet_yet_another_item)
-                self._write_end_element("submodelElements")
-
-    def visit_submodel(self, that: aas_types.Submodel) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("submodel")
-        self._write_submodel_as_sequence(that)
-        self._write_end_element("submodel")
-
-    def _write_relationship_element_as_sequence(
-        self, that: aas_types.RelationshipElement
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        self._write_start_element("first")
-        self._write_reference_as_sequence(that.first)
-        self._write_end_element("first")
-
-        self._write_start_element("second")
-        self._write_reference_as_sequence(that.second)
-        self._write_end_element("second")
-
-    def visit_relationship_element(self, that: aas_types.RelationshipElement) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("relationshipElement")
-        self._write_relationship_element_as_sequence(that)
-        self._write_end_element("relationshipElement")
-
-    def _write_submodel_element_list_as_sequence(
-        self, that: aas_types.SubmodelElementList
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        if that.order_relevant is not None:
-            self._write_bool_property("orderRelevant", that.order_relevant)
-
-        if that.semantic_id_list_element is not None:
-            self._write_start_element("semanticIdListElement")
-            self._write_reference_as_sequence(that.semantic_id_list_element)
-            self._write_end_element("semanticIdListElement")
-
-        self._write_str_property(
-            "typeValueListElement", that.type_value_list_element.value
-        )
-
-        if that.value_type_list_element is not None:
-            self._write_str_property(
-                "valueTypeListElement", that.value_type_list_element.value
-            )
-
-        if that.value is not None:
-            if len(that.value) == 0:
-                self._write_empty_element("value")
-            else:
-                self._write_start_element("value")
-                for yet_yet_yet_yet_yet_another_item in that.value:
-                    self.visit(yet_yet_yet_yet_yet_another_item)
-                self._write_end_element("value")
-
-    def visit_submodel_element_list(self, that: aas_types.SubmodelElementList) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("submodelElementList")
-        self._write_submodel_element_list_as_sequence(that)
-        self._write_end_element("submodelElementList")
-
-    def _write_submodel_element_collection_as_sequence(
-        self, that: aas_types.SubmodelElementCollection
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        if that.value is not None:
-            if len(that.value) == 0:
-                self._write_empty_element("value")
-            else:
-                self._write_start_element("value")
-                for yet_yet_yet_yet_yet_another_item in that.value:
-                    self.visit(yet_yet_yet_yet_yet_another_item)
-                self._write_end_element("value")
-
-    def visit_submodel_element_collection(
-        self, that: aas_types.SubmodelElementCollection
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        # We optimize for the case where all the optional properties are not set,
-        # so that we can simply output an empty element.
-        if (
-            that.extensions is None
-            and that.category is None
-            and that.id_short is None
-            and that.display_name is None
-            and that.description is None
-            and that.semantic_id is None
-            and that.supplemental_semantic_ids is None
-            and that.qualifiers is None
-            and that.embedded_data_specifications is None
-            and that.value is None
-        ):
-            self._write_empty_element("submodelElementCollection")
-        else:
-            self._write_start_element("submodelElementCollection")
-            self._write_submodel_element_collection_as_sequence(that)
-            self._write_end_element("submodelElementCollection")
-
-    def _write_property_as_sequence(self, that: aas_types.Property) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        self._write_str_property("valueType", that.value_type.value)
-
-        if that.value is not None:
-            self._write_str_property("value", that.value)
-
-        if that.value_id is not None:
-            self._write_start_element("valueId")
-            self._write_reference_as_sequence(that.value_id)
-            self._write_end_element("valueId")
-
-    def visit_property(self, that: aas_types.Property) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("property")
-        self._write_property_as_sequence(that)
-        self._write_end_element("property")
-
-    def _write_multi_language_property_as_sequence(
-        self, that: aas_types.MultiLanguageProperty
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        if that.value is not None:
-            if len(that.value) == 0:
-                self._write_empty_element("value")
-            else:
-                self._write_start_element("value")
-                for yet_yet_yet_yet_yet_another_item in that.value:
-                    self.visit(yet_yet_yet_yet_yet_another_item)
-                self._write_end_element("value")
-
-        if that.value_id is not None:
-            self._write_start_element("valueId")
-            self._write_reference_as_sequence(that.value_id)
-            self._write_end_element("valueId")
-
-    def visit_multi_language_property(
-        self, that: aas_types.MultiLanguageProperty
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        # We optimize for the case where all the optional properties are not set,
-        # so that we can simply output an empty element.
-        if (
-            that.extensions is None
-            and that.category is None
-            and that.id_short is None
-            and that.display_name is None
-            and that.description is None
-            and that.semantic_id is None
-            and that.supplemental_semantic_ids is None
-            and that.qualifiers is None
-            and that.embedded_data_specifications is None
-            and that.value is None
-            and that.value_id is None
-        ):
-            self._write_empty_element("multiLanguageProperty")
-        else:
-            self._write_start_element("multiLanguageProperty")
-            self._write_multi_language_property_as_sequence(that)
-            self._write_end_element("multiLanguageProperty")
-
-    def _write_range_as_sequence(self, that: aas_types.Range) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        self._write_str_property("valueType", that.value_type.value)
-
-        if that.min is not None:
-            self._write_str_property("min", that.min)
-
-        if that.max is not None:
-            self._write_str_property("max", that.max)
-
-    def visit_range(self, that: aas_types.Range) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("range")
-        self._write_range_as_sequence(that)
-        self._write_end_element("range")
-
-    def _write_reference_element_as_sequence(
-        self, that: aas_types.ReferenceElement
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        if that.value is not None:
-            self._write_start_element("value")
-            self._write_reference_as_sequence(that.value)
-            self._write_end_element("value")
-
-    def visit_reference_element(self, that: aas_types.ReferenceElement) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        # We optimize for the case where all the optional properties are not set,
-        # so that we can simply output an empty element.
-        if (
-            that.extensions is None
-            and that.category is None
-            and that.id_short is None
-            and that.display_name is None
-            and that.description is None
-            and that.semantic_id is None
-            and that.supplemental_semantic_ids is None
-            and that.qualifiers is None
-            and that.embedded_data_specifications is None
-            and that.value is None
-        ):
-            self._write_empty_element("referenceElement")
-        else:
-            self._write_start_element("referenceElement")
-            self._write_reference_element_as_sequence(that)
-            self._write_end_element("referenceElement")
-
-    def _write_blob_as_sequence(self, that: aas_types.Blob) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        if that.value is not None:
-            self._write_bytes_property("value", that.value)
-
-        self._write_str_property("contentType", that.content_type)
-
-    def visit_blob(self, that: aas_types.Blob) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("blob")
-        self._write_blob_as_sequence(that)
-        self._write_end_element("blob")
-
-    def _write_file_as_sequence(self, that: aas_types.File) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        if that.value is not None:
-            self._write_str_property("value", that.value)
-
-        self._write_str_property("contentType", that.content_type)
-
-    def visit_file(self, that: aas_types.File) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("file")
-        self._write_file_as_sequence(that)
-        self._write_end_element("file")
-
-    def _write_annotated_relationship_element_as_sequence(
-        self, that: aas_types.AnnotatedRelationshipElement
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        self._write_start_element("first")
-        self._write_reference_as_sequence(that.first)
-        self._write_end_element("first")
-
-        self._write_start_element("second")
-        self._write_reference_as_sequence(that.second)
-        self._write_end_element("second")
-
-        if that.annotations is not None:
-            if len(that.annotations) == 0:
-                self._write_empty_element("annotations")
-            else:
-                self._write_start_element("annotations")
-                for yet_yet_yet_yet_yet_another_item in that.annotations:
-                    self.visit(yet_yet_yet_yet_yet_another_item)
-                self._write_end_element("annotations")
-
-    def visit_annotated_relationship_element(
-        self, that: aas_types.AnnotatedRelationshipElement
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("annotatedRelationshipElement")
-        self._write_annotated_relationship_element_as_sequence(that)
-        self._write_end_element("annotatedRelationshipElement")
-
-    def _write_entity_as_sequence(self, that: aas_types.Entity) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        if that.statements is not None:
-            if len(that.statements) == 0:
-                self._write_empty_element("statements")
-            else:
-                self._write_start_element("statements")
-                for yet_yet_yet_yet_yet_another_item in that.statements:
-                    self.visit(yet_yet_yet_yet_yet_another_item)
-                self._write_end_element("statements")
-
-        self._write_str_property("entityType", that.entity_type.value)
-
-        if that.global_asset_id is not None:
-            self._write_str_property("globalAssetId", that.global_asset_id)
-
-        if that.specific_asset_ids is not None:
-            if len(that.specific_asset_ids) == 0:
-                self._write_empty_element("specificAssetIds")
-            else:
-                self._write_start_element("specificAssetIds")
-                for yet_yet_yet_yet_yet_yet_another_item in that.specific_asset_ids:
-                    self.visit(yet_yet_yet_yet_yet_yet_another_item)
-                self._write_end_element("specificAssetIds")
-
-    def visit_entity(self, that: aas_types.Entity) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("entity")
-        self._write_entity_as_sequence(that)
-        self._write_end_element("entity")
-
-    def _write_event_payload_as_sequence(self, that: aas_types.EventPayload) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("source")
-        self._write_reference_as_sequence(that.source)
-        self._write_end_element("source")
-
-        if that.source_semantic_id is not None:
-            self._write_start_element("sourceSemanticId")
-            self._write_reference_as_sequence(that.source_semantic_id)
-            self._write_end_element("sourceSemanticId")
-
-        self._write_start_element("observableReference")
-        self._write_reference_as_sequence(that.observable_reference)
-        self._write_end_element("observableReference")
-
-        if that.observable_semantic_id is not None:
-            self._write_start_element("observableSemanticId")
-            self._write_reference_as_sequence(that.observable_semantic_id)
-            self._write_end_element("observableSemanticId")
-
-        if that.topic is not None:
-            self._write_str_property("topic", that.topic)
-
-        if that.subject_id is not None:
-            self._write_start_element("subjectId")
-            self._write_reference_as_sequence(that.subject_id)
-            self._write_end_element("subjectId")
-
-        self._write_str_property("timeStamp", that.time_stamp)
-
-        if that.payload is not None:
-            self._write_bytes_property("payload", that.payload)
-
-    def visit_event_payload(self, that: aas_types.EventPayload) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("eventPayload")
-        self._write_event_payload_as_sequence(that)
-        self._write_end_element("eventPayload")
-
-    def _write_basic_event_element_as_sequence(
-        self, that: aas_types.BasicEventElement
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        self._write_start_element("observed")
-        self._write_reference_as_sequence(that.observed)
-        self._write_end_element("observed")
-
-        self._write_str_property("direction", that.direction.value)
-
-        self._write_str_property("state", that.state.value)
-
-        if that.message_topic is not None:
-            self._write_str_property("messageTopic", that.message_topic)
-
-        if that.message_broker is not None:
-            self._write_start_element("messageBroker")
-            self._write_reference_as_sequence(that.message_broker)
-            self._write_end_element("messageBroker")
-
-        if that.last_update is not None:
-            self._write_str_property("lastUpdate", that.last_update)
-
-        if that.min_interval is not None:
-            self._write_str_property("minInterval", that.min_interval)
-
-        if that.max_interval is not None:
-            self._write_str_property("maxInterval", that.max_interval)
-
-    def visit_basic_event_element(self, that: aas_types.BasicEventElement) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("basicEventElement")
-        self._write_basic_event_element_as_sequence(that)
-        self._write_end_element("basicEventElement")
-
-    def _write_operation_as_sequence(self, that: aas_types.Operation) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        if that.input_variables is not None:
-            if len(that.input_variables) == 0:
-                self._write_empty_element("inputVariables")
-            else:
-                self._write_start_element("inputVariables")
-                for yet_yet_yet_yet_yet_another_item in that.input_variables:
-                    self.visit(yet_yet_yet_yet_yet_another_item)
-                self._write_end_element("inputVariables")
-
-        if that.output_variables is not None:
-            if len(that.output_variables) == 0:
-                self._write_empty_element("outputVariables")
-            else:
-                self._write_start_element("outputVariables")
-                for yet_yet_yet_yet_yet_yet_another_item in that.output_variables:
-                    self.visit(yet_yet_yet_yet_yet_yet_another_item)
-                self._write_end_element("outputVariables")
-
-        if that.inoutput_variables is not None:
-            if len(that.inoutput_variables) == 0:
-                self._write_empty_element("inoutputVariables")
-            else:
-                self._write_start_element("inoutputVariables")
-                for yet_yet_yet_yet_yet_yet_yet_another_item in that.inoutput_variables:
-                    self.visit(yet_yet_yet_yet_yet_yet_yet_another_item)
-                self._write_end_element("inoutputVariables")
-
-    def visit_operation(self, that: aas_types.Operation) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        # We optimize for the case where all the optional properties are not set,
-        # so that we can simply output an empty element.
-        if (
-            that.extensions is None
-            and that.category is None
-            and that.id_short is None
-            and that.display_name is None
-            and that.description is None
-            and that.semantic_id is None
-            and that.supplemental_semantic_ids is None
-            and that.qualifiers is None
-            and that.embedded_data_specifications is None
-            and that.input_variables is None
-            and that.output_variables is None
-            and that.inoutput_variables is None
-        ):
-            self._write_empty_element("operation")
-        else:
-            self._write_start_element("operation")
-            self._write_operation_as_sequence(that)
-            self._write_end_element("operation")
-
-    def _write_operation_variable_as_sequence(
-        self, that: aas_types.OperationVariable
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("value")
-        self.visit(that.value)
-        self._write_end_element("value")
-
-    def visit_operation_variable(self, that: aas_types.OperationVariable) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("operationVariable")
-        self._write_operation_variable_as_sequence(that)
-        self._write_end_element("operationVariable")
-
-    def _write_capability_as_sequence(self, that: aas_types.Capability) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.semantic_id is not None:
-            self._write_start_element("semanticId")
-            self._write_reference_as_sequence(that.semantic_id)
-            self._write_end_element("semanticId")
-
-        if that.supplemental_semantic_ids is not None:
-            if len(that.supplemental_semantic_ids) == 0:
-                self._write_empty_element("supplementalSemanticIds")
-            else:
-                self._write_start_element("supplementalSemanticIds")
-                for yet_yet_another_item in that.supplemental_semantic_ids:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("supplementalSemanticIds")
-
-        if that.qualifiers is not None:
-            if len(that.qualifiers) == 0:
-                self._write_empty_element("qualifiers")
-            else:
-                self._write_start_element("qualifiers")
-                for yet_yet_yet_another_item in that.qualifiers:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("qualifiers")
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-    def visit_capability(self, that: aas_types.Capability) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        # We optimize for the case where all the optional properties are not set,
-        # so that we can simply output an empty element.
-        if (
-            that.extensions is None
-            and that.category is None
-            and that.id_short is None
-            and that.display_name is None
-            and that.description is None
-            and that.semantic_id is None
-            and that.supplemental_semantic_ids is None
-            and that.qualifiers is None
-            and that.embedded_data_specifications is None
-        ):
-            self._write_empty_element("capability")
-        else:
-            self._write_start_element("capability")
-            self._write_capability_as_sequence(that)
-            self._write_end_element("capability")
-
-    def _write_concept_description_as_sequence(
-        self, that: aas_types.ConceptDescription
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.extensions is not None:
-            if len(that.extensions) == 0:
-                self._write_empty_element("extensions")
-            else:
-                self._write_start_element("extensions")
-                for an_item in that.extensions:
-                    self.visit(an_item)
-                self._write_end_element("extensions")
-
-        if that.category is not None:
-            self._write_str_property("category", that.category)
-
-        if that.id_short is not None:
-            self._write_str_property("idShort", that.id_short)
-
-        if that.display_name is not None:
-            if len(that.display_name) == 0:
-                self._write_empty_element("displayName")
-            else:
-                self._write_start_element("displayName")
-                for another_item in that.display_name:
-                    self.visit(another_item)
-                self._write_end_element("displayName")
-
-        if that.description is not None:
-            if len(that.description) == 0:
-                self._write_empty_element("description")
-            else:
-                self._write_start_element("description")
-                for yet_another_item in that.description:
-                    self.visit(yet_another_item)
-                self._write_end_element("description")
-
-        if that.administration is not None:
-            the_administration = that.administration
-            # We optimize for the case where all the optional properties are not set,
-            # so that we can simply output an empty element.
-            if (
-                the_administration.embedded_data_specifications is None
-                and the_administration.version is None
-                and the_administration.revision is None
-                and the_administration.creator is None
-                and the_administration.template_id is None
-            ):
-                self._write_empty_element("administration")
-            else:
-                self._write_start_element("administration")
-                self._write_administrative_information_as_sequence(the_administration)
-                self._write_end_element("administration")
-
-        self._write_str_property("id", that.id)
-
-        if that.embedded_data_specifications is not None:
-            if len(that.embedded_data_specifications) == 0:
-                self._write_empty_element("embeddedDataSpecifications")
-            else:
-                self._write_start_element("embeddedDataSpecifications")
-                for yet_yet_another_item in that.embedded_data_specifications:
-                    self.visit(yet_yet_another_item)
-                self._write_end_element("embeddedDataSpecifications")
-
-        if that.is_case_of is not None:
-            if len(that.is_case_of) == 0:
-                self._write_empty_element("isCaseOf")
-            else:
-                self._write_start_element("isCaseOf")
-                for yet_yet_yet_another_item in that.is_case_of:
-                    self.visit(yet_yet_yet_another_item)
-                self._write_end_element("isCaseOf")
-
-    def visit_concept_description(self, that: aas_types.ConceptDescription) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("conceptDescription")
-        self._write_concept_description_as_sequence(that)
-        self._write_end_element("conceptDescription")
-
-    def _write_reference_as_sequence(self, that: aas_types.Reference) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_str_property("type", that.type.value)
-
-        if that.referred_semantic_id is not None:
-            self._write_start_element("referredSemanticId")
-            self._write_reference_as_sequence(that.referred_semantic_id)
-            self._write_end_element("referredSemanticId")
-
-        if len(that.keys) == 0:
-            self._write_empty_element("keys")
-        else:
-            self._write_start_element("keys")
-            for an_item in that.keys:
-                self.visit(an_item)
-            self._write_end_element("keys")
-
-    def visit_reference(self, that: aas_types.Reference) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("reference")
-        self._write_reference_as_sequence(that)
-        self._write_end_element("reference")
-
-    def _write_key_as_sequence(self, that: aas_types.Key) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_str_property("type", that.type.value)
-
-        self._write_str_property("value", that.value)
-
-    def visit_key(self, that: aas_types.Key) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("key")
-        self._write_key_as_sequence(that)
-        self._write_end_element("key")
-
-    def _write_lang_string_name_type_as_sequence(
-        self, that: aas_types.LangStringNameType
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_str_property("language", that.language)
-
-        self._write_str_property("text", that.text)
-
-    def visit_lang_string_name_type(self, that: aas_types.LangStringNameType) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("langStringNameType")
-        self._write_lang_string_name_type_as_sequence(that)
-        self._write_end_element("langStringNameType")
-
-    def _write_lang_string_text_type_as_sequence(
-        self, that: aas_types.LangStringTextType
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_str_property("language", that.language)
-
-        self._write_str_property("text", that.text)
-
-    def visit_lang_string_text_type(self, that: aas_types.LangStringTextType) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("langStringTextType")
-        self._write_lang_string_text_type_as_sequence(that)
-        self._write_end_element("langStringTextType")
-
-    def _write_environment_as_sequence(self, that: aas_types.Environment) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if that.asset_administration_shells is not None:
-            if len(that.asset_administration_shells) == 0:
-                self._write_empty_element("assetAdministrationShells")
-            else:
-                self._write_start_element("assetAdministrationShells")
-                for an_item in that.asset_administration_shells:
-                    self.visit(an_item)
-                self._write_end_element("assetAdministrationShells")
-
-        if that.submodels is not None:
-            if len(that.submodels) == 0:
-                self._write_empty_element("submodels")
-            else:
-                self._write_start_element("submodels")
-                for another_item in that.submodels:
-                    self.visit(another_item)
-                self._write_end_element("submodels")
-
-        if that.concept_descriptions is not None:
-            if len(that.concept_descriptions) == 0:
-                self._write_empty_element("conceptDescriptions")
-            else:
-                self._write_start_element("conceptDescriptions")
-                for yet_another_item in that.concept_descriptions:
-                    self.visit(yet_another_item)
-                self._write_end_element("conceptDescriptions")
-
-    def visit_environment(self, that: aas_types.Environment) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        # We optimize for the case where all the optional properties are not set,
-        # so that we can simply output an empty element.
-        if (
-            that.asset_administration_shells is None
-            and that.submodels is None
-            and that.concept_descriptions is None
-        ):
-            self._write_empty_element("environment")
-        else:
-            self._write_start_element("environment")
-            self._write_environment_as_sequence(that)
-            self._write_end_element("environment")
-
-    def _write_embedded_data_specification_as_sequence(
-        self, that: aas_types.EmbeddedDataSpecification
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("dataSpecification")
-        self._write_reference_as_sequence(that.data_specification)
-        self._write_end_element("dataSpecification")
-
-        self._write_start_element("dataSpecificationContent")
-        self.visit(that.data_specification_content)
-        self._write_end_element("dataSpecificationContent")
-
-    def visit_embedded_data_specification(
-        self, that: aas_types.EmbeddedDataSpecification
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("embeddedDataSpecification")
-        self._write_embedded_data_specification_as_sequence(that)
-        self._write_end_element("embeddedDataSpecification")
-
-    def _write_level_type_as_sequence(self, that: aas_types.LevelType) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_bool_property("min", that.min)
-
-        self._write_bool_property("nom", that.nom)
-
-        self._write_bool_property("typ", that.typ)
-
-        self._write_bool_property("max", that.max)
-
-    def visit_level_type(self, that: aas_types.LevelType) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("levelType")
-        self._write_level_type_as_sequence(that)
-        self._write_end_element("levelType")
-
-    def _write_value_reference_pair_as_sequence(
-        self, that: aas_types.ValueReferencePair
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_str_property("value", that.value)
-
-        self._write_start_element("valueId")
-        self._write_reference_as_sequence(that.value_id)
-        self._write_end_element("valueId")
-
-    def visit_value_reference_pair(self, that: aas_types.ValueReferencePair) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("valueReferencePair")
-        self._write_value_reference_pair_as_sequence(that)
-        self._write_end_element("valueReferencePair")
-
-    def _write_value_list_as_sequence(self, that: aas_types.ValueList) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if len(that.value_reference_pairs) == 0:
-            self._write_empty_element("valueReferencePairs")
-        else:
-            self._write_start_element("valueReferencePairs")
-            for an_item in that.value_reference_pairs:
-                self.visit(an_item)
-            self._write_end_element("valueReferencePairs")
-
-    def visit_value_list(self, that: aas_types.ValueList) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("valueList")
-        self._write_value_list_as_sequence(that)
-        self._write_end_element("valueList")
-
-    def _write_lang_string_preferred_name_type_iec_61360_as_sequence(
-        self, that: aas_types.LangStringPreferredNameTypeIEC61360
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_str_property("language", that.language)
-
-        self._write_str_property("text", that.text)
-
-    def visit_lang_string_preferred_name_type_iec_61360(
-        self, that: aas_types.LangStringPreferredNameTypeIEC61360
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("langStringPreferredNameTypeIec61360")
-        self._write_lang_string_preferred_name_type_iec_61360_as_sequence(that)
-        self._write_end_element("langStringPreferredNameTypeIec61360")
-
-    def _write_lang_string_short_name_type_iec_61360_as_sequence(
-        self, that: aas_types.LangStringShortNameTypeIEC61360
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_str_property("language", that.language)
-
-        self._write_str_property("text", that.text)
-
-    def visit_lang_string_short_name_type_iec_61360(
-        self, that: aas_types.LangStringShortNameTypeIEC61360
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("langStringShortNameTypeIec61360")
-        self._write_lang_string_short_name_type_iec_61360_as_sequence(that)
-        self._write_end_element("langStringShortNameTypeIec61360")
-
-    def _write_lang_string_definition_type_iec_61360_as_sequence(
-        self, that: aas_types.LangStringDefinitionTypeIEC61360
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        self._write_str_property("language", that.language)
-
-        self._write_str_property("text", that.text)
-
-    def visit_lang_string_definition_type_iec_61360(
-        self, that: aas_types.LangStringDefinitionTypeIEC61360
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("langStringDefinitionTypeIec61360")
-        self._write_lang_string_definition_type_iec_61360_as_sequence(that)
-        self._write_end_element("langStringDefinitionTypeIec61360")
-
-    def _write_data_specification_iec_61360_as_sequence(
-        self, that: aas_types.DataSpecificationIEC61360
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
-        XML elements.
-
-        Each element in the sequence corresponds to a property. If no properties
-        are set, nothing is written to the :py:attr:`~stream`.
-
-        :param that: instance to be serialized
-        """
-        if len(that.preferred_name) == 0:
-            self._write_empty_element("preferredName")
-        else:
-            self._write_start_element("preferredName")
-            for an_item in that.preferred_name:
-                self.visit(an_item)
-            self._write_end_element("preferredName")
-
-        if that.short_name is not None:
-            if len(that.short_name) == 0:
-                self._write_empty_element("shortName")
-            else:
-                self._write_start_element("shortName")
-                for another_item in that.short_name:
-                    self.visit(another_item)
-                self._write_end_element("shortName")
-
-        if that.unit is not None:
-            self._write_str_property("unit", that.unit)
-
-        if that.unit_id is not None:
-            self._write_start_element("unitId")
-            self._write_reference_as_sequence(that.unit_id)
-            self._write_end_element("unitId")
-
-        if that.source_of_definition is not None:
-            self._write_str_property("sourceOfDefinition", that.source_of_definition)
-
-        if that.symbol is not None:
-            self._write_str_property("symbol", that.symbol)
-
-        if that.data_type is not None:
-            self._write_str_property("dataType", that.data_type.value)
-
-        if that.definition is not None:
-            if len(that.definition) == 0:
-                self._write_empty_element("definition")
-            else:
-                self._write_start_element("definition")
-                for yet_another_item in that.definition:
-                    self.visit(yet_another_item)
-                self._write_end_element("definition")
-
-        if that.value_format is not None:
-            self._write_str_property("valueFormat", that.value_format)
-
-        if that.value_list is not None:
-            self._write_start_element("valueList")
-            self._write_value_list_as_sequence(that.value_list)
-            self._write_end_element("valueList")
-
-        if that.value is not None:
-            self._write_str_property("value", that.value)
-
-        if that.level_type is not None:
-            self._write_start_element("levelType")
-            self._write_level_type_as_sequence(that.level_type)
-            self._write_end_element("levelType")
-
-    def visit_data_specification_iec_61360(
-        self, that: aas_types.DataSpecificationIEC61360
-    ) -> None:
-        """
-        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
-
-        The enclosing XML element designates the class of the instance, where its
-        children correspond to the properties of the instance.
-
-        :param that: instance to be serialized
-        """
-        self._write_start_element("dataSpecificationIec61360")
-        self._write_data_specification_iec_61360_as_sequence(that)
-        self._write_end_element("dataSpecificationIec61360")
-
-
-def write(instance: aas_types.Class, stream: TextIO) -> None:
-    """
-    Write the XML representation of :paramref:`instance` to :paramref:`stream`.
-
-    Example usage:
-
-    .. code-block::
-
-        import pathlib
-
-        import aas_core3.types as aas_types
-        import aas_core3.xmlization as aas_xmlization
-
-        instance = Extension(
-           ... # some constructor arguments
-        )
-
-        pth = pathlib.Path(...)
-        with pth.open("wt") as fid:
-            aas_xmlization.write(instance, fid)
-
-    :param instance: to be serialized
-    :param stream: to write to
-    """
-    serializer = _Serializer(stream)
-    serializer.visit(instance)
-
-
-def to_str(that: aas_types.Class) -> str:
-    """
-    Serialize :paramref:`that` to an XML-encoded text.
-
-    :param that: instance to be serialized
-    :return: :paramref:`that` serialized to XML serialized to text
-    """
-    writer = io.StringIO()
-    write(that, writer)
-    return writer.getvalue()
-
-
-# endregion
+"""
+Read and write AAS models as XML.
+
+For reading, we provide different reading functions, each handling a different kind
+of input. All the reading functions operate in one pass, *i.e.*, the source is read
+incrementally and the complete XML is not held in memory.
+
+We provide the following four reading functions (where ``X`` represents the name of
+the class):
+
+1) ``X_from_iterparse`` reads from a stream of ``(event, element)`` tuples coming from
+   :py:func:`xml.etree.ElementTree.iterparse` with the argument
+   ``events=["start", "end"]``. If you do not trust the source, please consider
+   using `defusedxml.ElementTree`_.
+2) ``X_from_stream`` reads from the given text stream.
+3) ``X_from_file`` reads from a file on disk.
+4) ``X_from_str`` reads from the given string.
+
+The functions ``X_from_stream``, ``X_from_file`` and ``X_from_str`` provide
+an extra parameter, ``has_iterparse``, which allows you to use a parsing library
+different from :py:mod:`xml.etree.ElementTree`. For example, you can pass in
+`defusedxml.ElementTree`_.
+
+.. _defusedxml.ElementTree: https://pypi.org/project/defusedxml/#defusedxml-elementtree
+
+All XML elements are expected to live in the :py:attr:`~NAMESPACE`.
+
+For writing, use the function :py:func:`aas_core3.xmlization.write` which
+translates the instance of the model into an XML document and writes it in one pass
+to the stream.
+
+Here is an example usage how to de-serialize from a file:
+
+.. code-block::
+
+    import pathlib
+    import xml.etree.ElementTree as ET
+
+    import aas_core3.xmlization as aas_xmlization
+
+    path = pathlib.Path(...)
+    instance = aas_xmlization.read_extension_from_file(
+        path
+    )
+
+    # Do something with the ``instance``
+
+Here is another code example where we serialize the instance:
+
+.. code-block::
+
+    import pathlib
+
+    import aas_core3.types as aas_types
+    import aas_core3.xmlization as aas_xmlization
+
+    instance = Extension(
+       ... # some constructor arguments
+    )
+
+    pth = pathlib.Path(...)
+    with pth.open("wt") as fid:
+        aas_xmlization.write(instance, fid)
+"""
+
+
+# This code has been automatically generated by aas-core-codegen.
+# Do NOT edit or append.
+
+
+import base64
+import io
+import math
+import os
+import sys
+from typing import (
+    Any,
+    Callable,
+    Iterator,
+    List,
+    Mapping,
+    Optional,
+    Sequence,
+    TextIO,
+    Tuple,
+    Union,
+    TYPE_CHECKING,
+)
+import xml.etree.ElementTree
+
+if sys.version_info >= (3, 8):
+    from typing import Final, Protocol
+else:
+    from typing_extensions import Final, Protocol
+
+import aas_core3.stringification as aas_stringification
+import aas_core3.types as aas_types
+
+# See: https://stackoverflow.com/questions/55076778/why-isnt-this-function-type-annotated-correctly-error-missing-type-parameters
+if TYPE_CHECKING:
+    PathLike = os.PathLike[Any]
+else:
+    PathLike = os.PathLike
+
+
+#: XML namespace in which all the elements are expected to reside
+NAMESPACE = "https://admin-shell.io/aas/3/0"
+
+
+# region De-serialization
+
+
+#: XML namespace as a prefix specially tailored for
+#: :py:mod:`xml.etree.ElementTree`
+_NAMESPACE_IN_CURLY_BRACKETS = f"{{{NAMESPACE}}}"
+
+
+class Element(Protocol):
+    """Behave like :py:meth:`xml.etree.ElementTree.Element`."""
+
+    @property
+    def attrib(self) -> Optional[Mapping[str, str]]:
+        """Attributes of the element"""
+        raise NotImplementedError()
+
+    @property
+    def text(self) -> Optional[str]:
+        """Text content of the element"""
+        raise NotImplementedError()
+
+    @property
+    def tail(self) -> Optional[str]:
+        """Tail text of the element"""
+        raise NotImplementedError()
+
+    @property
+    def tag(self) -> str:
+        """Tag of the element; with a namespace provided as a ``{...}`` prefix"""
+        raise NotImplementedError()
+
+    def clear(self) -> None:
+        """Behave like :py:meth:`xml.etree.ElementTree.Element.clear`."""
+        raise NotImplementedError()
+
+
+class HasIterparse(Protocol):
+    """Parse an XML document incrementally."""
+
+    # NOTE (mristin, 2022-10-26):
+    # ``self`` is not used in this context, but is necessary for Mypy,
+    # see: https://github.com/python/mypy/issues/5018 and
+    # https://github.com/python/mypy/commit/3efbc5c5e910296a60ed5b9e0e7eb11dd912c3ed#diff-e165eb7aed9dca0a5ebd93985c8cd263a6462d36ac185f9461348dc5a1396d76R9937
+
+    def iterparse(
+        self, source: TextIO, events: Optional[Sequence[str]] = None
+    ) -> Iterator[Tuple[str, Element]]:
+        """Behave like :py:func:`xml.etree.ElementTree.iterparse`."""
+
+
+class ElementSegment:
+    """Represent an element on a path to the erroneous value."""
+
+    #: Erroneous element
+    element: Final[Element]
+
+    def __init__(self, element: Element) -> None:
+        """Initialize with the given values."""
+        self.element = element
+
+    def __str__(self) -> str:
+        """
+        Render the segment as a tag without the namespace.
+
+        We deliberately omit the namespace in the tag names. If you want to actually
+        query with the resulting XPath, you have to insert the namespaces manually.
+        We did not know how to include the namespace in a meaningful way, as XPath
+        assumes namespace prefixes to be defined *outside* of the document. At least
+        the path thus rendered is informative, and you should be able to descend it
+        manually.
+        """
+        _, has_namespace, tag_wo_ns = self.element.tag.rpartition("}")
+        if not has_namespace:
+            return self.element.tag
+        else:
+            return tag_wo_ns
+
+
+class IndexSegment:
+    """Represent an element in a sequence on a path to the erroneous value."""
+
+    #: Erroneous element
+    element: Final[Element]
+
+    #: Index of the element in the sequence
+    index: Final[int]
+
+    def __init__(self, element: Element, index: int) -> None:
+        """Initialize with the given values."""
+        self.element = element
+        self.index = index
+
+    def __str__(self) -> str:
+        """Render the segment as an element wildcard with the index."""
+        return f"*[{self.index}]"
+
+
+Segment = Union[ElementSegment, IndexSegment]
+
+
+class Path:
+    """Represent the relative path to the erroneous element."""
+
+    def __init__(self) -> None:
+        """Initialize as an empty path."""
+        self._segments = []  # type: List[Segment]
+
+    @property
+    def segments(self) -> Sequence[Segment]:
+        """Get the segments of the path."""
+        return self._segments
+
+    def _prepend(self, segment: Segment) -> None:
+        """Insert the :paramref:`segment` in front of other segments."""
+        self._segments.insert(0, segment)
+
+    def __str__(self) -> str:
+        """Render the path as a relative XPath.
+
+        We omit the leading ``/`` so that you can easily prefix it as you need.
+        """
+        return "/".join(str(segment) for segment in self._segments)
+
+
+class DeserializationException(Exception):
+    """Signal that the XML de-serialization could not be performed."""
+
+    #: Human-readable explanation of the exception's cause
+    cause: Final[str]
+
+    #: Relative path to the erroneous value
+    path: Final[Path]
+
+    def __init__(self, cause: str) -> None:
+        """Initialize with the given :paramref:`cause` and an empty path."""
+        self.cause = cause
+        self.path = Path()
+
+
+def _with_elements_cleared_after_yield(
+    iterator: Iterator[Tuple[str, Element]]
+) -> Iterator[Tuple[str, Element]]:
+    """
+    Map the :paramref:`iterator` such that the element is ``clear()``'ed
+    *after* every ``yield``.
+
+    :param iterator: to be mapped
+    :yield: event and element from :paramref:`iterator`
+    """
+    for event, element in iterator:
+        yield event, element
+        element.clear()
+
+
+def has_semantics_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.HasSemantics:
+    """
+    Read an instance of :py:class:`.types.HasSemantics` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.has_semantics_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasSemantics` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for HasSemantics, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for HasSemantics, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_has_semantics_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def has_semantics_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.HasSemantics:
+    """
+    Read an instance of :py:class:`.types.HasSemantics` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.has_semantics_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.HasSemantics` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasSemantics` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return has_semantics_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def has_semantics_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.HasSemantics:
+    """
+    Read an instance of :py:class:`.types.HasSemantics` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.has_semantics_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.HasSemantics` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasSemantics` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return has_semantics_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def has_semantics_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.HasSemantics:
+    """
+    Read an instance of :py:class:`.types.HasSemantics` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.has_semantics_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.HasSemantics` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasSemantics` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return has_semantics_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def extension_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Extension:
+    """
+    Read an instance of :py:class:`.types.Extension` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.extension_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Extension` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Extension, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Extension, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_extension_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def extension_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Extension:
+    """
+    Read an instance of :py:class:`.types.Extension` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.extension_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Extension` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Extension` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return extension_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def extension_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Extension:
+    """
+    Read an instance of :py:class:`.types.Extension` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.extension_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Extension` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Extension` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return extension_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def extension_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Extension:
+    """
+    Read an instance of :py:class:`.types.Extension` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.extension_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Extension` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Extension` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return extension_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def has_extensions_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.HasExtensions:
+    """
+    Read an instance of :py:class:`.types.HasExtensions` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.has_extensions_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasExtensions` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for HasExtensions, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for HasExtensions, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_has_extensions_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def has_extensions_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.HasExtensions:
+    """
+    Read an instance of :py:class:`.types.HasExtensions` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.has_extensions_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.HasExtensions` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasExtensions` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return has_extensions_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def has_extensions_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.HasExtensions:
+    """
+    Read an instance of :py:class:`.types.HasExtensions` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.has_extensions_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.HasExtensions` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasExtensions` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return has_extensions_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def has_extensions_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.HasExtensions:
+    """
+    Read an instance of :py:class:`.types.HasExtensions` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.has_extensions_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.HasExtensions` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasExtensions` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return has_extensions_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def referable_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Referable:
+    """
+    Read an instance of :py:class:`.types.Referable` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.referable_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Referable` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Referable, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Referable, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_referable_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def referable_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Referable:
+    """
+    Read an instance of :py:class:`.types.Referable` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.referable_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Referable` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Referable` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return referable_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def referable_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Referable:
+    """
+    Read an instance of :py:class:`.types.Referable` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.referable_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Referable` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Referable` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return referable_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def referable_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Referable:
+    """
+    Read an instance of :py:class:`.types.Referable` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.referable_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Referable` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Referable` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return referable_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def identifiable_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Identifiable:
+    """
+    Read an instance of :py:class:`.types.Identifiable` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.identifiable_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Identifiable` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Identifiable, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Identifiable, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_identifiable_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def identifiable_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Identifiable:
+    """
+    Read an instance of :py:class:`.types.Identifiable` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.identifiable_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Identifiable` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Identifiable` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return identifiable_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def identifiable_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Identifiable:
+    """
+    Read an instance of :py:class:`.types.Identifiable` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.identifiable_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Identifiable` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Identifiable` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return identifiable_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def identifiable_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Identifiable:
+    """
+    Read an instance of :py:class:`.types.Identifiable` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.identifiable_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Identifiable` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Identifiable` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return identifiable_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def has_kind_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.HasKind:
+    """
+    Read an instance of :py:class:`.types.HasKind` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.has_kind_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasKind` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for HasKind, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for HasKind, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_has_kind_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def has_kind_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.HasKind:
+    """
+    Read an instance of :py:class:`.types.HasKind` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.has_kind_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.HasKind` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasKind` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return has_kind_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def has_kind_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.HasKind:
+    """
+    Read an instance of :py:class:`.types.HasKind` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.has_kind_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.HasKind` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasKind` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return has_kind_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def has_kind_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.HasKind:
+    """
+    Read an instance of :py:class:`.types.HasKind` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.has_kind_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.HasKind` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasKind` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return has_kind_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def has_data_specification_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.HasDataSpecification:
+    """
+    Read an instance of :py:class:`.types.HasDataSpecification` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.has_data_specification_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasDataSpecification` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for HasDataSpecification, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for HasDataSpecification, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_has_data_specification_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def has_data_specification_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.HasDataSpecification:
+    """
+    Read an instance of :py:class:`.types.HasDataSpecification` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.has_data_specification_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.HasDataSpecification` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasDataSpecification` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return has_data_specification_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def has_data_specification_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.HasDataSpecification:
+    """
+    Read an instance of :py:class:`.types.HasDataSpecification` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.has_data_specification_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.HasDataSpecification` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasDataSpecification` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return has_data_specification_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def has_data_specification_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.HasDataSpecification:
+    """
+    Read an instance of :py:class:`.types.HasDataSpecification` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.has_data_specification_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.HasDataSpecification` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.HasDataSpecification` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return has_data_specification_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def administrative_information_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AdministrativeInformation:
+    """
+    Read an instance of :py:class:`.types.AdministrativeInformation` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.administrative_information_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AdministrativeInformation` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for AdministrativeInformation, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for AdministrativeInformation, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_administrative_information_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def administrative_information_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AdministrativeInformation:
+    """
+    Read an instance of :py:class:`.types.AdministrativeInformation` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.administrative_information_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.AdministrativeInformation` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AdministrativeInformation` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return administrative_information_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def administrative_information_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AdministrativeInformation:
+    """
+    Read an instance of :py:class:`.types.AdministrativeInformation` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.administrative_information_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.AdministrativeInformation` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AdministrativeInformation` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return administrative_information_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def administrative_information_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AdministrativeInformation:
+    """
+    Read an instance of :py:class:`.types.AdministrativeInformation` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.administrative_information_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.AdministrativeInformation` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AdministrativeInformation` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return administrative_information_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def qualifiable_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Qualifiable:
+    """
+    Read an instance of :py:class:`.types.Qualifiable` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.qualifiable_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Qualifiable` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Qualifiable, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Qualifiable, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_qualifiable_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def qualifiable_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Qualifiable:
+    """
+    Read an instance of :py:class:`.types.Qualifiable` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.qualifiable_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Qualifiable` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Qualifiable` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return qualifiable_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def qualifiable_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Qualifiable:
+    """
+    Read an instance of :py:class:`.types.Qualifiable` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.qualifiable_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Qualifiable` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Qualifiable` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return qualifiable_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def qualifiable_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Qualifiable:
+    """
+    Read an instance of :py:class:`.types.Qualifiable` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.qualifiable_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Qualifiable` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Qualifiable` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return qualifiable_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def qualifier_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Qualifier:
+    """
+    Read an instance of :py:class:`.types.Qualifier` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.qualifier_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Qualifier` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Qualifier, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Qualifier, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_qualifier_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def qualifier_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Qualifier:
+    """
+    Read an instance of :py:class:`.types.Qualifier` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.qualifier_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Qualifier` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Qualifier` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return qualifier_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def qualifier_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Qualifier:
+    """
+    Read an instance of :py:class:`.types.Qualifier` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.qualifier_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Qualifier` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Qualifier` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return qualifier_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def qualifier_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Qualifier:
+    """
+    Read an instance of :py:class:`.types.Qualifier` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.qualifier_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Qualifier` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Qualifier` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return qualifier_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def asset_administration_shell_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AssetAdministrationShell:
+    """
+    Read an instance of :py:class:`.types.AssetAdministrationShell` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.asset_administration_shell_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AssetAdministrationShell` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for AssetAdministrationShell, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for AssetAdministrationShell, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_asset_administration_shell_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def asset_administration_shell_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AssetAdministrationShell:
+    """
+    Read an instance of :py:class:`.types.AssetAdministrationShell` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.asset_administration_shell_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.AssetAdministrationShell` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AssetAdministrationShell` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return asset_administration_shell_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def asset_administration_shell_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AssetAdministrationShell:
+    """
+    Read an instance of :py:class:`.types.AssetAdministrationShell` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.asset_administration_shell_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.AssetAdministrationShell` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AssetAdministrationShell` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return asset_administration_shell_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def asset_administration_shell_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AssetAdministrationShell:
+    """
+    Read an instance of :py:class:`.types.AssetAdministrationShell` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.asset_administration_shell_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.AssetAdministrationShell` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AssetAdministrationShell` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return asset_administration_shell_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def asset_information_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AssetInformation:
+    """
+    Read an instance of :py:class:`.types.AssetInformation` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.asset_information_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AssetInformation` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for AssetInformation, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for AssetInformation, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_asset_information_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def asset_information_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AssetInformation:
+    """
+    Read an instance of :py:class:`.types.AssetInformation` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.asset_information_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.AssetInformation` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AssetInformation` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return asset_information_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def asset_information_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AssetInformation:
+    """
+    Read an instance of :py:class:`.types.AssetInformation` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.asset_information_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.AssetInformation` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AssetInformation` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return asset_information_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def asset_information_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AssetInformation:
+    """
+    Read an instance of :py:class:`.types.AssetInformation` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.asset_information_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.AssetInformation` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AssetInformation` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return asset_information_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def resource_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Resource:
+    """
+    Read an instance of :py:class:`.types.Resource` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.resource_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Resource` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Resource, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Resource, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_resource_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def resource_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Resource:
+    """
+    Read an instance of :py:class:`.types.Resource` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.resource_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Resource` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Resource` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return resource_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def resource_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Resource:
+    """
+    Read an instance of :py:class:`.types.Resource` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.resource_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Resource` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Resource` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return resource_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def resource_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Resource:
+    """
+    Read an instance of :py:class:`.types.Resource` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.resource_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Resource` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Resource` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return resource_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def specific_asset_id_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.SpecificAssetID:
+    """
+    Read an instance of :py:class:`.types.SpecificAssetID` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.specific_asset_id_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SpecificAssetID` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for SpecificAssetID, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for SpecificAssetID, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_specific_asset_id_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def specific_asset_id_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.SpecificAssetID:
+    """
+    Read an instance of :py:class:`.types.SpecificAssetID` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.specific_asset_id_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.SpecificAssetID` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SpecificAssetID` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return specific_asset_id_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def specific_asset_id_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.SpecificAssetID:
+    """
+    Read an instance of :py:class:`.types.SpecificAssetID` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.specific_asset_id_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.SpecificAssetID` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SpecificAssetID` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return specific_asset_id_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def specific_asset_id_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.SpecificAssetID:
+    """
+    Read an instance of :py:class:`.types.SpecificAssetID` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.specific_asset_id_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.SpecificAssetID` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SpecificAssetID` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return specific_asset_id_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def submodel_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Submodel:
+    """
+    Read an instance of :py:class:`.types.Submodel` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.submodel_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Submodel` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Submodel, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Submodel, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_submodel_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def submodel_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Submodel:
+    """
+    Read an instance of :py:class:`.types.Submodel` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.submodel_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Submodel` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Submodel` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return submodel_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def submodel_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Submodel:
+    """
+    Read an instance of :py:class:`.types.Submodel` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.submodel_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Submodel` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Submodel` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return submodel_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def submodel_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Submodel:
+    """
+    Read an instance of :py:class:`.types.Submodel` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.submodel_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Submodel` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Submodel` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return submodel_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def submodel_element_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.SubmodelElement:
+    """
+    Read an instance of :py:class:`.types.SubmodelElement` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.submodel_element_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SubmodelElement` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for SubmodelElement, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for SubmodelElement, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_submodel_element_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def submodel_element_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.SubmodelElement:
+    """
+    Read an instance of :py:class:`.types.SubmodelElement` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.submodel_element_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.SubmodelElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SubmodelElement` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return submodel_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def submodel_element_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.SubmodelElement:
+    """
+    Read an instance of :py:class:`.types.SubmodelElement` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.submodel_element_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.SubmodelElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SubmodelElement` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return submodel_element_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def submodel_element_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.SubmodelElement:
+    """
+    Read an instance of :py:class:`.types.SubmodelElement` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.submodel_element_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.SubmodelElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SubmodelElement` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return submodel_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def relationship_element_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.RelationshipElement:
+    """
+    Read an instance of :py:class:`.types.RelationshipElement` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.relationship_element_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.RelationshipElement` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for RelationshipElement, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for RelationshipElement, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_relationship_element_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def relationship_element_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.RelationshipElement:
+    """
+    Read an instance of :py:class:`.types.RelationshipElement` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.relationship_element_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.RelationshipElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.RelationshipElement` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return relationship_element_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def relationship_element_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.RelationshipElement:
+    """
+    Read an instance of :py:class:`.types.RelationshipElement` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.relationship_element_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.RelationshipElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.RelationshipElement` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return relationship_element_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def relationship_element_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.RelationshipElement:
+    """
+    Read an instance of :py:class:`.types.RelationshipElement` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.relationship_element_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.RelationshipElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.RelationshipElement` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return relationship_element_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def submodel_element_list_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.SubmodelElementList:
+    """
+    Read an instance of :py:class:`.types.SubmodelElementList` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.submodel_element_list_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SubmodelElementList` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for SubmodelElementList, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for SubmodelElementList, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_submodel_element_list_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def submodel_element_list_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.SubmodelElementList:
+    """
+    Read an instance of :py:class:`.types.SubmodelElementList` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.submodel_element_list_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.SubmodelElementList` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SubmodelElementList` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return submodel_element_list_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def submodel_element_list_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.SubmodelElementList:
+    """
+    Read an instance of :py:class:`.types.SubmodelElementList` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.submodel_element_list_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.SubmodelElementList` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SubmodelElementList` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return submodel_element_list_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def submodel_element_list_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.SubmodelElementList:
+    """
+    Read an instance of :py:class:`.types.SubmodelElementList` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.submodel_element_list_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.SubmodelElementList` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SubmodelElementList` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return submodel_element_list_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def submodel_element_collection_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.SubmodelElementCollection:
+    """
+    Read an instance of :py:class:`.types.SubmodelElementCollection` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.submodel_element_collection_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SubmodelElementCollection` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for SubmodelElementCollection, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for SubmodelElementCollection, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_submodel_element_collection_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def submodel_element_collection_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.SubmodelElementCollection:
+    """
+    Read an instance of :py:class:`.types.SubmodelElementCollection` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.submodel_element_collection_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.SubmodelElementCollection` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SubmodelElementCollection` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return submodel_element_collection_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def submodel_element_collection_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.SubmodelElementCollection:
+    """
+    Read an instance of :py:class:`.types.SubmodelElementCollection` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.submodel_element_collection_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.SubmodelElementCollection` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SubmodelElementCollection` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return submodel_element_collection_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def submodel_element_collection_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.SubmodelElementCollection:
+    """
+    Read an instance of :py:class:`.types.SubmodelElementCollection` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.submodel_element_collection_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.SubmodelElementCollection` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.SubmodelElementCollection` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return submodel_element_collection_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def data_element_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.DataElement:
+    """
+    Read an instance of :py:class:`.types.DataElement` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.data_element_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.DataElement` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for DataElement, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for DataElement, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_data_element_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def data_element_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.DataElement:
+    """
+    Read an instance of :py:class:`.types.DataElement` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.data_element_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.DataElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.DataElement` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return data_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def data_element_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.DataElement:
+    """
+    Read an instance of :py:class:`.types.DataElement` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.data_element_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.DataElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.DataElement` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return data_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def data_element_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.DataElement:
+    """
+    Read an instance of :py:class:`.types.DataElement` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.data_element_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.DataElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.DataElement` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return data_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def property_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Property:
+    """
+    Read an instance of :py:class:`.types.Property` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.property_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Property` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Property, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Property, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_property_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def property_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Property:
+    """
+    Read an instance of :py:class:`.types.Property` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.property_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Property` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Property` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return property_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def property_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Property:
+    """
+    Read an instance of :py:class:`.types.Property` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.property_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Property` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Property` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return property_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def property_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Property:
+    """
+    Read an instance of :py:class:`.types.Property` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.property_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Property` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Property` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return property_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def multi_language_property_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.MultiLanguageProperty:
+    """
+    Read an instance of :py:class:`.types.MultiLanguageProperty` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.multi_language_property_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.MultiLanguageProperty` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for MultiLanguageProperty, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for MultiLanguageProperty, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_multi_language_property_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def multi_language_property_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.MultiLanguageProperty:
+    """
+    Read an instance of :py:class:`.types.MultiLanguageProperty` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.multi_language_property_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.MultiLanguageProperty` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.MultiLanguageProperty` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return multi_language_property_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def multi_language_property_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.MultiLanguageProperty:
+    """
+    Read an instance of :py:class:`.types.MultiLanguageProperty` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.multi_language_property_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.MultiLanguageProperty` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.MultiLanguageProperty` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return multi_language_property_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def multi_language_property_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.MultiLanguageProperty:
+    """
+    Read an instance of :py:class:`.types.MultiLanguageProperty` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.multi_language_property_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.MultiLanguageProperty` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.MultiLanguageProperty` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return multi_language_property_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def range_from_iterparse(iterator: Iterator[Tuple[str, Element]]) -> aas_types.Range:
+    """
+    Read an instance of :py:class:`.types.Range` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.range_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Range` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Range, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Range, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_range_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def range_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Range:
+    """
+    Read an instance of :py:class:`.types.Range` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.range_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Range` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Range` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return range_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def range_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Range:
+    """
+    Read an instance of :py:class:`.types.Range` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.range_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Range` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Range` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return range_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def range_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Range:
+    """
+    Read an instance of :py:class:`.types.Range` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.range_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Range` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Range` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return range_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def reference_element_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ReferenceElement:
+    """
+    Read an instance of :py:class:`.types.ReferenceElement` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.reference_element_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ReferenceElement` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for ReferenceElement, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for ReferenceElement, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_reference_element_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def reference_element_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.ReferenceElement:
+    """
+    Read an instance of :py:class:`.types.ReferenceElement` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.reference_element_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.ReferenceElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ReferenceElement` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return reference_element_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def reference_element_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.ReferenceElement:
+    """
+    Read an instance of :py:class:`.types.ReferenceElement` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.reference_element_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.ReferenceElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ReferenceElement` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return reference_element_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def reference_element_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.ReferenceElement:
+    """
+    Read an instance of :py:class:`.types.ReferenceElement` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.reference_element_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.ReferenceElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ReferenceElement` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return reference_element_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def blob_from_iterparse(iterator: Iterator[Tuple[str, Element]]) -> aas_types.Blob:
+    """
+    Read an instance of :py:class:`.types.Blob` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.blob_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Blob` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Blob, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Blob, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_blob_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def blob_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Blob:
+    """
+    Read an instance of :py:class:`.types.Blob` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.blob_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Blob` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Blob` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return blob_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def blob_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Blob:
+    """
+    Read an instance of :py:class:`.types.Blob` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.blob_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Blob` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Blob` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return blob_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def blob_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Blob:
+    """
+    Read an instance of :py:class:`.types.Blob` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.blob_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Blob` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Blob` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return blob_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def file_from_iterparse(iterator: Iterator[Tuple[str, Element]]) -> aas_types.File:
+    """
+    Read an instance of :py:class:`.types.File` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.file_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.File` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for File, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for File, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_file_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def file_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.File:
+    """
+    Read an instance of :py:class:`.types.File` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.file_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.File` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.File` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return file_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def file_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.File:
+    """
+    Read an instance of :py:class:`.types.File` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.file_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.File` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.File` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return file_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def file_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.File:
+    """
+    Read an instance of :py:class:`.types.File` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.file_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.File` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.File` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return file_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def annotated_relationship_element_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AnnotatedRelationshipElement:
+    """
+    Read an instance of :py:class:`.types.AnnotatedRelationshipElement` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.annotated_relationship_element_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AnnotatedRelationshipElement` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for AnnotatedRelationshipElement, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for AnnotatedRelationshipElement, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_annotated_relationship_element_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def annotated_relationship_element_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AnnotatedRelationshipElement:
+    """
+    Read an instance of :py:class:`.types.AnnotatedRelationshipElement` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.annotated_relationship_element_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.AnnotatedRelationshipElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AnnotatedRelationshipElement` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return annotated_relationship_element_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def annotated_relationship_element_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AnnotatedRelationshipElement:
+    """
+    Read an instance of :py:class:`.types.AnnotatedRelationshipElement` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.annotated_relationship_element_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.AnnotatedRelationshipElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AnnotatedRelationshipElement` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return annotated_relationship_element_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def annotated_relationship_element_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AnnotatedRelationshipElement:
+    """
+    Read an instance of :py:class:`.types.AnnotatedRelationshipElement` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.annotated_relationship_element_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.AnnotatedRelationshipElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AnnotatedRelationshipElement` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return annotated_relationship_element_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def entity_from_iterparse(iterator: Iterator[Tuple[str, Element]]) -> aas_types.Entity:
+    """
+    Read an instance of :py:class:`.types.Entity` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.entity_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Entity` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Entity, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Entity, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_entity_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def entity_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Entity:
+    """
+    Read an instance of :py:class:`.types.Entity` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.entity_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Entity` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Entity` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return entity_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def entity_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Entity:
+    """
+    Read an instance of :py:class:`.types.Entity` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.entity_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Entity` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Entity` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return entity_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def entity_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Entity:
+    """
+    Read an instance of :py:class:`.types.Entity` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.entity_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Entity` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Entity` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return entity_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def event_payload_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.EventPayload:
+    """
+    Read an instance of :py:class:`.types.EventPayload` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.event_payload_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.EventPayload` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for EventPayload, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for EventPayload, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_event_payload_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def event_payload_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.EventPayload:
+    """
+    Read an instance of :py:class:`.types.EventPayload` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.event_payload_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.EventPayload` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.EventPayload` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return event_payload_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def event_payload_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.EventPayload:
+    """
+    Read an instance of :py:class:`.types.EventPayload` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.event_payload_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.EventPayload` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.EventPayload` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return event_payload_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def event_payload_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.EventPayload:
+    """
+    Read an instance of :py:class:`.types.EventPayload` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.event_payload_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.EventPayload` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.EventPayload` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return event_payload_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def event_element_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.EventElement:
+    """
+    Read an instance of :py:class:`.types.EventElement` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.event_element_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.EventElement` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for EventElement, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for EventElement, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_event_element_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def event_element_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.EventElement:
+    """
+    Read an instance of :py:class:`.types.EventElement` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.event_element_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.EventElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.EventElement` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return event_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def event_element_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.EventElement:
+    """
+    Read an instance of :py:class:`.types.EventElement` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.event_element_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.EventElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.EventElement` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return event_element_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def event_element_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.EventElement:
+    """
+    Read an instance of :py:class:`.types.EventElement` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.event_element_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.EventElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.EventElement` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return event_element_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def basic_event_element_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.BasicEventElement:
+    """
+    Read an instance of :py:class:`.types.BasicEventElement` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.basic_event_element_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.BasicEventElement` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for BasicEventElement, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for BasicEventElement, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_basic_event_element_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def basic_event_element_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.BasicEventElement:
+    """
+    Read an instance of :py:class:`.types.BasicEventElement` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.basic_event_element_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.BasicEventElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.BasicEventElement` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return basic_event_element_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def basic_event_element_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.BasicEventElement:
+    """
+    Read an instance of :py:class:`.types.BasicEventElement` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.basic_event_element_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.BasicEventElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.BasicEventElement` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return basic_event_element_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def basic_event_element_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.BasicEventElement:
+    """
+    Read an instance of :py:class:`.types.BasicEventElement` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.basic_event_element_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.BasicEventElement` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.BasicEventElement` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return basic_event_element_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def operation_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Operation:
+    """
+    Read an instance of :py:class:`.types.Operation` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.operation_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Operation` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Operation, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Operation, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_operation_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def operation_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Operation:
+    """
+    Read an instance of :py:class:`.types.Operation` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.operation_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Operation` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Operation` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return operation_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def operation_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Operation:
+    """
+    Read an instance of :py:class:`.types.Operation` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.operation_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Operation` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Operation` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return operation_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def operation_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Operation:
+    """
+    Read an instance of :py:class:`.types.Operation` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.operation_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Operation` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Operation` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return operation_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def operation_variable_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.OperationVariable:
+    """
+    Read an instance of :py:class:`.types.OperationVariable` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.operation_variable_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.OperationVariable` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for OperationVariable, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for OperationVariable, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_operation_variable_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def operation_variable_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.OperationVariable:
+    """
+    Read an instance of :py:class:`.types.OperationVariable` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.operation_variable_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.OperationVariable` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.OperationVariable` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return operation_variable_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def operation_variable_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.OperationVariable:
+    """
+    Read an instance of :py:class:`.types.OperationVariable` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.operation_variable_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.OperationVariable` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.OperationVariable` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return operation_variable_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def operation_variable_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.OperationVariable:
+    """
+    Read an instance of :py:class:`.types.OperationVariable` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.operation_variable_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.OperationVariable` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.OperationVariable` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return operation_variable_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def capability_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Capability:
+    """
+    Read an instance of :py:class:`.types.Capability` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.capability_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Capability` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Capability, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Capability, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_capability_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def capability_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Capability:
+    """
+    Read an instance of :py:class:`.types.Capability` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.capability_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Capability` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Capability` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return capability_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def capability_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Capability:
+    """
+    Read an instance of :py:class:`.types.Capability` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.capability_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Capability` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Capability` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return capability_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def capability_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Capability:
+    """
+    Read an instance of :py:class:`.types.Capability` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.capability_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Capability` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Capability` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return capability_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def concept_description_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ConceptDescription:
+    """
+    Read an instance of :py:class:`.types.ConceptDescription` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.concept_description_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ConceptDescription` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for ConceptDescription, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for ConceptDescription, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_concept_description_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def concept_description_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.ConceptDescription:
+    """
+    Read an instance of :py:class:`.types.ConceptDescription` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.concept_description_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.ConceptDescription` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ConceptDescription` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return concept_description_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def concept_description_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.ConceptDescription:
+    """
+    Read an instance of :py:class:`.types.ConceptDescription` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.concept_description_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.ConceptDescription` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ConceptDescription` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return concept_description_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def concept_description_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.ConceptDescription:
+    """
+    Read an instance of :py:class:`.types.ConceptDescription` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.concept_description_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.ConceptDescription` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ConceptDescription` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return concept_description_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def reference_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Reference:
+    """
+    Read an instance of :py:class:`.types.Reference` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.reference_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Reference` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Reference, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Reference, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_reference_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def reference_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Reference:
+    """
+    Read an instance of :py:class:`.types.Reference` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.reference_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Reference` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Reference` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return reference_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def reference_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Reference:
+    """
+    Read an instance of :py:class:`.types.Reference` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.reference_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Reference` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Reference` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return reference_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def reference_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Reference:
+    """
+    Read an instance of :py:class:`.types.Reference` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.reference_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Reference` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Reference` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return reference_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def key_from_iterparse(iterator: Iterator[Tuple[str, Element]]) -> aas_types.Key:
+    """
+    Read an instance of :py:class:`.types.Key` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.key_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Key` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Key, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Key, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_key_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def key_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Key:
+    """
+    Read an instance of :py:class:`.types.Key` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.key_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Key` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Key` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return key_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def key_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Key:
+    """
+    Read an instance of :py:class:`.types.Key` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.key_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Key` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Key` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return key_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def key_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Key:
+    """
+    Read an instance of :py:class:`.types.Key` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.key_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Key` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Key` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return key_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def abstract_lang_string_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AbstractLangString:
+    """
+    Read an instance of :py:class:`.types.AbstractLangString` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.abstract_lang_string_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AbstractLangString` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for AbstractLangString, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for AbstractLangString, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_abstract_lang_string_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def abstract_lang_string_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AbstractLangString:
+    """
+    Read an instance of :py:class:`.types.AbstractLangString` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.abstract_lang_string_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.AbstractLangString` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AbstractLangString` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return abstract_lang_string_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def abstract_lang_string_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AbstractLangString:
+    """
+    Read an instance of :py:class:`.types.AbstractLangString` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.abstract_lang_string_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.AbstractLangString` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AbstractLangString` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return abstract_lang_string_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def abstract_lang_string_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.AbstractLangString:
+    """
+    Read an instance of :py:class:`.types.AbstractLangString` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.abstract_lang_string_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.AbstractLangString` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.AbstractLangString` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return abstract_lang_string_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def lang_string_name_type_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringNameType:
+    """
+    Read an instance of :py:class:`.types.LangStringNameType` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.lang_string_name_type_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringNameType` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for LangStringNameType, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for LangStringNameType, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_lang_string_name_type_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def lang_string_name_type_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringNameType:
+    """
+    Read an instance of :py:class:`.types.LangStringNameType` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.lang_string_name_type_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.LangStringNameType` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringNameType` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return lang_string_name_type_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def lang_string_name_type_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringNameType:
+    """
+    Read an instance of :py:class:`.types.LangStringNameType` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.lang_string_name_type_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.LangStringNameType` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringNameType` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return lang_string_name_type_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def lang_string_name_type_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringNameType:
+    """
+    Read an instance of :py:class:`.types.LangStringNameType` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.lang_string_name_type_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.LangStringNameType` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringNameType` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return lang_string_name_type_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def lang_string_text_type_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringTextType:
+    """
+    Read an instance of :py:class:`.types.LangStringTextType` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.lang_string_text_type_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringTextType` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for LangStringTextType, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for LangStringTextType, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_lang_string_text_type_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def lang_string_text_type_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringTextType:
+    """
+    Read an instance of :py:class:`.types.LangStringTextType` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.lang_string_text_type_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.LangStringTextType` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringTextType` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return lang_string_text_type_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def lang_string_text_type_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringTextType:
+    """
+    Read an instance of :py:class:`.types.LangStringTextType` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.lang_string_text_type_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.LangStringTextType` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringTextType` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return lang_string_text_type_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def lang_string_text_type_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringTextType:
+    """
+    Read an instance of :py:class:`.types.LangStringTextType` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.lang_string_text_type_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.LangStringTextType` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringTextType` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return lang_string_text_type_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def environment_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Environment:
+    """
+    Read an instance of :py:class:`.types.Environment` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.environment_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Environment` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for Environment, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for Environment, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_environment_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def environment_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Environment:
+    """
+    Read an instance of :py:class:`.types.Environment` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.environment_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.Environment` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Environment` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return environment_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def environment_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Environment:
+    """
+    Read an instance of :py:class:`.types.Environment` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.environment_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.Environment` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Environment` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return environment_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def environment_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.Environment:
+    """
+    Read an instance of :py:class:`.types.Environment` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.environment_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.Environment` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.Environment` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return environment_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def data_specification_content_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.DataSpecificationContent:
+    """
+    Read an instance of :py:class:`.types.DataSpecificationContent` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.data_specification_content_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.DataSpecificationContent` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for DataSpecificationContent, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for DataSpecificationContent, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_data_specification_content_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def data_specification_content_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.DataSpecificationContent:
+    """
+    Read an instance of :py:class:`.types.DataSpecificationContent` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.data_specification_content_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.DataSpecificationContent` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.DataSpecificationContent` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return data_specification_content_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def data_specification_content_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.DataSpecificationContent:
+    """
+    Read an instance of :py:class:`.types.DataSpecificationContent` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.data_specification_content_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.DataSpecificationContent` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.DataSpecificationContent` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return data_specification_content_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def data_specification_content_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.DataSpecificationContent:
+    """
+    Read an instance of :py:class:`.types.DataSpecificationContent` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.data_specification_content_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.DataSpecificationContent` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.DataSpecificationContent` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return data_specification_content_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def embedded_data_specification_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.EmbeddedDataSpecification:
+    """
+    Read an instance of :py:class:`.types.EmbeddedDataSpecification` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.embedded_data_specification_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.EmbeddedDataSpecification` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for EmbeddedDataSpecification, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for EmbeddedDataSpecification, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_embedded_data_specification_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def embedded_data_specification_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.EmbeddedDataSpecification:
+    """
+    Read an instance of :py:class:`.types.EmbeddedDataSpecification` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.embedded_data_specification_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.EmbeddedDataSpecification` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.EmbeddedDataSpecification` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return embedded_data_specification_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def embedded_data_specification_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.EmbeddedDataSpecification:
+    """
+    Read an instance of :py:class:`.types.EmbeddedDataSpecification` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.embedded_data_specification_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.EmbeddedDataSpecification` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.EmbeddedDataSpecification` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return embedded_data_specification_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def embedded_data_specification_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.EmbeddedDataSpecification:
+    """
+    Read an instance of :py:class:`.types.EmbeddedDataSpecification` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.embedded_data_specification_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.EmbeddedDataSpecification` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.EmbeddedDataSpecification` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return embedded_data_specification_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def level_type_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LevelType:
+    """
+    Read an instance of :py:class:`.types.LevelType` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.level_type_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LevelType` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for LevelType, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for LevelType, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_level_type_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def level_type_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LevelType:
+    """
+    Read an instance of :py:class:`.types.LevelType` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.level_type_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.LevelType` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LevelType` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return level_type_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def level_type_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LevelType:
+    """
+    Read an instance of :py:class:`.types.LevelType` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.level_type_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.LevelType` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LevelType` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return level_type_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def level_type_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LevelType:
+    """
+    Read an instance of :py:class:`.types.LevelType` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.level_type_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.LevelType` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LevelType` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return level_type_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def value_reference_pair_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ValueReferencePair:
+    """
+    Read an instance of :py:class:`.types.ValueReferencePair` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.value_reference_pair_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ValueReferencePair` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for ValueReferencePair, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for ValueReferencePair, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_value_reference_pair_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def value_reference_pair_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.ValueReferencePair:
+    """
+    Read an instance of :py:class:`.types.ValueReferencePair` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.value_reference_pair_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.ValueReferencePair` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ValueReferencePair` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return value_reference_pair_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def value_reference_pair_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.ValueReferencePair:
+    """
+    Read an instance of :py:class:`.types.ValueReferencePair` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.value_reference_pair_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.ValueReferencePair` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ValueReferencePair` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return value_reference_pair_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def value_reference_pair_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.ValueReferencePair:
+    """
+    Read an instance of :py:class:`.types.ValueReferencePair` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.value_reference_pair_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.ValueReferencePair` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ValueReferencePair` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return value_reference_pair_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def value_list_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ValueList:
+    """
+    Read an instance of :py:class:`.types.ValueList` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.value_list_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ValueList` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for ValueList, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for ValueList, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_value_list_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def value_list_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.ValueList:
+    """
+    Read an instance of :py:class:`.types.ValueList` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.value_list_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.ValueList` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ValueList` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return value_list_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def value_list_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.ValueList:
+    """
+    Read an instance of :py:class:`.types.ValueList` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.value_list_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.ValueList` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ValueList` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return value_list_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def value_list_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.ValueList:
+    """
+    Read an instance of :py:class:`.types.ValueList` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.value_list_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.ValueList` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.ValueList` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return value_list_from_iterparse(_with_elements_cleared_after_yield(iterator))
+
+
+def lang_string_preferred_name_type_iec_61360_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringPreferredNameTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.lang_string_preferred_name_type_iec_61360_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for LangStringPreferredNameTypeIEC61360, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for LangStringPreferredNameTypeIEC61360, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_lang_string_preferred_name_type_iec_61360_as_element(
+            next_element, iterator
+        )
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def lang_string_preferred_name_type_iec_61360_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringPreferredNameTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.lang_string_preferred_name_type_iec_61360_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.LangStringPreferredNameTypeIEC61360` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return lang_string_preferred_name_type_iec_61360_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def lang_string_preferred_name_type_iec_61360_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringPreferredNameTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.lang_string_preferred_name_type_iec_61360_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.LangStringPreferredNameTypeIEC61360` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return lang_string_preferred_name_type_iec_61360_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def lang_string_preferred_name_type_iec_61360_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringPreferredNameTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.lang_string_preferred_name_type_iec_61360_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.LangStringPreferredNameTypeIEC61360` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return lang_string_preferred_name_type_iec_61360_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def lang_string_short_name_type_iec_61360_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringShortNameTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringShortNameTypeIEC61360` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.lang_string_short_name_type_iec_61360_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringShortNameTypeIEC61360` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for LangStringShortNameTypeIEC61360, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for LangStringShortNameTypeIEC61360, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_lang_string_short_name_type_iec_61360_as_element(
+            next_element, iterator
+        )
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def lang_string_short_name_type_iec_61360_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringShortNameTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringShortNameTypeIEC61360` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.lang_string_short_name_type_iec_61360_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.LangStringShortNameTypeIEC61360` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringShortNameTypeIEC61360` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return lang_string_short_name_type_iec_61360_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def lang_string_short_name_type_iec_61360_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringShortNameTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringShortNameTypeIEC61360` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.lang_string_short_name_type_iec_61360_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.LangStringShortNameTypeIEC61360` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringShortNameTypeIEC61360` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return lang_string_short_name_type_iec_61360_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def lang_string_short_name_type_iec_61360_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringShortNameTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringShortNameTypeIEC61360` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.lang_string_short_name_type_iec_61360_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.LangStringShortNameTypeIEC61360` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringShortNameTypeIEC61360` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return lang_string_short_name_type_iec_61360_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def lang_string_definition_type_iec_61360_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringDefinitionTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.lang_string_definition_type_iec_61360_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for LangStringDefinitionTypeIEC61360, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for LangStringDefinitionTypeIEC61360, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_lang_string_definition_type_iec_61360_as_element(
+            next_element, iterator
+        )
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def lang_string_definition_type_iec_61360_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringDefinitionTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.lang_string_definition_type_iec_61360_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.LangStringDefinitionTypeIEC61360` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return lang_string_definition_type_iec_61360_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def lang_string_definition_type_iec_61360_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringDefinitionTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.lang_string_definition_type_iec_61360_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.LangStringDefinitionTypeIEC61360` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return lang_string_definition_type_iec_61360_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def lang_string_definition_type_iec_61360_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.LangStringDefinitionTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.lang_string_definition_type_iec_61360_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.LangStringDefinitionTypeIEC61360` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return lang_string_definition_type_iec_61360_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def data_specification_iec_61360_from_iterparse(
+    iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.DataSpecificationIEC61360:
+    """
+    Read an instance of :py:class:`.types.DataSpecificationIEC61360` from
+    the :paramref:`iterator`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import xml.etree.ElementTree as ET
+
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        with path.open("rt") as fid:
+            iterator = ET.iterparse(
+                source=fid,
+                events=['start', 'end']
+            )
+            instance = aas_xmlization.data_specification_iec_61360_from_iterparse(
+                iterator
+            )
+
+        # Do something with the ``instance``
+
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.DataSpecificationIEC61360` read from
+        :paramref:`iterator`
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            # fmt: off
+            "Expected the start element for DataSpecificationIEC61360, "
+            "but got the end-of-input"
+            # fmt: on
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "start":
+        raise DeserializationException(
+            f"Expected the start element for DataSpecificationIEC61360, "
+            f"but got event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    try:
+        return _read_data_specification_iec_61360_as_element(next_element, iterator)
+    except DeserializationException as exception:
+        exception.path._prepend(ElementSegment(next_element))
+        raise exception
+
+
+def data_specification_iec_61360_from_stream(
+    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.DataSpecificationIEC61360:
+    """
+    Read an instance of :py:class:`.types.DataSpecificationIEC61360` from
+    the :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import aas_core3.xmlization as aas_xmlization
+
+        with open_some_stream_over_network(...) as stream:
+            instance = aas_xmlization.data_specification_iec_61360_from_stream(
+                stream
+            )
+
+        # Do something with the ``instance``
+
+    :param stream:
+        representing an instance of
+        :py:class:`.types.DataSpecificationIEC61360` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.DataSpecificationIEC61360` read from
+        :paramref:`stream`
+    """
+    iterator = has_iterparse.iterparse(stream, ["start", "end"])
+    return data_specification_iec_61360_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+def data_specification_iec_61360_from_file(
+    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.DataSpecificationIEC61360:
+    """
+    Read an instance of :py:class:`.types.DataSpecificationIEC61360` from
+    the :paramref:`path`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        path = pathlib.Path(...)
+        instance = aas_xmlization.data_specification_iec_61360_from_file(
+            path
+        )
+
+        # Do something with the ``instance``
+
+    :param path:
+        to the file representing an instance of
+        :py:class:`.types.DataSpecificationIEC61360` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.DataSpecificationIEC61360` read from
+        :paramref:`path`
+    """
+    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
+        iterator = has_iterparse.iterparse(fid, ["start", "end"])
+        return data_specification_iec_61360_from_iterparse(
+            _with_elements_cleared_after_yield(iterator)
+        )
+
+
+def data_specification_iec_61360_from_str(
+    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
+) -> aas_types.DataSpecificationIEC61360:
+    """
+    Read an instance of :py:class:`.types.DataSpecificationIEC61360` from
+    the :paramref:`text`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+        import aas_core3.xmlization as aas_xmlization
+
+        text = "<...>...</...>"
+        instance = aas_xmlization.data_specification_iec_61360_from_str(
+            text
+        )
+
+        # Do something with the ``instance``
+
+    :param text:
+        representing an instance of
+        :py:class:`.types.DataSpecificationIEC61360` in XML
+    :param has_iterparse:
+        Module containing ``iterparse`` function.
+
+        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
+        library. If you have to deal with malicious input, consider using
+        a library such as `defusedxml.ElementTree`_.
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return:
+        Instance of :py:class:`.types.DataSpecificationIEC61360` read from
+        :paramref:`text`
+    """
+    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
+    return data_specification_iec_61360_from_iterparse(
+        _with_elements_cleared_after_yield(iterator)
+    )
+
+
+# NOTE (mristin, 2022-10-08):
+# Directly using the iterator turned out to result in very complex function
+# designs. The design became much simpler as soon as we considered one look-ahead
+# element. We came up finally with the following pattern which all the protected
+# reading functions below roughly follow:
+#
+# ..code-block::
+#
+#    _read_*(
+#       look-ahead element,
+#       iterator
+#    ) -> result
+#
+# The reading functions all read from the ``iterator`` coming from
+# :py:func:`xml.etree.ElementTree.iterparse` with the argument
+# ``events=["start", "end"]``. The exception :py:class:`.DeserializationException`
+# is raised in case of unexpected input.
+#
+# The reading functions are responsible to read the end element corresponding to the
+# start look-ahead element.
+#
+# When it comes to error reporting, we use exceptions. The exceptions are raised in
+# the *callee*, as usual. However, the context of the exception, such as the error path,
+# is added in the *caller*, as only the caller knows the context of
+# the lookahead-element. In particular, prepending the path segment corresponding to
+# the lookahead-element is the responsibility of the *caller*, and not of
+# the *callee*.
+
+
+def _parse_element_tag(element: Element) -> str:
+    """
+    Extract the tag name without the namespace prefix from :paramref:`element`.
+
+    :param element: whose tag without namespace we want to extract
+    :return: tag name without the namespace prefix
+    :raise: :py:class:`DeserializationException` if unexpected :paramref:`element`
+    """
+    if not element.tag.startswith(_NAMESPACE_IN_CURLY_BRACKETS):
+        namespace, got_namespace, tag_wo_ns = element.tag.rpartition("}")
+        if got_namespace:
+            if namespace.startswith("{"):
+                namespace = namespace[1:]
+
+            raise DeserializationException(
+                f"Expected the element in the namespace {NAMESPACE!r}, "
+                f"but got the element {tag_wo_ns!r} in the namespace {namespace!r}"
+            )
+        else:
+            raise DeserializationException(
+                f"Expected the element in the namespace {NAMESPACE!r}, "
+                f"but got the element {tag_wo_ns!r} without the namespace prefix"
+            )
+
+    return element.tag[len(_NAMESPACE_IN_CURLY_BRACKETS) :]
+
+
+def _raise_if_has_tail_or_attrib(element: Element) -> None:
+    """
+    Check that :paramref:`element` has no trailing text and no attributes.
+
+    :param element: to be verified
+    :raise:
+        :py:class:`.DeserializationException` if trailing text or attributes;
+        conforming to the convention about handling error paths,
+        the exception path is left empty.
+    """
+    if element.tail is not None and len(element.tail.strip()) != 0:
+        raise DeserializationException(
+            f"Expected no trailing text, but got: {element.tail!r}"
+        )
+
+    if element.attrib is not None and len(element.attrib) > 0:
+        raise DeserializationException(
+            f"Expected no attributes, but got: {element.attrib}"
+        )
+
+
+def _read_end_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> None:
+    """
+    Read the end element corresponding to the start :paramref:`element`
+    from :paramref:`iterator`.
+
+    :param element: corresponding start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    """
+    next_event_element = next(iterator, None)
+    if next_event_element is None:
+        raise DeserializationException(
+            f"Expected the end element for {element.tag}, " f"but got the end-of-input"
+        )
+
+    next_event, next_element = next_event_element
+    if next_event != "end" or next_element.tag != element.tag:
+        raise DeserializationException(
+            f"Expected the end element for {element.tag!r}, "
+            f"but got the event {next_event!r} and element {next_element.tag!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(next_element)
+
+
+def _read_text_from_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> str:
+    """
+    Extract the text from the :paramref:`element`, and read
+    the end element from :paramref:`iterator`.
+
+    The :paramref:`element` is expected to contain text. Otherwise,
+    it is considered as unexpected input.
+
+    :param element: start element enclosing the text
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    """
+    _raise_if_has_tail_or_attrib(element)
+
+    if element.text is None:
+        raise DeserializationException(
+            "Expected an element with text, but got an element with no text."
+        )
+
+    text = element.text
+
+    _read_end_element(element, iterator)
+
+    return text
+
+
+_XS_BOOLEAN_LITERAL_SET = {
+    "1",
+    "true",
+    "0",
+    "false",
+}
+
+
+def _read_bool_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> bool:
+    """
+    Parse the text of :paramref:`element` as a boolean, and
+    read the corresponding end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    if text not in _XS_BOOLEAN_LITERAL_SET:
+        raise DeserializationException(
+            f"Expected a boolean, " f"but got an element with text: {text!r}"
+        )
+
+    return text in ("1", "true")
+
+
+def _read_int_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> int:
+    """
+    Parse the text of :paramref:`element` as an integer, and
+    read the corresponding end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    try:
+        value = int(text)
+    except ValueError:
+        # pylint: disable=raise-missing-from
+        raise DeserializationException(
+            f"Expected an integer, " f"but got an element with text: {text!r}"
+        )
+
+    return value
+
+
+_TEXT_TO_XS_DOUBLE_LITERALS = {
+    "NaN": math.nan,
+    "INF": math.inf,
+    "-INF": -math.inf,
+}
+
+
+def _read_float_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> float:
+    """
+    Parse the text of :paramref:`element` as a floating-point number, and
+    read the corresponding end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    value = _TEXT_TO_XS_DOUBLE_LITERALS.get(text, None)
+    if value is None:
+        try:
+            value = float(text)
+        except ValueError:
+            # pylint: disable=raise-missing-from
+            raise DeserializationException(
+                f"Expected a floating-point number, "
+                f"but got an element with text: {text!r}"
+            )
+
+    return value
+
+
+def _read_str_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> str:
+    """
+    Parse the text of :paramref:`element` as a string, and
+    read the corresponding end element from :paramref:`iterator`.
+
+    If there is no text, empty string is returned.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    # NOTE (mristin, 2022-10-26):
+    # We do not use ``_read_text_from_element`` as that function expects
+    # the ``element`` to contain *some* text. In contrast, this function
+    # can also deal with empty text, in which case it returns an empty string.
+
+    _raise_if_has_tail_or_attrib(element)
+    result = element.text if element.text is not None else ""
+
+    _read_end_element(element, iterator)
+
+    return result
+
+
+def _read_bytes_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> bytes:
+    """
+    Parse the text of :paramref:`element` as base64-encoded bytes, and
+    read the corresponding end element from :paramref:`iterator`.
+
+    :param element: look-ahead element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    try:
+        value = base64.b64decode(text)
+    except Exception:
+        # pylint: disable=raise-missing-from
+        raise DeserializationException(
+            f"Expected a text as base64-encoded bytes, "
+            f"but got an element with text: {text!r}"
+        )
+
+    return value
+
+
+def _read_has_semantics_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.HasSemantics:
+    """
+    Read an instance of :py:class:`.types.HasSemantics` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_HAS_SEMANTICS.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'HasSemantics', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForExtension:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Extension`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Extension`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.name: Optional[str] = None
+        self.value_type: Optional[aas_types.DataTypeDefXSD] = None
+        self.value: Optional[str] = None
+        self.refers_to: Optional[List[aas_types.Reference]] = None
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Extension.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Extension.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Extension.name` and set it.
+        """
+        self.name = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_value_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Extension.value_type` and set it.
+        """
+        self.value_type = _read_data_type_def_xsd_from_element_text(element, iterator)
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Extension.value` and set it.
+        """
+        self.value = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_refers_to(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Extension.refers_to` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.refers_to = result
+
+
+def _read_extension_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Extension:
+    """
+    Read an instance of :py:class:`.types.Extension`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForExtension()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_EXTENSION.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.name is None:
+        raise DeserializationException("The required property 'name' is missing")
+
+    return aas_types.Extension(
+        reader_and_setter.name,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.value_type,
+        reader_and_setter.value,
+        reader_and_setter.refers_to,
+    )
+
+
+def _read_extension_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Extension:
+    """
+    Read an instance of :py:class:`.types.Extension` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "extension":
+        raise DeserializationException(
+            f"Expected the element with the tag 'extension', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_extension_as_sequence(element, iterator)
+
+
+def _read_has_extensions_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.HasExtensions:
+    """
+    Read an instance of :py:class:`.types.HasExtensions` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_HAS_EXTENSIONS.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'HasExtensions', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+def _read_referable_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Referable:
+    """
+    Read an instance of :py:class:`.types.Referable` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_REFERABLE.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'Referable', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+def _read_identifiable_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Identifiable:
+    """
+    Read an instance of :py:class:`.types.Identifiable` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_IDENTIFIABLE.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'Identifiable', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+def _read_modelling_kind_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ModellingKind:
+    """
+    Parse the text of :paramref:`element` as a literal of
+    :py:class:`.types.ModellingKind`, and read the corresponding
+    end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    literal = aas_stringification.modelling_kind_from_str(text)
+    if literal is None:
+        raise DeserializationException(
+            f"Not a valid string representation of "
+            f"a literal of ModellingKind: {text}"
+        )
+
+    return literal
+
+
+def _read_has_kind_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.HasKind:
+    """
+    Read an instance of :py:class:`.types.HasKind` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_HAS_KIND.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'HasKind', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+def _read_has_data_specification_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.HasDataSpecification:
+    """
+    Read an instance of :py:class:`.types.HasDataSpecification` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_HAS_DATA_SPECIFICATION.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'HasDataSpecification', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForAdministrativeInformation:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`AdministrativeInformation`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`AdministrativeInformation`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.version: Optional[str] = None
+        self.revision: Optional[str] = None
+        self.creator: Optional[aas_types.Reference] = None
+        self.template_id: Optional[str] = None
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AdministrativeInformation.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_version(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AdministrativeInformation.version` and set it.
+        """
+        self.version = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_revision(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AdministrativeInformation.revision` and set it.
+        """
+        self.revision = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_creator(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AdministrativeInformation.creator` and set it.
+        """
+        self.creator = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_template_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AdministrativeInformation.template_id` and set it.
+        """
+        self.template_id = _read_str_from_element_text(element, iterator)
+
+
+def _read_administrative_information_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AdministrativeInformation:
+    """
+    Read an instance of :py:class:`.types.AdministrativeInformation`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForAdministrativeInformation()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_ADMINISTRATIVE_INFORMATION.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    return aas_types.AdministrativeInformation(
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.version,
+        reader_and_setter.revision,
+        reader_and_setter.creator,
+        reader_and_setter.template_id,
+    )
+
+
+def _read_administrative_information_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AdministrativeInformation:
+    """
+    Read an instance of :py:class:`.types.AdministrativeInformation` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "administrativeInformation":
+        raise DeserializationException(
+            f"Expected the element with the tag 'administrativeInformation', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_administrative_information_as_sequence(element, iterator)
+
+
+def _read_qualifiable_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Qualifiable:
+    """
+    Read an instance of :py:class:`.types.Qualifiable` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_QUALIFIABLE.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'Qualifiable', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+def _read_qualifier_kind_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.QualifierKind:
+    """
+    Parse the text of :paramref:`element` as a literal of
+    :py:class:`.types.QualifierKind`, and read the corresponding
+    end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    literal = aas_stringification.qualifier_kind_from_str(text)
+    if literal is None:
+        raise DeserializationException(
+            f"Not a valid string representation of "
+            f"a literal of QualifierKind: {text}"
+        )
+
+    return literal
+
+
+class _ReaderAndSetterForQualifier:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Qualifier`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Qualifier`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.kind: Optional[aas_types.QualifierKind] = None
+        self.type: Optional[str] = None
+        self.value_type: Optional[aas_types.DataTypeDefXSD] = None
+        self.value: Optional[str] = None
+        self.value_id: Optional[aas_types.Reference] = None
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Qualifier.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Qualifier.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_kind(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Qualifier.kind` and set it.
+        """
+        self.kind = _read_qualifier_kind_from_element_text(element, iterator)
+
+    def read_and_set_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Qualifier.type` and set it.
+        """
+        self.type = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_value_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Qualifier.value_type` and set it.
+        """
+        self.value_type = _read_data_type_def_xsd_from_element_text(element, iterator)
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Qualifier.value` and set it.
+        """
+        self.value = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_value_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Qualifier.value_id` and set it.
+        """
+        self.value_id = _read_reference_as_sequence(element, iterator)
+
+
+def _read_qualifier_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Qualifier:
+    """
+    Read an instance of :py:class:`.types.Qualifier`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForQualifier()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_QUALIFIER.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.type is None:
+        raise DeserializationException("The required property 'type' is missing")
+
+    if reader_and_setter.value_type is None:
+        raise DeserializationException("The required property 'valueType' is missing")
+
+    return aas_types.Qualifier(
+        reader_and_setter.type,
+        reader_and_setter.value_type,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.kind,
+        reader_and_setter.value,
+        reader_and_setter.value_id,
+    )
+
+
+def _read_qualifier_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Qualifier:
+    """
+    Read an instance of :py:class:`.types.Qualifier` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "qualifier":
+        raise DeserializationException(
+            f"Expected the element with the tag 'qualifier', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_qualifier_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForAssetAdministrationShell:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`AssetAdministrationShell`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`AssetAdministrationShell`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.administration: Optional[aas_types.AdministrativeInformation] = None
+        self.id: Optional[str] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.derived_from: Optional[aas_types.Reference] = None
+        self.asset_information: Optional[aas_types.AssetInformation] = None
+        self.submodels: Optional[List[aas_types.Reference]] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetAdministrationShell.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetAdministrationShell.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetAdministrationShell.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetAdministrationShell.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetAdministrationShell.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_administration(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetAdministrationShell.administration` and set it.
+        """
+        self.administration = _read_administrative_information_as_sequence(
+            element, iterator
+        )
+
+    def read_and_set_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetAdministrationShell.id` and set it.
+        """
+        self.id = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetAdministrationShell.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_derived_from(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetAdministrationShell.derived_from` and set it.
+        """
+        self.derived_from = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_asset_information(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetAdministrationShell.asset_information` and set it.
+        """
+        self.asset_information = _read_asset_information_as_sequence(element, iterator)
+
+    def read_and_set_submodels(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetAdministrationShell.submodels` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.submodels = result
+
+
+def _read_asset_administration_shell_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AssetAdministrationShell:
+    """
+    Read an instance of :py:class:`.types.AssetAdministrationShell`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForAssetAdministrationShell()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_ASSET_ADMINISTRATION_SHELL.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.id is None:
+        raise DeserializationException("The required property 'id' is missing")
+
+    if reader_and_setter.asset_information is None:
+        raise DeserializationException(
+            "The required property 'assetInformation' is missing"
+        )
+
+    return aas_types.AssetAdministrationShell(
+        reader_and_setter.id,
+        reader_and_setter.asset_information,
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.administration,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.derived_from,
+        reader_and_setter.submodels,
+    )
+
+
+def _read_asset_administration_shell_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AssetAdministrationShell:
+    """
+    Read an instance of :py:class:`.types.AssetAdministrationShell` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "assetAdministrationShell":
+        raise DeserializationException(
+            f"Expected the element with the tag 'assetAdministrationShell', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_asset_administration_shell_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForAssetInformation:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`AssetInformation`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`AssetInformation`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.asset_kind: Optional[aas_types.AssetKind] = None
+        self.global_asset_id: Optional[str] = None
+        self.specific_asset_ids: Optional[List[aas_types.SpecificAssetID]] = None
+        self.asset_type: Optional[str] = None
+        self.default_thumbnail: Optional[aas_types.Resource] = None
+
+    def read_and_set_asset_kind(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetInformation.asset_kind` and set it.
+        """
+        self.asset_kind = _read_asset_kind_from_element_text(element, iterator)
+
+    def read_and_set_global_asset_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetInformation.global_asset_id` and set it.
+        """
+        self.global_asset_id = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_specific_asset_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetInformation.specific_asset_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.SpecificAssetID] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_specific_asset_id_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.specific_asset_ids = result
+
+    def read_and_set_asset_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetInformation.asset_type` and set it.
+        """
+        self.asset_type = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_default_thumbnail(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AssetInformation.default_thumbnail` and set it.
+        """
+        self.default_thumbnail = _read_resource_as_sequence(element, iterator)
+
+
+def _read_asset_information_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AssetInformation:
+    """
+    Read an instance of :py:class:`.types.AssetInformation`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForAssetInformation()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_ASSET_INFORMATION.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.asset_kind is None:
+        raise DeserializationException("The required property 'assetKind' is missing")
+
+    return aas_types.AssetInformation(
+        reader_and_setter.asset_kind,
+        reader_and_setter.global_asset_id,
+        reader_and_setter.specific_asset_ids,
+        reader_and_setter.asset_type,
+        reader_and_setter.default_thumbnail,
+    )
+
+
+def _read_asset_information_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AssetInformation:
+    """
+    Read an instance of :py:class:`.types.AssetInformation` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "assetInformation":
+        raise DeserializationException(
+            f"Expected the element with the tag 'assetInformation', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_asset_information_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForResource:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Resource`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Resource`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.path: Optional[str] = None
+        self.content_type: Optional[str] = None
+
+    def read_and_set_path(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Resource.path` and set it.
+        """
+        self.path = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_content_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Resource.content_type` and set it.
+        """
+        self.content_type = _read_str_from_element_text(element, iterator)
+
+
+def _read_resource_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Resource:
+    """
+    Read an instance of :py:class:`.types.Resource`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForResource()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_RESOURCE.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.path is None:
+        raise DeserializationException("The required property 'path' is missing")
+
+    return aas_types.Resource(reader_and_setter.path, reader_and_setter.content_type)
+
+
+def _read_resource_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Resource:
+    """
+    Read an instance of :py:class:`.types.Resource` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "resource":
+        raise DeserializationException(
+            f"Expected the element with the tag 'resource', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_resource_as_sequence(element, iterator)
+
+
+def _read_asset_kind_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AssetKind:
+    """
+    Parse the text of :paramref:`element` as a literal of
+    :py:class:`.types.AssetKind`, and read the corresponding
+    end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    literal = aas_stringification.asset_kind_from_str(text)
+    if literal is None:
+        raise DeserializationException(
+            f"Not a valid string representation of " f"a literal of AssetKind: {text}"
+        )
+
+    return literal
+
+
+class _ReaderAndSetterForSpecificAssetID:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`SpecificAssetID`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`SpecificAssetID`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.name: Optional[str] = None
+        self.value: Optional[str] = None
+        self.external_subject_id: Optional[aas_types.Reference] = None
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SpecificAssetID.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SpecificAssetID.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SpecificAssetID.name` and set it.
+        """
+        self.name = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SpecificAssetID.value` and set it.
+        """
+        self.value = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_external_subject_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SpecificAssetID.external_subject_id` and set it.
+        """
+        self.external_subject_id = _read_reference_as_sequence(element, iterator)
+
+
+def _read_specific_asset_id_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.SpecificAssetID:
+    """
+    Read an instance of :py:class:`.types.SpecificAssetID`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForSpecificAssetID()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_SPECIFIC_ASSET_ID.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.name is None:
+        raise DeserializationException("The required property 'name' is missing")
+
+    if reader_and_setter.value is None:
+        raise DeserializationException("The required property 'value' is missing")
+
+    return aas_types.SpecificAssetID(
+        reader_and_setter.name,
+        reader_and_setter.value,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.external_subject_id,
+    )
+
+
+def _read_specific_asset_id_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.SpecificAssetID:
+    """
+    Read an instance of :py:class:`.types.SpecificAssetID` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "specificAssetId":
+        raise DeserializationException(
+            f"Expected the element with the tag 'specificAssetId', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_specific_asset_id_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForSubmodel:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Submodel`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Submodel`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.administration: Optional[aas_types.AdministrativeInformation] = None
+        self.id: Optional[str] = None
+        self.kind: Optional[aas_types.ModellingKind] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.submodel_elements: Optional[List[aas_types.SubmodelElement]] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_administration(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.administration` and set it.
+        """
+        self.administration = _read_administrative_information_as_sequence(
+            element, iterator
+        )
+
+    def read_and_set_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.id` and set it.
+        """
+        self.id = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_kind(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.kind` and set it.
+        """
+        self.kind = _read_modelling_kind_from_element_text(element, iterator)
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_submodel_elements(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Submodel.submodel_elements` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.SubmodelElement] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_submodel_element_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.submodel_elements = result
+
+
+def _read_submodel_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Submodel:
+    """
+    Read an instance of :py:class:`.types.Submodel`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForSubmodel()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_SUBMODEL.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.id is None:
+        raise DeserializationException("The required property 'id' is missing")
+
+    return aas_types.Submodel(
+        reader_and_setter.id,
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.administration,
+        reader_and_setter.kind,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.submodel_elements,
+    )
+
+
+def _read_submodel_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Submodel:
+    """
+    Read an instance of :py:class:`.types.Submodel` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "submodel":
+        raise DeserializationException(
+            f"Expected the element with the tag 'submodel', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_submodel_as_sequence(element, iterator)
+
+
+def _read_submodel_element_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.SubmodelElement:
+    """
+    Read an instance of :py:class:`.types.SubmodelElement` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_SUBMODEL_ELEMENT.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'SubmodelElement', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForRelationshipElement:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`RelationshipElement`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`RelationshipElement`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.first: Optional[aas_types.Reference] = None
+        self.second: Optional[aas_types.Reference] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.RelationshipElement.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.RelationshipElement.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.RelationshipElement.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.RelationshipElement.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.RelationshipElement.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.RelationshipElement.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.RelationshipElement.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.RelationshipElement.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.RelationshipElement.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_first(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.RelationshipElement.first` and set it.
+        """
+        self.first = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_second(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.RelationshipElement.second` and set it.
+        """
+        self.second = _read_reference_as_sequence(element, iterator)
+
+
+def _read_relationship_element_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.RelationshipElement:
+    """
+    Read an instance of :py:class:`.types.RelationshipElement`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForRelationshipElement()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_RELATIONSHIP_ELEMENT.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.first is None:
+        raise DeserializationException("The required property 'first' is missing")
+
+    if reader_and_setter.second is None:
+        raise DeserializationException("The required property 'second' is missing")
+
+    return aas_types.RelationshipElement(
+        reader_and_setter.first,
+        reader_and_setter.second,
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+    )
+
+
+def _read_relationship_element_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.RelationshipElement:
+    """
+    Read an instance of :py:class:`.types.RelationshipElement` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_RELATIONSHIP_ELEMENT.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'RelationshipElement', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+def _read_aas_submodel_elements_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AASSubmodelElements:
+    """
+    Parse the text of :paramref:`element` as a literal of
+    :py:class:`.types.AASSubmodelElements`, and read the corresponding
+    end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    literal = aas_stringification.aas_submodel_elements_from_str(text)
+    if literal is None:
+        raise DeserializationException(
+            f"Not a valid string representation of "
+            f"a literal of AASSubmodelElements: {text}"
+        )
+
+    return literal
+
+
+class _ReaderAndSetterForSubmodelElementList:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`SubmodelElementList`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`SubmodelElementList`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.order_relevant: Optional[bool] = None
+        self.semantic_id_list_element: Optional[aas_types.Reference] = None
+        self.type_value_list_element: Optional[aas_types.AASSubmodelElements] = None
+        self.value_type_list_element: Optional[aas_types.DataTypeDefXSD] = None
+        self.value: Optional[List[aas_types.SubmodelElement]] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_order_relevant(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.order_relevant` and set it.
+        """
+        self.order_relevant = _read_bool_from_element_text(element, iterator)
+
+    def read_and_set_semantic_id_list_element(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.semantic_id_list_element` and set it.
+        """
+        self.semantic_id_list_element = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_type_value_list_element(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.type_value_list_element` and set it.
+        """
+        self.type_value_list_element = _read_aas_submodel_elements_from_element_text(
+            element, iterator
+        )
+
+    def read_and_set_value_type_list_element(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.value_type_list_element` and set it.
+        """
+        self.value_type_list_element = _read_data_type_def_xsd_from_element_text(
+            element, iterator
+        )
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementList.value` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.SubmodelElement] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_submodel_element_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.value = result
+
+
+def _read_submodel_element_list_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.SubmodelElementList:
+    """
+    Read an instance of :py:class:`.types.SubmodelElementList`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForSubmodelElementList()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_SUBMODEL_ELEMENT_LIST.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.type_value_list_element is None:
+        raise DeserializationException(
+            "The required property 'typeValueListElement' is missing"
+        )
+
+    return aas_types.SubmodelElementList(
+        reader_and_setter.type_value_list_element,
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.order_relevant,
+        reader_and_setter.semantic_id_list_element,
+        reader_and_setter.value_type_list_element,
+        reader_and_setter.value,
+    )
+
+
+def _read_submodel_element_list_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.SubmodelElementList:
+    """
+    Read an instance of :py:class:`.types.SubmodelElementList` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "submodelElementList":
+        raise DeserializationException(
+            f"Expected the element with the tag 'submodelElementList', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_submodel_element_list_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForSubmodelElementCollection:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`SubmodelElementCollection`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`SubmodelElementCollection`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.value: Optional[List[aas_types.SubmodelElement]] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementCollection.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementCollection.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementCollection.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementCollection.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementCollection.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementCollection.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementCollection.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementCollection.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementCollection.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.SubmodelElementCollection.value` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.SubmodelElement] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_submodel_element_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.value = result
+
+
+def _read_submodel_element_collection_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.SubmodelElementCollection:
+    """
+    Read an instance of :py:class:`.types.SubmodelElementCollection`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForSubmodelElementCollection()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = (
+            _READ_AND_SET_DISPATCH_FOR_SUBMODEL_ELEMENT_COLLECTION.get(tag_wo_ns, None)
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    return aas_types.SubmodelElementCollection(
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.value,
+    )
+
+
+def _read_submodel_element_collection_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.SubmodelElementCollection:
+    """
+    Read an instance of :py:class:`.types.SubmodelElementCollection` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "submodelElementCollection":
+        raise DeserializationException(
+            f"Expected the element with the tag 'submodelElementCollection', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_submodel_element_collection_as_sequence(element, iterator)
+
+
+def _read_data_element_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.DataElement:
+    """
+    Read an instance of :py:class:`.types.DataElement` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_DATA_ELEMENT.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'DataElement', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForProperty:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Property`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Property`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.value_type: Optional[aas_types.DataTypeDefXSD] = None
+        self.value: Optional[str] = None
+        self.value_id: Optional[aas_types.Reference] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Property.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Property.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Property.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Property.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Property.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Property.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Property.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Property.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Property.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_value_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Property.value_type` and set it.
+        """
+        self.value_type = _read_data_type_def_xsd_from_element_text(element, iterator)
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Property.value` and set it.
+        """
+        self.value = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_value_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Property.value_id` and set it.
+        """
+        self.value_id = _read_reference_as_sequence(element, iterator)
+
+
+def _read_property_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Property:
+    """
+    Read an instance of :py:class:`.types.Property`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForProperty()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_PROPERTY.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.value_type is None:
+        raise DeserializationException("The required property 'valueType' is missing")
+
+    return aas_types.Property(
+        reader_and_setter.value_type,
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.value,
+        reader_and_setter.value_id,
+    )
+
+
+def _read_property_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Property:
+    """
+    Read an instance of :py:class:`.types.Property` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "property":
+        raise DeserializationException(
+            f"Expected the element with the tag 'property', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_property_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForMultiLanguageProperty:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`MultiLanguageProperty`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`MultiLanguageProperty`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.value: Optional[List[aas_types.LangStringTextType]] = None
+        self.value_id: Optional[aas_types.Reference] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.MultiLanguageProperty.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.MultiLanguageProperty.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.MultiLanguageProperty.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.MultiLanguageProperty.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.MultiLanguageProperty.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.MultiLanguageProperty.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.MultiLanguageProperty.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.MultiLanguageProperty.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.MultiLanguageProperty.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.MultiLanguageProperty.value` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.value = result
+
+    def read_and_set_value_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.MultiLanguageProperty.value_id` and set it.
+        """
+        self.value_id = _read_reference_as_sequence(element, iterator)
+
+
+def _read_multi_language_property_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.MultiLanguageProperty:
+    """
+    Read an instance of :py:class:`.types.MultiLanguageProperty`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForMultiLanguageProperty()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_MULTI_LANGUAGE_PROPERTY.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    return aas_types.MultiLanguageProperty(
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.value,
+        reader_and_setter.value_id,
+    )
+
+
+def _read_multi_language_property_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.MultiLanguageProperty:
+    """
+    Read an instance of :py:class:`.types.MultiLanguageProperty` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "multiLanguageProperty":
+        raise DeserializationException(
+            f"Expected the element with the tag 'multiLanguageProperty', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_multi_language_property_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForRange:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Range`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Range`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.value_type: Optional[aas_types.DataTypeDefXSD] = None
+        self.min: Optional[str] = None
+        self.max: Optional[str] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Range.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Range.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Range.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Range.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Range.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Range.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Range.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Range.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Range.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_value_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Range.value_type` and set it.
+        """
+        self.value_type = _read_data_type_def_xsd_from_element_text(element, iterator)
+
+    def read_and_set_min(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Range.min` and set it.
+        """
+        self.min = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_max(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Range.max` and set it.
+        """
+        self.max = _read_str_from_element_text(element, iterator)
+
+
+def _read_range_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Range:
+    """
+    Read an instance of :py:class:`.types.Range`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForRange()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_RANGE.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.value_type is None:
+        raise DeserializationException("The required property 'valueType' is missing")
+
+    return aas_types.Range(
+        reader_and_setter.value_type,
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.min,
+        reader_and_setter.max,
+    )
+
+
+def _read_range_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Range:
+    """
+    Read an instance of :py:class:`.types.Range` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "range":
+        raise DeserializationException(
+            f"Expected the element with the tag 'range', " f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_range_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForReferenceElement:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`ReferenceElement`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`ReferenceElement`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.value: Optional[aas_types.Reference] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ReferenceElement.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ReferenceElement.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ReferenceElement.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ReferenceElement.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ReferenceElement.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ReferenceElement.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ReferenceElement.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ReferenceElement.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ReferenceElement.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ReferenceElement.value` and set it.
+        """
+        self.value = _read_reference_as_sequence(element, iterator)
+
+
+def _read_reference_element_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ReferenceElement:
+    """
+    Read an instance of :py:class:`.types.ReferenceElement`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForReferenceElement()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_REFERENCE_ELEMENT.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    return aas_types.ReferenceElement(
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.value,
+    )
+
+
+def _read_reference_element_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ReferenceElement:
+    """
+    Read an instance of :py:class:`.types.ReferenceElement` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "referenceElement":
+        raise DeserializationException(
+            f"Expected the element with the tag 'referenceElement', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_reference_element_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForBlob:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Blob`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Blob`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.value: Optional[bytes] = None
+        self.content_type: Optional[str] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Blob.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Blob.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Blob.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Blob.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Blob.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Blob.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Blob.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Blob.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Blob.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Blob.value` and set it.
+        """
+        self.value = _read_bytes_from_element_text(element, iterator)
+
+    def read_and_set_content_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Blob.content_type` and set it.
+        """
+        self.content_type = _read_str_from_element_text(element, iterator)
+
+
+def _read_blob_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Blob:
+    """
+    Read an instance of :py:class:`.types.Blob`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForBlob()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_BLOB.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.content_type is None:
+        raise DeserializationException("The required property 'contentType' is missing")
+
+    return aas_types.Blob(
+        reader_and_setter.content_type,
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.value,
+    )
+
+
+def _read_blob_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Blob:
+    """
+    Read an instance of :py:class:`.types.Blob` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "blob":
+        raise DeserializationException(
+            f"Expected the element with the tag 'blob', " f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_blob_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForFile:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`File`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`File`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.value: Optional[str] = None
+        self.content_type: Optional[str] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.File.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.File.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.File.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.File.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.File.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.File.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.File.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.File.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.File.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.File.value` and set it.
+        """
+        self.value = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_content_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.File.content_type` and set it.
+        """
+        self.content_type = _read_str_from_element_text(element, iterator)
+
+
+def _read_file_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.File:
+    """
+    Read an instance of :py:class:`.types.File`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForFile()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_FILE.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.content_type is None:
+        raise DeserializationException("The required property 'contentType' is missing")
+
+    return aas_types.File(
+        reader_and_setter.content_type,
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.value,
+    )
+
+
+def _read_file_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.File:
+    """
+    Read an instance of :py:class:`.types.File` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "file":
+        raise DeserializationException(
+            f"Expected the element with the tag 'file', " f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_file_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForAnnotatedRelationshipElement:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`AnnotatedRelationshipElement`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`AnnotatedRelationshipElement`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.first: Optional[aas_types.Reference] = None
+        self.second: Optional[aas_types.Reference] = None
+        self.annotations: Optional[List[aas_types.DataElement]] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AnnotatedRelationshipElement.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AnnotatedRelationshipElement.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AnnotatedRelationshipElement.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AnnotatedRelationshipElement.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AnnotatedRelationshipElement.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AnnotatedRelationshipElement.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AnnotatedRelationshipElement.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AnnotatedRelationshipElement.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AnnotatedRelationshipElement.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_first(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AnnotatedRelationshipElement.first` and set it.
+        """
+        self.first = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_second(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AnnotatedRelationshipElement.second` and set it.
+        """
+        self.second = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_annotations(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.AnnotatedRelationshipElement.annotations` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.DataElement] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_data_element_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.annotations = result
+
+
+def _read_annotated_relationship_element_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AnnotatedRelationshipElement:
+    """
+    Read an instance of :py:class:`.types.AnnotatedRelationshipElement`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForAnnotatedRelationshipElement()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = (
+            _READ_AND_SET_DISPATCH_FOR_ANNOTATED_RELATIONSHIP_ELEMENT.get(
+                tag_wo_ns, None
+            )
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.first is None:
+        raise DeserializationException("The required property 'first' is missing")
+
+    if reader_and_setter.second is None:
+        raise DeserializationException("The required property 'second' is missing")
+
+    return aas_types.AnnotatedRelationshipElement(
+        reader_and_setter.first,
+        reader_and_setter.second,
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.annotations,
+    )
+
+
+def _read_annotated_relationship_element_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AnnotatedRelationshipElement:
+    """
+    Read an instance of :py:class:`.types.AnnotatedRelationshipElement` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "annotatedRelationshipElement":
+        raise DeserializationException(
+            f"Expected the element with the tag 'annotatedRelationshipElement', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_annotated_relationship_element_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForEntity:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Entity`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Entity`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.statements: Optional[List[aas_types.SubmodelElement]] = None
+        self.entity_type: Optional[aas_types.EntityType] = None
+        self.global_asset_id: Optional[str] = None
+        self.specific_asset_ids: Optional[List[aas_types.SpecificAssetID]] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_statements(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.statements` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.SubmodelElement] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_submodel_element_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.statements = result
+
+    def read_and_set_entity_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.entity_type` and set it.
+        """
+        self.entity_type = _read_entity_type_from_element_text(element, iterator)
+
+    def read_and_set_global_asset_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.global_asset_id` and set it.
+        """
+        self.global_asset_id = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_specific_asset_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Entity.specific_asset_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.SpecificAssetID] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_specific_asset_id_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.specific_asset_ids = result
+
+
+def _read_entity_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Entity:
+    """
+    Read an instance of :py:class:`.types.Entity`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForEntity()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_ENTITY.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.entity_type is None:
+        raise DeserializationException("The required property 'entityType' is missing")
+
+    return aas_types.Entity(
+        reader_and_setter.entity_type,
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.statements,
+        reader_and_setter.global_asset_id,
+        reader_and_setter.specific_asset_ids,
+    )
+
+
+def _read_entity_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Entity:
+    """
+    Read an instance of :py:class:`.types.Entity` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "entity":
+        raise DeserializationException(
+            f"Expected the element with the tag 'entity', " f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_entity_as_sequence(element, iterator)
+
+
+def _read_entity_type_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.EntityType:
+    """
+    Parse the text of :paramref:`element` as a literal of
+    :py:class:`.types.EntityType`, and read the corresponding
+    end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    literal = aas_stringification.entity_type_from_str(text)
+    if literal is None:
+        raise DeserializationException(
+            f"Not a valid string representation of " f"a literal of EntityType: {text}"
+        )
+
+    return literal
+
+
+def _read_direction_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Direction:
+    """
+    Parse the text of :paramref:`element` as a literal of
+    :py:class:`.types.Direction`, and read the corresponding
+    end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    literal = aas_stringification.direction_from_str(text)
+    if literal is None:
+        raise DeserializationException(
+            f"Not a valid string representation of " f"a literal of Direction: {text}"
+        )
+
+    return literal
+
+
+def _read_state_of_event_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.StateOfEvent:
+    """
+    Parse the text of :paramref:`element` as a literal of
+    :py:class:`.types.StateOfEvent`, and read the corresponding
+    end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    literal = aas_stringification.state_of_event_from_str(text)
+    if literal is None:
+        raise DeserializationException(
+            f"Not a valid string representation of "
+            f"a literal of StateOfEvent: {text}"
+        )
+
+    return literal
+
+
+class _ReaderAndSetterForEventPayload:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`EventPayload`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`EventPayload`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.source: Optional[aas_types.Reference] = None
+        self.source_semantic_id: Optional[aas_types.Reference] = None
+        self.observable_reference: Optional[aas_types.Reference] = None
+        self.observable_semantic_id: Optional[aas_types.Reference] = None
+        self.topic: Optional[str] = None
+        self.subject_id: Optional[aas_types.Reference] = None
+        self.time_stamp: Optional[str] = None
+        self.payload: Optional[bytes] = None
+
+    def read_and_set_source(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.EventPayload.source` and set it.
+        """
+        self.source = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_source_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.EventPayload.source_semantic_id` and set it.
+        """
+        self.source_semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_observable_reference(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.EventPayload.observable_reference` and set it.
+        """
+        self.observable_reference = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_observable_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.EventPayload.observable_semantic_id` and set it.
+        """
+        self.observable_semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_topic(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.EventPayload.topic` and set it.
+        """
+        self.topic = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_subject_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.EventPayload.subject_id` and set it.
+        """
+        self.subject_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_time_stamp(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.EventPayload.time_stamp` and set it.
+        """
+        self.time_stamp = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_payload(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.EventPayload.payload` and set it.
+        """
+        self.payload = _read_bytes_from_element_text(element, iterator)
+
+
+def _read_event_payload_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.EventPayload:
+    """
+    Read an instance of :py:class:`.types.EventPayload`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForEventPayload()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_EVENT_PAYLOAD.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.source is None:
+        raise DeserializationException("The required property 'source' is missing")
+
+    if reader_and_setter.observable_reference is None:
+        raise DeserializationException(
+            "The required property 'observableReference' is missing"
+        )
+
+    if reader_and_setter.time_stamp is None:
+        raise DeserializationException("The required property 'timeStamp' is missing")
+
+    return aas_types.EventPayload(
+        reader_and_setter.source,
+        reader_and_setter.observable_reference,
+        reader_and_setter.time_stamp,
+        reader_and_setter.source_semantic_id,
+        reader_and_setter.observable_semantic_id,
+        reader_and_setter.topic,
+        reader_and_setter.subject_id,
+        reader_and_setter.payload,
+    )
+
+
+def _read_event_payload_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.EventPayload:
+    """
+    Read an instance of :py:class:`.types.EventPayload` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "eventPayload":
+        raise DeserializationException(
+            f"Expected the element with the tag 'eventPayload', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_event_payload_as_sequence(element, iterator)
+
+
+def _read_event_element_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.EventElement:
+    """
+    Read an instance of :py:class:`.types.EventElement` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_EVENT_ELEMENT.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'EventElement', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForBasicEventElement:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`BasicEventElement`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`BasicEventElement`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.observed: Optional[aas_types.Reference] = None
+        self.direction: Optional[aas_types.Direction] = None
+        self.state: Optional[aas_types.StateOfEvent] = None
+        self.message_topic: Optional[str] = None
+        self.message_broker: Optional[aas_types.Reference] = None
+        self.last_update: Optional[str] = None
+        self.min_interval: Optional[str] = None
+        self.max_interval: Optional[str] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_observed(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.observed` and set it.
+        """
+        self.observed = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_direction(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.direction` and set it.
+        """
+        self.direction = _read_direction_from_element_text(element, iterator)
+
+    def read_and_set_state(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.state` and set it.
+        """
+        self.state = _read_state_of_event_from_element_text(element, iterator)
+
+    def read_and_set_message_topic(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.message_topic` and set it.
+        """
+        self.message_topic = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_message_broker(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.message_broker` and set it.
+        """
+        self.message_broker = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_last_update(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.last_update` and set it.
+        """
+        self.last_update = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_min_interval(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.min_interval` and set it.
+        """
+        self.min_interval = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_max_interval(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.BasicEventElement.max_interval` and set it.
+        """
+        self.max_interval = _read_str_from_element_text(element, iterator)
+
+
+def _read_basic_event_element_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.BasicEventElement:
+    """
+    Read an instance of :py:class:`.types.BasicEventElement`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForBasicEventElement()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_BASIC_EVENT_ELEMENT.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.observed is None:
+        raise DeserializationException("The required property 'observed' is missing")
+
+    if reader_and_setter.direction is None:
+        raise DeserializationException("The required property 'direction' is missing")
+
+    if reader_and_setter.state is None:
+        raise DeserializationException("The required property 'state' is missing")
+
+    return aas_types.BasicEventElement(
+        reader_and_setter.observed,
+        reader_and_setter.direction,
+        reader_and_setter.state,
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.message_topic,
+        reader_and_setter.message_broker,
+        reader_and_setter.last_update,
+        reader_and_setter.min_interval,
+        reader_and_setter.max_interval,
+    )
+
+
+def _read_basic_event_element_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.BasicEventElement:
+    """
+    Read an instance of :py:class:`.types.BasicEventElement` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "basicEventElement":
+        raise DeserializationException(
+            f"Expected the element with the tag 'basicEventElement', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_basic_event_element_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForOperation:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Operation`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Operation`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.input_variables: Optional[List[aas_types.OperationVariable]] = None
+        self.output_variables: Optional[List[aas_types.OperationVariable]] = None
+        self.inoutput_variables: Optional[List[aas_types.OperationVariable]] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Operation.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Operation.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Operation.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Operation.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Operation.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Operation.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Operation.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Operation.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Operation.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_input_variables(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Operation.input_variables` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.OperationVariable] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_operation_variable_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.input_variables = result
+
+    def read_and_set_output_variables(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Operation.output_variables` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.OperationVariable] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_operation_variable_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.output_variables = result
+
+    def read_and_set_inoutput_variables(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Operation.inoutput_variables` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.OperationVariable] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_operation_variable_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.inoutput_variables = result
+
+
+def _read_operation_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Operation:
+    """
+    Read an instance of :py:class:`.types.Operation`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForOperation()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_OPERATION.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    return aas_types.Operation(
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.input_variables,
+        reader_and_setter.output_variables,
+        reader_and_setter.inoutput_variables,
+    )
+
+
+def _read_operation_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Operation:
+    """
+    Read an instance of :py:class:`.types.Operation` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "operation":
+        raise DeserializationException(
+            f"Expected the element with the tag 'operation', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_operation_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForOperationVariable:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`OperationVariable`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`OperationVariable`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.value: Optional[aas_types.SubmodelElement] = None
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.OperationVariable.value` and set it.
+        """
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected a discriminator start element corresponding "
+                "to SubmodelElement, but got end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event != "start":
+            raise DeserializationException(
+                f"Expected a discriminator start element corresponding "
+                f"to SubmodelElement, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            result = _read_submodel_element_as_element(next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        _read_end_element(element, iterator)
+
+        self.value = result
+
+
+def _read_operation_variable_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.OperationVariable:
+    """
+    Read an instance of :py:class:`.types.OperationVariable`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForOperationVariable()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_OPERATION_VARIABLE.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.value is None:
+        raise DeserializationException("The required property 'value' is missing")
+
+    return aas_types.OperationVariable(reader_and_setter.value)
+
+
+def _read_operation_variable_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.OperationVariable:
+    """
+    Read an instance of :py:class:`.types.OperationVariable` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "operationVariable":
+        raise DeserializationException(
+            f"Expected the element with the tag 'operationVariable', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_operation_variable_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForCapability:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Capability`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Capability`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.semantic_id: Optional[aas_types.Reference] = None
+        self.supplemental_semantic_ids: Optional[List[aas_types.Reference]] = None
+        self.qualifiers: Optional[List[aas_types.Qualifier]] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Capability.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Capability.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Capability.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Capability.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Capability.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Capability.semantic_id` and set it.
+        """
+        self.semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_supplemental_semantic_ids(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Capability.supplemental_semantic_ids` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.supplemental_semantic_ids = result
+
+    def read_and_set_qualifiers(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Capability.qualifiers` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Qualifier] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_qualifier_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.qualifiers = result
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Capability.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+
+def _read_capability_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Capability:
+    """
+    Read an instance of :py:class:`.types.Capability`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForCapability()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_CAPABILITY.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    return aas_types.Capability(
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.semantic_id,
+        reader_and_setter.supplemental_semantic_ids,
+        reader_and_setter.qualifiers,
+        reader_and_setter.embedded_data_specifications,
+    )
+
+
+def _read_capability_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Capability:
+    """
+    Read an instance of :py:class:`.types.Capability` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "capability":
+        raise DeserializationException(
+            f"Expected the element with the tag 'capability', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_capability_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForConceptDescription:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`ConceptDescription`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`ConceptDescription`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.extensions: Optional[List[aas_types.Extension]] = None
+        self.category: Optional[str] = None
+        self.id_short: Optional[str] = None
+        self.display_name: Optional[List[aas_types.LangStringNameType]] = None
+        self.description: Optional[List[aas_types.LangStringTextType]] = None
+        self.administration: Optional[aas_types.AdministrativeInformation] = None
+        self.id: Optional[str] = None
+        self.embedded_data_specifications: Optional[
+            List[aas_types.EmbeddedDataSpecification]
+        ] = None
+        self.is_case_of: Optional[List[aas_types.Reference]] = None
+
+    def read_and_set_extensions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ConceptDescription.extensions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Extension] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_extension_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.extensions = result
+
+    def read_and_set_category(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ConceptDescription.category` and set it.
+        """
+        self.category = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_id_short(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ConceptDescription.id_short` and set it.
+        """
+        self.id_short = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_display_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ConceptDescription.display_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringNameType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_name_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.display_name = result
+
+    def read_and_set_description(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ConceptDescription.description` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringTextType] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_text_type_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.description = result
+
+    def read_and_set_administration(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ConceptDescription.administration` and set it.
+        """
+        self.administration = _read_administrative_information_as_sequence(
+            element, iterator
+        )
+
+    def read_and_set_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ConceptDescription.id` and set it.
+        """
+        self.id = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_embedded_data_specifications(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ConceptDescription.embedded_data_specifications` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.EmbeddedDataSpecification] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_embedded_data_specification_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.embedded_data_specifications = result
+
+    def read_and_set_is_case_of(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ConceptDescription.is_case_of` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Reference] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_reference_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.is_case_of = result
+
+
+def _read_concept_description_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ConceptDescription:
+    """
+    Read an instance of :py:class:`.types.ConceptDescription`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForConceptDescription()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_CONCEPT_DESCRIPTION.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.id is None:
+        raise DeserializationException("The required property 'id' is missing")
+
+    return aas_types.ConceptDescription(
+        reader_and_setter.id,
+        reader_and_setter.extensions,
+        reader_and_setter.category,
+        reader_and_setter.id_short,
+        reader_and_setter.display_name,
+        reader_and_setter.description,
+        reader_and_setter.administration,
+        reader_and_setter.embedded_data_specifications,
+        reader_and_setter.is_case_of,
+    )
+
+
+def _read_concept_description_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ConceptDescription:
+    """
+    Read an instance of :py:class:`.types.ConceptDescription` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "conceptDescription":
+        raise DeserializationException(
+            f"Expected the element with the tag 'conceptDescription', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_concept_description_as_sequence(element, iterator)
+
+
+def _read_reference_types_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ReferenceTypes:
+    """
+    Parse the text of :paramref:`element` as a literal of
+    :py:class:`.types.ReferenceTypes`, and read the corresponding
+    end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    literal = aas_stringification.reference_types_from_str(text)
+    if literal is None:
+        raise DeserializationException(
+            f"Not a valid string representation of "
+            f"a literal of ReferenceTypes: {text}"
+        )
+
+    return literal
+
+
+class _ReaderAndSetterForReference:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Reference`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Reference`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.type: Optional[aas_types.ReferenceTypes] = None
+        self.referred_semantic_id: Optional[aas_types.Reference] = None
+        self.keys: Optional[List[aas_types.Key]] = None
+
+    def read_and_set_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Reference.type` and set it.
+        """
+        self.type = _read_reference_types_from_element_text(element, iterator)
+
+    def read_and_set_referred_semantic_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Reference.referred_semantic_id` and set it.
+        """
+        self.referred_semantic_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_keys(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Reference.keys` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Key] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_key_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.keys = result
+
+
+def _read_reference_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Reference:
+    """
+    Read an instance of :py:class:`.types.Reference`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForReference()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_REFERENCE.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.type is None:
+        raise DeserializationException("The required property 'type' is missing")
+
+    if reader_and_setter.keys is None:
+        raise DeserializationException("The required property 'keys' is missing")
+
+    return aas_types.Reference(
+        reader_and_setter.type,
+        reader_and_setter.keys,
+        reader_and_setter.referred_semantic_id,
+    )
+
+
+def _read_reference_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Reference:
+    """
+    Read an instance of :py:class:`.types.Reference` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "reference":
+        raise DeserializationException(
+            f"Expected the element with the tag 'reference', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_reference_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForKey:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Key`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Key`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.type: Optional[aas_types.KeyTypes] = None
+        self.value: Optional[str] = None
+
+    def read_and_set_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Key.type` and set it.
+        """
+        self.type = _read_key_types_from_element_text(element, iterator)
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Key.value` and set it.
+        """
+        self.value = _read_str_from_element_text(element, iterator)
+
+
+def _read_key_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Key:
+    """
+    Read an instance of :py:class:`.types.Key`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForKey()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_KEY.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.type is None:
+        raise DeserializationException("The required property 'type' is missing")
+
+    if reader_and_setter.value is None:
+        raise DeserializationException("The required property 'value' is missing")
+
+    return aas_types.Key(reader_and_setter.type, reader_and_setter.value)
+
+
+def _read_key_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Key:
+    """
+    Read an instance of :py:class:`.types.Key` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "key":
+        raise DeserializationException(
+            f"Expected the element with the tag 'key', " f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_key_as_sequence(element, iterator)
+
+
+def _read_key_types_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.KeyTypes:
+    """
+    Parse the text of :paramref:`element` as a literal of
+    :py:class:`.types.KeyTypes`, and read the corresponding
+    end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    literal = aas_stringification.key_types_from_str(text)
+    if literal is None:
+        raise DeserializationException(
+            f"Not a valid string representation of " f"a literal of KeyTypes: {text}"
+        )
+
+    return literal
+
+
+def _read_data_type_def_xsd_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.DataTypeDefXSD:
+    """
+    Parse the text of :paramref:`element` as a literal of
+    :py:class:`.types.DataTypeDefXSD`, and read the corresponding
+    end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    literal = aas_stringification.data_type_def_xsd_from_str(text)
+    if literal is None:
+        raise DeserializationException(
+            f"Not a valid string representation of "
+            f"a literal of DataTypeDefXSD: {text}"
+        )
+
+    return literal
+
+
+def _read_abstract_lang_string_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.AbstractLangString:
+    """
+    Read an instance of :py:class:`.types.AbstractLangString` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_ABSTRACT_LANG_STRING.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'AbstractLangString', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForLangStringNameType:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`LangStringNameType`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`LangStringNameType`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.language: Optional[str] = None
+        self.text: Optional[str] = None
+
+    def read_and_set_language(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LangStringNameType.language` and set it.
+        """
+        self.language = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_text(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LangStringNameType.text` and set it.
+        """
+        self.text = _read_str_from_element_text(element, iterator)
+
+
+def _read_lang_string_name_type_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringNameType:
+    """
+    Read an instance of :py:class:`.types.LangStringNameType`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForLangStringNameType()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_LANG_STRING_NAME_TYPE.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.language is None:
+        raise DeserializationException("The required property 'language' is missing")
+
+    if reader_and_setter.text is None:
+        raise DeserializationException("The required property 'text' is missing")
+
+    return aas_types.LangStringNameType(
+        reader_and_setter.language, reader_and_setter.text
+    )
+
+
+def _read_lang_string_name_type_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringNameType:
+    """
+    Read an instance of :py:class:`.types.LangStringNameType` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "langStringNameType":
+        raise DeserializationException(
+            f"Expected the element with the tag 'langStringNameType', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_lang_string_name_type_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForLangStringTextType:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`LangStringTextType`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`LangStringTextType`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.language: Optional[str] = None
+        self.text: Optional[str] = None
+
+    def read_and_set_language(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LangStringTextType.language` and set it.
+        """
+        self.language = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_text(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LangStringTextType.text` and set it.
+        """
+        self.text = _read_str_from_element_text(element, iterator)
+
+
+def _read_lang_string_text_type_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringTextType:
+    """
+    Read an instance of :py:class:`.types.LangStringTextType`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForLangStringTextType()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_LANG_STRING_TEXT_TYPE.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.language is None:
+        raise DeserializationException("The required property 'language' is missing")
+
+    if reader_and_setter.text is None:
+        raise DeserializationException("The required property 'text' is missing")
+
+    return aas_types.LangStringTextType(
+        reader_and_setter.language, reader_and_setter.text
+    )
+
+
+def _read_lang_string_text_type_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringTextType:
+    """
+    Read an instance of :py:class:`.types.LangStringTextType` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "langStringTextType":
+        raise DeserializationException(
+            f"Expected the element with the tag 'langStringTextType', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_lang_string_text_type_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForEnvironment:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`Environment`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`Environment`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.asset_administration_shells: Optional[
+            List[aas_types.AssetAdministrationShell]
+        ] = None
+        self.submodels: Optional[List[aas_types.Submodel]] = None
+        self.concept_descriptions: Optional[List[aas_types.ConceptDescription]] = None
+
+    def read_and_set_asset_administration_shells(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Environment.asset_administration_shells` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.AssetAdministrationShell] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_asset_administration_shell_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.asset_administration_shells = result
+
+    def read_and_set_submodels(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Environment.submodels` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.Submodel] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_submodel_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.submodels = result
+
+    def read_and_set_concept_descriptions(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.Environment.concept_descriptions` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.ConceptDescription] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_concept_description_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.concept_descriptions = result
+
+
+def _read_environment_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Environment:
+    """
+    Read an instance of :py:class:`.types.Environment`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForEnvironment()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_ENVIRONMENT.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    return aas_types.Environment(
+        reader_and_setter.asset_administration_shells,
+        reader_and_setter.submodels,
+        reader_and_setter.concept_descriptions,
+    )
+
+
+def _read_environment_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.Environment:
+    """
+    Read an instance of :py:class:`.types.Environment` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "environment":
+        raise DeserializationException(
+            f"Expected the element with the tag 'environment', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_environment_as_sequence(element, iterator)
+
+
+def _read_data_specification_content_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.DataSpecificationContent:
+    """
+    Read an instance of :py:class:`.types.DataSpecificationContent` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+    read_as_sequence = _DISPATCH_FOR_DATA_SPECIFICATION_CONTENT.get(tag_wo_ns, None)
+
+    if read_as_sequence is None:
+        raise DeserializationException(
+            f"Expected the element tag to be a valid model type "
+            f"of a concrete instance of 'DataSpecificationContent', "
+            f"but got tag {tag_wo_ns!r}"
+        )
+
+    return read_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForEmbeddedDataSpecification:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`EmbeddedDataSpecification`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`EmbeddedDataSpecification`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.data_specification: Optional[aas_types.Reference] = None
+        self.data_specification_content: Optional[
+            aas_types.DataSpecificationContent
+        ] = None
+
+    def read_and_set_data_specification(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.EmbeddedDataSpecification.data_specification` and set it.
+        """
+        self.data_specification = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_data_specification_content(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.EmbeddedDataSpecification.data_specification_content` and set it.
+        """
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected a discriminator start element corresponding "
+                "to DataSpecificationContent, but got end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event != "start":
+            raise DeserializationException(
+                f"Expected a discriminator start element corresponding "
+                f"to DataSpecificationContent, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            result = _read_data_specification_content_as_element(next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        _read_end_element(element, iterator)
+
+        self.data_specification_content = result
+
+
+def _read_embedded_data_specification_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.EmbeddedDataSpecification:
+    """
+    Read an instance of :py:class:`.types.EmbeddedDataSpecification`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForEmbeddedDataSpecification()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = (
+            _READ_AND_SET_DISPATCH_FOR_EMBEDDED_DATA_SPECIFICATION.get(tag_wo_ns, None)
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.data_specification is None:
+        raise DeserializationException(
+            "The required property 'dataSpecification' is missing"
+        )
+
+    if reader_and_setter.data_specification_content is None:
+        raise DeserializationException(
+            "The required property 'dataSpecificationContent' is missing"
+        )
+
+    return aas_types.EmbeddedDataSpecification(
+        reader_and_setter.data_specification,
+        reader_and_setter.data_specification_content,
+    )
+
+
+def _read_embedded_data_specification_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.EmbeddedDataSpecification:
+    """
+    Read an instance of :py:class:`.types.EmbeddedDataSpecification` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "embeddedDataSpecification":
+        raise DeserializationException(
+            f"Expected the element with the tag 'embeddedDataSpecification', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_embedded_data_specification_as_sequence(element, iterator)
+
+
+def _read_data_type_iec_61360_from_element_text(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.DataTypeIEC61360:
+    """
+    Parse the text of :paramref:`element` as a literal of
+    :py:class:`.types.DataTypeIEC61360`, and read the corresponding
+    end element from :paramref:`iterator`.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed value
+    """
+    text = _read_text_from_element(element, iterator)
+
+    literal = aas_stringification.data_type_iec_61360_from_str(text)
+    if literal is None:
+        raise DeserializationException(
+            f"Not a valid string representation of "
+            f"a literal of DataTypeIEC61360: {text}"
+        )
+
+    return literal
+
+
+class _ReaderAndSetterForLevelType:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`LevelType`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`LevelType`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.min: Optional[bool] = None
+        self.nom: Optional[bool] = None
+        self.typ: Optional[bool] = None
+        self.max: Optional[bool] = None
+
+    def read_and_set_min(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LevelType.min` and set it.
+        """
+        self.min = _read_bool_from_element_text(element, iterator)
+
+    def read_and_set_nom(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LevelType.nom` and set it.
+        """
+        self.nom = _read_bool_from_element_text(element, iterator)
+
+    def read_and_set_typ(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LevelType.typ` and set it.
+        """
+        self.typ = _read_bool_from_element_text(element, iterator)
+
+    def read_and_set_max(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LevelType.max` and set it.
+        """
+        self.max = _read_bool_from_element_text(element, iterator)
+
+
+def _read_level_type_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LevelType:
+    """
+    Read an instance of :py:class:`.types.LevelType`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForLevelType()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_LEVEL_TYPE.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.min is None:
+        raise DeserializationException("The required property 'min' is missing")
+
+    if reader_and_setter.nom is None:
+        raise DeserializationException("The required property 'nom' is missing")
+
+    if reader_and_setter.typ is None:
+        raise DeserializationException("The required property 'typ' is missing")
+
+    if reader_and_setter.max is None:
+        raise DeserializationException("The required property 'max' is missing")
+
+    return aas_types.LevelType(
+        reader_and_setter.min,
+        reader_and_setter.nom,
+        reader_and_setter.typ,
+        reader_and_setter.max,
+    )
+
+
+def _read_level_type_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LevelType:
+    """
+    Read an instance of :py:class:`.types.LevelType` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "levelType":
+        raise DeserializationException(
+            f"Expected the element with the tag 'levelType', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_level_type_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForValueReferencePair:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`ValueReferencePair`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`ValueReferencePair`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.value: Optional[str] = None
+        self.value_id: Optional[aas_types.Reference] = None
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ValueReferencePair.value` and set it.
+        """
+        self.value = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_value_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ValueReferencePair.value_id` and set it.
+        """
+        self.value_id = _read_reference_as_sequence(element, iterator)
+
+
+def _read_value_reference_pair_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ValueReferencePair:
+    """
+    Read an instance of :py:class:`.types.ValueReferencePair`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForValueReferencePair()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_VALUE_REFERENCE_PAIR.get(
+            tag_wo_ns, None
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.value is None:
+        raise DeserializationException("The required property 'value' is missing")
+
+    if reader_and_setter.value_id is None:
+        raise DeserializationException("The required property 'valueId' is missing")
+
+    return aas_types.ValueReferencePair(
+        reader_and_setter.value, reader_and_setter.value_id
+    )
+
+
+def _read_value_reference_pair_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ValueReferencePair:
+    """
+    Read an instance of :py:class:`.types.ValueReferencePair` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "valueReferencePair":
+        raise DeserializationException(
+            f"Expected the element with the tag 'valueReferencePair', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_value_reference_pair_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForValueList:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`ValueList`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`ValueList`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.value_reference_pairs: Optional[List[aas_types.ValueReferencePair]] = None
+
+    def read_and_set_value_reference_pairs(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.ValueList.value_reference_pairs` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.ValueReferencePair] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_value_reference_pair_as_element(next_element, iterator)
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.value_reference_pairs = result
+
+
+def _read_value_list_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ValueList:
+    """
+    Read an instance of :py:class:`.types.ValueList`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForValueList()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_VALUE_LIST.get(tag_wo_ns, None)
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.value_reference_pairs is None:
+        raise DeserializationException(
+            "The required property 'valueReferencePairs' is missing"
+        )
+
+    return aas_types.ValueList(reader_and_setter.value_reference_pairs)
+
+
+def _read_value_list_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.ValueList:
+    """
+    Read an instance of :py:class:`.types.ValueList` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "valueList":
+        raise DeserializationException(
+            f"Expected the element with the tag 'valueList', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_value_list_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForLangStringPreferredNameTypeIEC61360:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`LangStringPreferredNameTypeIEC61360`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`LangStringPreferredNameTypeIEC61360`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.language: Optional[str] = None
+        self.text: Optional[str] = None
+
+    def read_and_set_language(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LangStringPreferredNameTypeIEC61360.language` and set it.
+        """
+        self.language = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_text(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LangStringPreferredNameTypeIEC61360.text` and set it.
+        """
+        self.text = _read_str_from_element_text(element, iterator)
+
+
+def _read_lang_string_preferred_name_type_iec_61360_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringPreferredNameTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForLangStringPreferredNameTypeIEC61360()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = (
+            _READ_AND_SET_DISPATCH_FOR_LANG_STRING_PREFERRED_NAME_TYPE_IEC_61360.get(
+                tag_wo_ns, None
+            )
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.language is None:
+        raise DeserializationException("The required property 'language' is missing")
+
+    if reader_and_setter.text is None:
+        raise DeserializationException("The required property 'text' is missing")
+
+    return aas_types.LangStringPreferredNameTypeIEC61360(
+        reader_and_setter.language, reader_and_setter.text
+    )
+
+
+def _read_lang_string_preferred_name_type_iec_61360_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringPreferredNameTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringPreferredNameTypeIEC61360` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "langStringPreferredNameTypeIec61360":
+        raise DeserializationException(
+            f"Expected the element with the tag 'langStringPreferredNameTypeIec61360', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_lang_string_preferred_name_type_iec_61360_as_sequence(
+        element, iterator
+    )
+
+
+class _ReaderAndSetterForLangStringShortNameTypeIEC61360:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`LangStringShortNameTypeIEC61360`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`LangStringShortNameTypeIEC61360`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.language: Optional[str] = None
+        self.text: Optional[str] = None
+
+    def read_and_set_language(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LangStringShortNameTypeIEC61360.language` and set it.
+        """
+        self.language = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_text(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LangStringShortNameTypeIEC61360.text` and set it.
+        """
+        self.text = _read_str_from_element_text(element, iterator)
+
+
+def _read_lang_string_short_name_type_iec_61360_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringShortNameTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringShortNameTypeIEC61360`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForLangStringShortNameTypeIEC61360()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = (
+            _READ_AND_SET_DISPATCH_FOR_LANG_STRING_SHORT_NAME_TYPE_IEC_61360.get(
+                tag_wo_ns, None
+            )
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.language is None:
+        raise DeserializationException("The required property 'language' is missing")
+
+    if reader_and_setter.text is None:
+        raise DeserializationException("The required property 'text' is missing")
+
+    return aas_types.LangStringShortNameTypeIEC61360(
+        reader_and_setter.language, reader_and_setter.text
+    )
+
+
+def _read_lang_string_short_name_type_iec_61360_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringShortNameTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringShortNameTypeIEC61360` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "langStringShortNameTypeIec61360":
+        raise DeserializationException(
+            f"Expected the element with the tag 'langStringShortNameTypeIec61360', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_lang_string_short_name_type_iec_61360_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForLangStringDefinitionTypeIEC61360:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`LangStringDefinitionTypeIEC61360`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`LangStringDefinitionTypeIEC61360`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.language: Optional[str] = None
+        self.text: Optional[str] = None
+
+    def read_and_set_language(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LangStringDefinitionTypeIEC61360.language` and set it.
+        """
+        self.language = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_text(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.LangStringDefinitionTypeIEC61360.text` and set it.
+        """
+        self.text = _read_str_from_element_text(element, iterator)
+
+
+def _read_lang_string_definition_type_iec_61360_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringDefinitionTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringDefinitionTypeIEC61360`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForLangStringDefinitionTypeIEC61360()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = (
+            _READ_AND_SET_DISPATCH_FOR_LANG_STRING_DEFINITION_TYPE_IEC_61360.get(
+                tag_wo_ns, None
+            )
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.language is None:
+        raise DeserializationException("The required property 'language' is missing")
+
+    if reader_and_setter.text is None:
+        raise DeserializationException("The required property 'text' is missing")
+
+    return aas_types.LangStringDefinitionTypeIEC61360(
+        reader_and_setter.language, reader_and_setter.text
+    )
+
+
+def _read_lang_string_definition_type_iec_61360_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.LangStringDefinitionTypeIEC61360:
+    """
+    Read an instance of :py:class:`.types.LangStringDefinitionTypeIEC61360` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "langStringDefinitionTypeIec61360":
+        raise DeserializationException(
+            f"Expected the element with the tag 'langStringDefinitionTypeIec61360', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_lang_string_definition_type_iec_61360_as_sequence(element, iterator)
+
+
+class _ReaderAndSetterForDataSpecificationIEC61360:
+    """
+    Provide a buffer for reading and setting the properties for the class
+    :py:class:`DataSpecificationIEC61360`.
+
+    The properties correspond to the constructor arguments of
+    :py:class:`DataSpecificationIEC61360`. We use this buffer to facilitate dispatching when
+    parsing the properties in a streaming fashion.
+    """
+
+    def __init__(self) -> None:
+        """Initialize with all the properties unset."""
+        self.preferred_name: Optional[
+            List[aas_types.LangStringPreferredNameTypeIEC61360]
+        ] = None
+        self.short_name: Optional[
+            List[aas_types.LangStringShortNameTypeIEC61360]
+        ] = None
+        self.unit: Optional[str] = None
+        self.unit_id: Optional[aas_types.Reference] = None
+        self.source_of_definition: Optional[str] = None
+        self.symbol: Optional[str] = None
+        self.data_type: Optional[aas_types.DataTypeIEC61360] = None
+        self.definition: Optional[
+            List[aas_types.LangStringDefinitionTypeIEC61360]
+        ] = None
+        self.value_format: Optional[str] = None
+        self.value_list: Optional[aas_types.ValueList] = None
+        self.value: Optional[str] = None
+        self.level_type: Optional[aas_types.LevelType] = None
+
+    def read_and_set_preferred_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.DataSpecificationIEC61360.preferred_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringPreferredNameTypeIEC61360] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_preferred_name_type_iec_61360_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.preferred_name = result
+
+    def read_and_set_short_name(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.DataSpecificationIEC61360.short_name` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringShortNameTypeIEC61360] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_short_name_type_iec_61360_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.short_name = result
+
+    def read_and_set_unit(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.DataSpecificationIEC61360.unit` and set it.
+        """
+        self.unit = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_unit_id(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.DataSpecificationIEC61360.unit_id` and set it.
+        """
+        self.unit_id = _read_reference_as_sequence(element, iterator)
+
+    def read_and_set_source_of_definition(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.DataSpecificationIEC61360.source_of_definition` and set it.
+        """
+        self.source_of_definition = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_symbol(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.DataSpecificationIEC61360.symbol` and set it.
+        """
+        self.symbol = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_data_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.DataSpecificationIEC61360.data_type` and set it.
+        """
+        self.data_type = _read_data_type_iec_61360_from_element_text(element, iterator)
+
+    def read_and_set_definition(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.DataSpecificationIEC61360.definition` and set it.
+        """
+        if element.text is not None and len(element.text.strip()) != 0:
+            raise DeserializationException(
+                f"Expected only item elements and whitespace text, "
+                f"but got text: {element.text!r}"
+            )
+
+        result: List[aas_types.LangStringDefinitionTypeIEC61360] = []
+
+        item_i = 0
+
+        while True:
+            next_event_element = next(iterator, None)
+            if next_event_element is None:
+                raise DeserializationException(
+                    "Expected one or more items from a list or the end element, "
+                    "but got end-of-input"
+                )
+
+            next_event, next_element = next_event_element
+            if next_event == "end" and next_element.tag == element.tag:
+                # We reached the end of the list.
+                break
+
+            if next_event != "start":
+                raise DeserializationException(
+                    "Expected a start element corresponding to an item, "
+                    f"but got event {next_event!r} and element {next_element.tag!r}"
+                )
+
+            try:
+                item = _read_lang_string_definition_type_iec_61360_as_element(
+                    next_element, iterator
+                )
+            except DeserializationException as exception:
+                exception.path._prepend(IndexSegment(next_element, item_i))
+                raise
+
+            result.append(item)
+            item_i += 1
+
+        self.definition = result
+
+    def read_and_set_value_format(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.DataSpecificationIEC61360.value_format` and set it.
+        """
+        self.value_format = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_value_list(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.DataSpecificationIEC61360.value_list` and set it.
+        """
+        self.value_list = _read_value_list_as_sequence(element, iterator)
+
+    def read_and_set_value(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.DataSpecificationIEC61360.value` and set it.
+        """
+        self.value = _read_str_from_element_text(element, iterator)
+
+    def read_and_set_level_type(
+        self, element: Element, iterator: Iterator[Tuple[str, Element]]
+    ) -> None:
+        """
+        Read :paramref:`element` as the property
+        :py:attr:`.types.DataSpecificationIEC61360.level_type` and set it.
+        """
+        self.level_type = _read_level_type_as_sequence(element, iterator)
+
+
+def _read_data_specification_iec_61360_as_sequence(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.DataSpecificationIEC61360:
+    """
+    Read an instance of :py:class:`.types.DataSpecificationIEC61360`
+    as a sequence of XML-encoded properties.
+
+    The end element corresponding to the :paramref:`element` will be
+    read as well.
+
+    :param element: start element, parent of the sequence
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    if element.text is not None and len(element.text.strip()) != 0:
+        raise DeserializationException(
+            f"Expected only XML elements representing the properties and whitespace text, "
+            f"but got text: {element.text!r}"
+        )
+
+    _raise_if_has_tail_or_attrib(element)
+
+    reader_and_setter = _ReaderAndSetterForDataSpecificationIEC61360()
+
+    while True:
+        next_event_element = next(iterator, None)
+        if next_event_element is None:
+            raise DeserializationException(
+                "Expected one or more XML-encoded properties or the end element, "
+                "but got the end-of-input"
+            )
+
+        next_event, next_element = next_event_element
+        if next_event == "end" and next_element.tag == element.tag:
+            # We reached the end element enclosing the sequence.
+            break
+
+        if next_event != "start":
+            raise DeserializationException(
+                "Expected a start element corresponding to a property, "
+                f"but got event {next_event!r} and element {next_element.tag!r}"
+            )
+
+        try:
+            tag_wo_ns = _parse_element_tag(next_element)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+        read_and_set_method = (
+            _READ_AND_SET_DISPATCH_FOR_DATA_SPECIFICATION_IEC_61360.get(tag_wo_ns, None)
+        )
+        if read_and_set_method is None:
+            an_exception = DeserializationException(
+                f"Expected an element representing a property, "
+                f"but got an element with unexpected tag: {tag_wo_ns!r}"
+            )
+            an_exception.path._prepend(ElementSegment(next_element))
+            raise an_exception
+
+        try:
+            read_and_set_method(reader_and_setter, next_element, iterator)
+        except DeserializationException as exception:
+            exception.path._prepend(ElementSegment(next_element))
+            raise
+
+    if reader_and_setter.preferred_name is None:
+        raise DeserializationException(
+            "The required property 'preferredName' is missing"
+        )
+
+    return aas_types.DataSpecificationIEC61360(
+        reader_and_setter.preferred_name,
+        reader_and_setter.short_name,
+        reader_and_setter.unit,
+        reader_and_setter.unit_id,
+        reader_and_setter.source_of_definition,
+        reader_and_setter.symbol,
+        reader_and_setter.data_type,
+        reader_and_setter.definition,
+        reader_and_setter.value_format,
+        reader_and_setter.value_list,
+        reader_and_setter.value,
+        reader_and_setter.level_type,
+    )
+
+
+def _read_data_specification_iec_61360_as_element(
+    element: Element, iterator: Iterator[Tuple[str, Element]]
+) -> aas_types.DataSpecificationIEC61360:
+    """
+    Read an instance of :py:class:`.types.DataSpecificationIEC61360` from
+    :paramref:`iterator`, including the end element.
+
+    :param element: start element
+    :param iterator:
+        Input stream of ``(event, element)`` coming from
+        :py:func:`xml.etree.ElementTree.iterparse` with the argument
+        ``events=["start", "end"]``
+    :raise: :py:class:`DeserializationException` if unexpected input
+    :return: parsed instance
+    """
+    tag_wo_ns = _parse_element_tag(element)
+
+    if tag_wo_ns != "dataSpecificationIec61360":
+        raise DeserializationException(
+            f"Expected the element with the tag 'dataSpecificationIec61360', "
+            f"but got tag: {tag_wo_ns}"
+        )
+
+    return _read_data_specification_iec_61360_as_sequence(element, iterator)
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to concrete descendants of HasSemantics
+_DISPATCH_FOR_HAS_SEMANTICS: Mapping[
+    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.HasSemantics]
+] = {
+    "relationshipElement": _read_relationship_element_as_sequence,
+    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
+    "basicEventElement": _read_basic_event_element_as_sequence,
+    "blob": _read_blob_as_sequence,
+    "capability": _read_capability_as_sequence,
+    "entity": _read_entity_as_sequence,
+    "extension": _read_extension_as_sequence,
+    "file": _read_file_as_sequence,
+    "multiLanguageProperty": _read_multi_language_property_as_sequence,
+    "operation": _read_operation_as_sequence,
+    "property": _read_property_as_sequence,
+    "qualifier": _read_qualifier_as_sequence,
+    "range": _read_range_as_sequence,
+    "referenceElement": _read_reference_element_as_sequence,
+    "specificAssetId": _read_specific_asset_id_as_sequence,
+    "submodel": _read_submodel_as_sequence,
+    "submodelElementCollection": _read_submodel_element_collection_as_sequence,
+    "submodelElementList": _read_submodel_element_list_as_sequence,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForExtension`
+_READ_AND_SET_DISPATCH_FOR_EXTENSION: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForExtension, Element, Iterator[Tuple[str, Element]]], None
+    ],
+] = {
+    "semanticId": _ReaderAndSetterForExtension.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForExtension.read_and_set_supplemental_semantic_ids,
+    "name": _ReaderAndSetterForExtension.read_and_set_name,
+    "valueType": _ReaderAndSetterForExtension.read_and_set_value_type,
+    "value": _ReaderAndSetterForExtension.read_and_set_value,
+    "refersTo": _ReaderAndSetterForExtension.read_and_set_refers_to,
+}
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to concrete descendants of HasExtensions
+_DISPATCH_FOR_HAS_EXTENSIONS: Mapping[
+    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.HasExtensions]
+] = {
+    "relationshipElement": _read_relationship_element_as_sequence,
+    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
+    "assetAdministrationShell": _read_asset_administration_shell_as_sequence,
+    "basicEventElement": _read_basic_event_element_as_sequence,
+    "blob": _read_blob_as_sequence,
+    "capability": _read_capability_as_sequence,
+    "conceptDescription": _read_concept_description_as_sequence,
+    "entity": _read_entity_as_sequence,
+    "file": _read_file_as_sequence,
+    "multiLanguageProperty": _read_multi_language_property_as_sequence,
+    "operation": _read_operation_as_sequence,
+    "property": _read_property_as_sequence,
+    "range": _read_range_as_sequence,
+    "referenceElement": _read_reference_element_as_sequence,
+    "submodel": _read_submodel_as_sequence,
+    "submodelElementCollection": _read_submodel_element_collection_as_sequence,
+    "submodelElementList": _read_submodel_element_list_as_sequence,
+}
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to concrete descendants of Referable
+_DISPATCH_FOR_REFERABLE: Mapping[
+    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.Referable]
+] = {
+    "relationshipElement": _read_relationship_element_as_sequence,
+    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
+    "assetAdministrationShell": _read_asset_administration_shell_as_sequence,
+    "basicEventElement": _read_basic_event_element_as_sequence,
+    "blob": _read_blob_as_sequence,
+    "capability": _read_capability_as_sequence,
+    "conceptDescription": _read_concept_description_as_sequence,
+    "entity": _read_entity_as_sequence,
+    "file": _read_file_as_sequence,
+    "multiLanguageProperty": _read_multi_language_property_as_sequence,
+    "operation": _read_operation_as_sequence,
+    "property": _read_property_as_sequence,
+    "range": _read_range_as_sequence,
+    "referenceElement": _read_reference_element_as_sequence,
+    "submodel": _read_submodel_as_sequence,
+    "submodelElementCollection": _read_submodel_element_collection_as_sequence,
+    "submodelElementList": _read_submodel_element_list_as_sequence,
+}
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to concrete descendants of Identifiable
+_DISPATCH_FOR_IDENTIFIABLE: Mapping[
+    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.Identifiable]
+] = {
+    "assetAdministrationShell": _read_asset_administration_shell_as_sequence,
+    "conceptDescription": _read_concept_description_as_sequence,
+    "submodel": _read_submodel_as_sequence,
+}
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to concrete descendants of HasKind
+_DISPATCH_FOR_HAS_KIND: Mapping[
+    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.HasKind]
+] = {
+    "submodel": _read_submodel_as_sequence,
+}
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to concrete descendants of HasDataSpecification
+_DISPATCH_FOR_HAS_DATA_SPECIFICATION: Mapping[
+    str,
+    Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.HasDataSpecification],
+] = {
+    "administrativeInformation": _read_administrative_information_as_sequence,
+    "relationshipElement": _read_relationship_element_as_sequence,
+    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
+    "assetAdministrationShell": _read_asset_administration_shell_as_sequence,
+    "basicEventElement": _read_basic_event_element_as_sequence,
+    "blob": _read_blob_as_sequence,
+    "capability": _read_capability_as_sequence,
+    "conceptDescription": _read_concept_description_as_sequence,
+    "entity": _read_entity_as_sequence,
+    "file": _read_file_as_sequence,
+    "multiLanguageProperty": _read_multi_language_property_as_sequence,
+    "operation": _read_operation_as_sequence,
+    "property": _read_property_as_sequence,
+    "range": _read_range_as_sequence,
+    "referenceElement": _read_reference_element_as_sequence,
+    "submodel": _read_submodel_as_sequence,
+    "submodelElementCollection": _read_submodel_element_collection_as_sequence,
+    "submodelElementList": _read_submodel_element_list_as_sequence,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForAdministrativeInformation`
+_READ_AND_SET_DISPATCH_FOR_ADMINISTRATIVE_INFORMATION: Mapping[
+    str,
+    Callable[
+        [
+            _ReaderAndSetterForAdministrativeInformation,
+            Element,
+            Iterator[Tuple[str, Element]],
+        ],
+        None,
+    ],
+] = {
+    "embeddedDataSpecifications": _ReaderAndSetterForAdministrativeInformation.read_and_set_embedded_data_specifications,
+    "version": _ReaderAndSetterForAdministrativeInformation.read_and_set_version,
+    "revision": _ReaderAndSetterForAdministrativeInformation.read_and_set_revision,
+    "creator": _ReaderAndSetterForAdministrativeInformation.read_and_set_creator,
+    "templateId": _ReaderAndSetterForAdministrativeInformation.read_and_set_template_id,
+}
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to concrete descendants of Qualifiable
+_DISPATCH_FOR_QUALIFIABLE: Mapping[
+    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.Qualifiable]
+] = {
+    "relationshipElement": _read_relationship_element_as_sequence,
+    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
+    "basicEventElement": _read_basic_event_element_as_sequence,
+    "blob": _read_blob_as_sequence,
+    "capability": _read_capability_as_sequence,
+    "entity": _read_entity_as_sequence,
+    "file": _read_file_as_sequence,
+    "multiLanguageProperty": _read_multi_language_property_as_sequence,
+    "operation": _read_operation_as_sequence,
+    "property": _read_property_as_sequence,
+    "range": _read_range_as_sequence,
+    "referenceElement": _read_reference_element_as_sequence,
+    "submodel": _read_submodel_as_sequence,
+    "submodelElementCollection": _read_submodel_element_collection_as_sequence,
+    "submodelElementList": _read_submodel_element_list_as_sequence,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForQualifier`
+_READ_AND_SET_DISPATCH_FOR_QUALIFIER: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForQualifier, Element, Iterator[Tuple[str, Element]]], None
+    ],
+] = {
+    "semanticId": _ReaderAndSetterForQualifier.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForQualifier.read_and_set_supplemental_semantic_ids,
+    "kind": _ReaderAndSetterForQualifier.read_and_set_kind,
+    "type": _ReaderAndSetterForQualifier.read_and_set_type,
+    "valueType": _ReaderAndSetterForQualifier.read_and_set_value_type,
+    "value": _ReaderAndSetterForQualifier.read_and_set_value,
+    "valueId": _ReaderAndSetterForQualifier.read_and_set_value_id,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForAssetAdministrationShell`
+_READ_AND_SET_DISPATCH_FOR_ASSET_ADMINISTRATION_SHELL: Mapping[
+    str,
+    Callable[
+        [
+            _ReaderAndSetterForAssetAdministrationShell,
+            Element,
+            Iterator[Tuple[str, Element]],
+        ],
+        None,
+    ],
+] = {
+    "extensions": _ReaderAndSetterForAssetAdministrationShell.read_and_set_extensions,
+    "category": _ReaderAndSetterForAssetAdministrationShell.read_and_set_category,
+    "idShort": _ReaderAndSetterForAssetAdministrationShell.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForAssetAdministrationShell.read_and_set_display_name,
+    "description": _ReaderAndSetterForAssetAdministrationShell.read_and_set_description,
+    "administration": _ReaderAndSetterForAssetAdministrationShell.read_and_set_administration,
+    "id": _ReaderAndSetterForAssetAdministrationShell.read_and_set_id,
+    "embeddedDataSpecifications": _ReaderAndSetterForAssetAdministrationShell.read_and_set_embedded_data_specifications,
+    "derivedFrom": _ReaderAndSetterForAssetAdministrationShell.read_and_set_derived_from,
+    "assetInformation": _ReaderAndSetterForAssetAdministrationShell.read_and_set_asset_information,
+    "submodels": _ReaderAndSetterForAssetAdministrationShell.read_and_set_submodels,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForAssetInformation`
+_READ_AND_SET_DISPATCH_FOR_ASSET_INFORMATION: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForAssetInformation, Element, Iterator[Tuple[str, Element]]],
+        None,
+    ],
+] = {
+    "assetKind": _ReaderAndSetterForAssetInformation.read_and_set_asset_kind,
+    "globalAssetId": _ReaderAndSetterForAssetInformation.read_and_set_global_asset_id,
+    "specificAssetIds": _ReaderAndSetterForAssetInformation.read_and_set_specific_asset_ids,
+    "assetType": _ReaderAndSetterForAssetInformation.read_and_set_asset_type,
+    "defaultThumbnail": _ReaderAndSetterForAssetInformation.read_and_set_default_thumbnail,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForResource`
+_READ_AND_SET_DISPATCH_FOR_RESOURCE: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForResource, Element, Iterator[Tuple[str, Element]]], None
+    ],
+] = {
+    "path": _ReaderAndSetterForResource.read_and_set_path,
+    "contentType": _ReaderAndSetterForResource.read_and_set_content_type,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForSpecificAssetID`
+_READ_AND_SET_DISPATCH_FOR_SPECIFIC_ASSET_ID: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForSpecificAssetID, Element, Iterator[Tuple[str, Element]]],
+        None,
+    ],
+] = {
+    "semanticId": _ReaderAndSetterForSpecificAssetID.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForSpecificAssetID.read_and_set_supplemental_semantic_ids,
+    "name": _ReaderAndSetterForSpecificAssetID.read_and_set_name,
+    "value": _ReaderAndSetterForSpecificAssetID.read_and_set_value,
+    "externalSubjectId": _ReaderAndSetterForSpecificAssetID.read_and_set_external_subject_id,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForSubmodel`
+_READ_AND_SET_DISPATCH_FOR_SUBMODEL: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForSubmodel, Element, Iterator[Tuple[str, Element]]], None
+    ],
+] = {
+    "extensions": _ReaderAndSetterForSubmodel.read_and_set_extensions,
+    "category": _ReaderAndSetterForSubmodel.read_and_set_category,
+    "idShort": _ReaderAndSetterForSubmodel.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForSubmodel.read_and_set_display_name,
+    "description": _ReaderAndSetterForSubmodel.read_and_set_description,
+    "administration": _ReaderAndSetterForSubmodel.read_and_set_administration,
+    "id": _ReaderAndSetterForSubmodel.read_and_set_id,
+    "kind": _ReaderAndSetterForSubmodel.read_and_set_kind,
+    "semanticId": _ReaderAndSetterForSubmodel.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForSubmodel.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForSubmodel.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForSubmodel.read_and_set_embedded_data_specifications,
+    "submodelElements": _ReaderAndSetterForSubmodel.read_and_set_submodel_elements,
+}
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to concrete descendants of SubmodelElement
+_DISPATCH_FOR_SUBMODEL_ELEMENT: Mapping[
+    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.SubmodelElement]
+] = {
+    "relationshipElement": _read_relationship_element_as_sequence,
+    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
+    "basicEventElement": _read_basic_event_element_as_sequence,
+    "blob": _read_blob_as_sequence,
+    "capability": _read_capability_as_sequence,
+    "entity": _read_entity_as_sequence,
+    "file": _read_file_as_sequence,
+    "multiLanguageProperty": _read_multi_language_property_as_sequence,
+    "operation": _read_operation_as_sequence,
+    "property": _read_property_as_sequence,
+    "range": _read_range_as_sequence,
+    "referenceElement": _read_reference_element_as_sequence,
+    "submodelElementCollection": _read_submodel_element_collection_as_sequence,
+    "submodelElementList": _read_submodel_element_list_as_sequence,
+}
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to RelationshipElement and its concrete descendants
+_DISPATCH_FOR_RELATIONSHIP_ELEMENT: Mapping[
+    str,
+    Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.RelationshipElement],
+] = {
+    "relationshipElement": _read_relationship_element_as_sequence,
+    "annotatedRelationshipElement": _read_annotated_relationship_element_as_sequence,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForRelationshipElement`
+_READ_AND_SET_DISPATCH_FOR_RELATIONSHIP_ELEMENT: Mapping[
+    str,
+    Callable[
+        [
+            _ReaderAndSetterForRelationshipElement,
+            Element,
+            Iterator[Tuple[str, Element]],
+        ],
+        None,
+    ],
+] = {
+    "extensions": _ReaderAndSetterForRelationshipElement.read_and_set_extensions,
+    "category": _ReaderAndSetterForRelationshipElement.read_and_set_category,
+    "idShort": _ReaderAndSetterForRelationshipElement.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForRelationshipElement.read_and_set_display_name,
+    "description": _ReaderAndSetterForRelationshipElement.read_and_set_description,
+    "semanticId": _ReaderAndSetterForRelationshipElement.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForRelationshipElement.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForRelationshipElement.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForRelationshipElement.read_and_set_embedded_data_specifications,
+    "first": _ReaderAndSetterForRelationshipElement.read_and_set_first,
+    "second": _ReaderAndSetterForRelationshipElement.read_and_set_second,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForSubmodelElementList`
+_READ_AND_SET_DISPATCH_FOR_SUBMODEL_ELEMENT_LIST: Mapping[
+    str,
+    Callable[
+        [
+            _ReaderAndSetterForSubmodelElementList,
+            Element,
+            Iterator[Tuple[str, Element]],
+        ],
+        None,
+    ],
+] = {
+    "extensions": _ReaderAndSetterForSubmodelElementList.read_and_set_extensions,
+    "category": _ReaderAndSetterForSubmodelElementList.read_and_set_category,
+    "idShort": _ReaderAndSetterForSubmodelElementList.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForSubmodelElementList.read_and_set_display_name,
+    "description": _ReaderAndSetterForSubmodelElementList.read_and_set_description,
+    "semanticId": _ReaderAndSetterForSubmodelElementList.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForSubmodelElementList.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForSubmodelElementList.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForSubmodelElementList.read_and_set_embedded_data_specifications,
+    "orderRelevant": _ReaderAndSetterForSubmodelElementList.read_and_set_order_relevant,
+    "semanticIdListElement": _ReaderAndSetterForSubmodelElementList.read_and_set_semantic_id_list_element,
+    "typeValueListElement": _ReaderAndSetterForSubmodelElementList.read_and_set_type_value_list_element,
+    "valueTypeListElement": _ReaderAndSetterForSubmodelElementList.read_and_set_value_type_list_element,
+    "value": _ReaderAndSetterForSubmodelElementList.read_and_set_value,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForSubmodelElementCollection`
+_READ_AND_SET_DISPATCH_FOR_SUBMODEL_ELEMENT_COLLECTION: Mapping[
+    str,
+    Callable[
+        [
+            _ReaderAndSetterForSubmodelElementCollection,
+            Element,
+            Iterator[Tuple[str, Element]],
+        ],
+        None,
+    ],
+] = {
+    "extensions": _ReaderAndSetterForSubmodelElementCollection.read_and_set_extensions,
+    "category": _ReaderAndSetterForSubmodelElementCollection.read_and_set_category,
+    "idShort": _ReaderAndSetterForSubmodelElementCollection.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForSubmodelElementCollection.read_and_set_display_name,
+    "description": _ReaderAndSetterForSubmodelElementCollection.read_and_set_description,
+    "semanticId": _ReaderAndSetterForSubmodelElementCollection.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForSubmodelElementCollection.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForSubmodelElementCollection.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForSubmodelElementCollection.read_and_set_embedded_data_specifications,
+    "value": _ReaderAndSetterForSubmodelElementCollection.read_and_set_value,
+}
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to concrete descendants of DataElement
+_DISPATCH_FOR_DATA_ELEMENT: Mapping[
+    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.DataElement]
+] = {
+    "blob": _read_blob_as_sequence,
+    "file": _read_file_as_sequence,
+    "multiLanguageProperty": _read_multi_language_property_as_sequence,
+    "property": _read_property_as_sequence,
+    "range": _read_range_as_sequence,
+    "referenceElement": _read_reference_element_as_sequence,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForProperty`
+_READ_AND_SET_DISPATCH_FOR_PROPERTY: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForProperty, Element, Iterator[Tuple[str, Element]]], None
+    ],
+] = {
+    "extensions": _ReaderAndSetterForProperty.read_and_set_extensions,
+    "category": _ReaderAndSetterForProperty.read_and_set_category,
+    "idShort": _ReaderAndSetterForProperty.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForProperty.read_and_set_display_name,
+    "description": _ReaderAndSetterForProperty.read_and_set_description,
+    "semanticId": _ReaderAndSetterForProperty.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForProperty.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForProperty.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForProperty.read_and_set_embedded_data_specifications,
+    "valueType": _ReaderAndSetterForProperty.read_and_set_value_type,
+    "value": _ReaderAndSetterForProperty.read_and_set_value,
+    "valueId": _ReaderAndSetterForProperty.read_and_set_value_id,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForMultiLanguageProperty`
+_READ_AND_SET_DISPATCH_FOR_MULTI_LANGUAGE_PROPERTY: Mapping[
+    str,
+    Callable[
+        [
+            _ReaderAndSetterForMultiLanguageProperty,
+            Element,
+            Iterator[Tuple[str, Element]],
+        ],
+        None,
+    ],
+] = {
+    "extensions": _ReaderAndSetterForMultiLanguageProperty.read_and_set_extensions,
+    "category": _ReaderAndSetterForMultiLanguageProperty.read_and_set_category,
+    "idShort": _ReaderAndSetterForMultiLanguageProperty.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForMultiLanguageProperty.read_and_set_display_name,
+    "description": _ReaderAndSetterForMultiLanguageProperty.read_and_set_description,
+    "semanticId": _ReaderAndSetterForMultiLanguageProperty.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForMultiLanguageProperty.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForMultiLanguageProperty.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForMultiLanguageProperty.read_and_set_embedded_data_specifications,
+    "value": _ReaderAndSetterForMultiLanguageProperty.read_and_set_value,
+    "valueId": _ReaderAndSetterForMultiLanguageProperty.read_and_set_value_id,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForRange`
+_READ_AND_SET_DISPATCH_FOR_RANGE: Mapping[
+    str,
+    Callable[[_ReaderAndSetterForRange, Element, Iterator[Tuple[str, Element]]], None],
+] = {
+    "extensions": _ReaderAndSetterForRange.read_and_set_extensions,
+    "category": _ReaderAndSetterForRange.read_and_set_category,
+    "idShort": _ReaderAndSetterForRange.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForRange.read_and_set_display_name,
+    "description": _ReaderAndSetterForRange.read_and_set_description,
+    "semanticId": _ReaderAndSetterForRange.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForRange.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForRange.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForRange.read_and_set_embedded_data_specifications,
+    "valueType": _ReaderAndSetterForRange.read_and_set_value_type,
+    "min": _ReaderAndSetterForRange.read_and_set_min,
+    "max": _ReaderAndSetterForRange.read_and_set_max,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForReferenceElement`
+_READ_AND_SET_DISPATCH_FOR_REFERENCE_ELEMENT: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForReferenceElement, Element, Iterator[Tuple[str, Element]]],
+        None,
+    ],
+] = {
+    "extensions": _ReaderAndSetterForReferenceElement.read_and_set_extensions,
+    "category": _ReaderAndSetterForReferenceElement.read_and_set_category,
+    "idShort": _ReaderAndSetterForReferenceElement.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForReferenceElement.read_and_set_display_name,
+    "description": _ReaderAndSetterForReferenceElement.read_and_set_description,
+    "semanticId": _ReaderAndSetterForReferenceElement.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForReferenceElement.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForReferenceElement.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForReferenceElement.read_and_set_embedded_data_specifications,
+    "value": _ReaderAndSetterForReferenceElement.read_and_set_value,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForBlob`
+_READ_AND_SET_DISPATCH_FOR_BLOB: Mapping[
+    str,
+    Callable[[_ReaderAndSetterForBlob, Element, Iterator[Tuple[str, Element]]], None],
+] = {
+    "extensions": _ReaderAndSetterForBlob.read_and_set_extensions,
+    "category": _ReaderAndSetterForBlob.read_and_set_category,
+    "idShort": _ReaderAndSetterForBlob.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForBlob.read_and_set_display_name,
+    "description": _ReaderAndSetterForBlob.read_and_set_description,
+    "semanticId": _ReaderAndSetterForBlob.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForBlob.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForBlob.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForBlob.read_and_set_embedded_data_specifications,
+    "value": _ReaderAndSetterForBlob.read_and_set_value,
+    "contentType": _ReaderAndSetterForBlob.read_and_set_content_type,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForFile`
+_READ_AND_SET_DISPATCH_FOR_FILE: Mapping[
+    str,
+    Callable[[_ReaderAndSetterForFile, Element, Iterator[Tuple[str, Element]]], None],
+] = {
+    "extensions": _ReaderAndSetterForFile.read_and_set_extensions,
+    "category": _ReaderAndSetterForFile.read_and_set_category,
+    "idShort": _ReaderAndSetterForFile.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForFile.read_and_set_display_name,
+    "description": _ReaderAndSetterForFile.read_and_set_description,
+    "semanticId": _ReaderAndSetterForFile.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForFile.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForFile.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForFile.read_and_set_embedded_data_specifications,
+    "value": _ReaderAndSetterForFile.read_and_set_value,
+    "contentType": _ReaderAndSetterForFile.read_and_set_content_type,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForAnnotatedRelationshipElement`
+_READ_AND_SET_DISPATCH_FOR_ANNOTATED_RELATIONSHIP_ELEMENT: Mapping[
+    str,
+    Callable[
+        [
+            _ReaderAndSetterForAnnotatedRelationshipElement,
+            Element,
+            Iterator[Tuple[str, Element]],
+        ],
+        None,
+    ],
+] = {
+    "extensions": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_extensions,
+    "category": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_category,
+    "idShort": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_display_name,
+    "description": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_description,
+    "semanticId": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_embedded_data_specifications,
+    "first": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_first,
+    "second": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_second,
+    "annotations": _ReaderAndSetterForAnnotatedRelationshipElement.read_and_set_annotations,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForEntity`
+_READ_AND_SET_DISPATCH_FOR_ENTITY: Mapping[
+    str,
+    Callable[[_ReaderAndSetterForEntity, Element, Iterator[Tuple[str, Element]]], None],
+] = {
+    "extensions": _ReaderAndSetterForEntity.read_and_set_extensions,
+    "category": _ReaderAndSetterForEntity.read_and_set_category,
+    "idShort": _ReaderAndSetterForEntity.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForEntity.read_and_set_display_name,
+    "description": _ReaderAndSetterForEntity.read_and_set_description,
+    "semanticId": _ReaderAndSetterForEntity.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForEntity.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForEntity.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForEntity.read_and_set_embedded_data_specifications,
+    "statements": _ReaderAndSetterForEntity.read_and_set_statements,
+    "entityType": _ReaderAndSetterForEntity.read_and_set_entity_type,
+    "globalAssetId": _ReaderAndSetterForEntity.read_and_set_global_asset_id,
+    "specificAssetIds": _ReaderAndSetterForEntity.read_and_set_specific_asset_ids,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForEventPayload`
+_READ_AND_SET_DISPATCH_FOR_EVENT_PAYLOAD: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForEventPayload, Element, Iterator[Tuple[str, Element]]], None
+    ],
+] = {
+    "source": _ReaderAndSetterForEventPayload.read_and_set_source,
+    "sourceSemanticId": _ReaderAndSetterForEventPayload.read_and_set_source_semantic_id,
+    "observableReference": _ReaderAndSetterForEventPayload.read_and_set_observable_reference,
+    "observableSemanticId": _ReaderAndSetterForEventPayload.read_and_set_observable_semantic_id,
+    "topic": _ReaderAndSetterForEventPayload.read_and_set_topic,
+    "subjectId": _ReaderAndSetterForEventPayload.read_and_set_subject_id,
+    "timeStamp": _ReaderAndSetterForEventPayload.read_and_set_time_stamp,
+    "payload": _ReaderAndSetterForEventPayload.read_and_set_payload,
+}
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to concrete descendants of EventElement
+_DISPATCH_FOR_EVENT_ELEMENT: Mapping[
+    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.EventElement]
+] = {
+    "basicEventElement": _read_basic_event_element_as_sequence,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForBasicEventElement`
+_READ_AND_SET_DISPATCH_FOR_BASIC_EVENT_ELEMENT: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForBasicEventElement, Element, Iterator[Tuple[str, Element]]],
+        None,
+    ],
+] = {
+    "extensions": _ReaderAndSetterForBasicEventElement.read_and_set_extensions,
+    "category": _ReaderAndSetterForBasicEventElement.read_and_set_category,
+    "idShort": _ReaderAndSetterForBasicEventElement.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForBasicEventElement.read_and_set_display_name,
+    "description": _ReaderAndSetterForBasicEventElement.read_and_set_description,
+    "semanticId": _ReaderAndSetterForBasicEventElement.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForBasicEventElement.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForBasicEventElement.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForBasicEventElement.read_and_set_embedded_data_specifications,
+    "observed": _ReaderAndSetterForBasicEventElement.read_and_set_observed,
+    "direction": _ReaderAndSetterForBasicEventElement.read_and_set_direction,
+    "state": _ReaderAndSetterForBasicEventElement.read_and_set_state,
+    "messageTopic": _ReaderAndSetterForBasicEventElement.read_and_set_message_topic,
+    "messageBroker": _ReaderAndSetterForBasicEventElement.read_and_set_message_broker,
+    "lastUpdate": _ReaderAndSetterForBasicEventElement.read_and_set_last_update,
+    "minInterval": _ReaderAndSetterForBasicEventElement.read_and_set_min_interval,
+    "maxInterval": _ReaderAndSetterForBasicEventElement.read_and_set_max_interval,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForOperation`
+_READ_AND_SET_DISPATCH_FOR_OPERATION: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForOperation, Element, Iterator[Tuple[str, Element]]], None
+    ],
+] = {
+    "extensions": _ReaderAndSetterForOperation.read_and_set_extensions,
+    "category": _ReaderAndSetterForOperation.read_and_set_category,
+    "idShort": _ReaderAndSetterForOperation.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForOperation.read_and_set_display_name,
+    "description": _ReaderAndSetterForOperation.read_and_set_description,
+    "semanticId": _ReaderAndSetterForOperation.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForOperation.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForOperation.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForOperation.read_and_set_embedded_data_specifications,
+    "inputVariables": _ReaderAndSetterForOperation.read_and_set_input_variables,
+    "outputVariables": _ReaderAndSetterForOperation.read_and_set_output_variables,
+    "inoutputVariables": _ReaderAndSetterForOperation.read_and_set_inoutput_variables,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForOperationVariable`
+_READ_AND_SET_DISPATCH_FOR_OPERATION_VARIABLE: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForOperationVariable, Element, Iterator[Tuple[str, Element]]],
+        None,
+    ],
+] = {
+    "value": _ReaderAndSetterForOperationVariable.read_and_set_value,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForCapability`
+_READ_AND_SET_DISPATCH_FOR_CAPABILITY: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForCapability, Element, Iterator[Tuple[str, Element]]], None
+    ],
+] = {
+    "extensions": _ReaderAndSetterForCapability.read_and_set_extensions,
+    "category": _ReaderAndSetterForCapability.read_and_set_category,
+    "idShort": _ReaderAndSetterForCapability.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForCapability.read_and_set_display_name,
+    "description": _ReaderAndSetterForCapability.read_and_set_description,
+    "semanticId": _ReaderAndSetterForCapability.read_and_set_semantic_id,
+    "supplementalSemanticIds": _ReaderAndSetterForCapability.read_and_set_supplemental_semantic_ids,
+    "qualifiers": _ReaderAndSetterForCapability.read_and_set_qualifiers,
+    "embeddedDataSpecifications": _ReaderAndSetterForCapability.read_and_set_embedded_data_specifications,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForConceptDescription`
+_READ_AND_SET_DISPATCH_FOR_CONCEPT_DESCRIPTION: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForConceptDescription, Element, Iterator[Tuple[str, Element]]],
+        None,
+    ],
+] = {
+    "extensions": _ReaderAndSetterForConceptDescription.read_and_set_extensions,
+    "category": _ReaderAndSetterForConceptDescription.read_and_set_category,
+    "idShort": _ReaderAndSetterForConceptDescription.read_and_set_id_short,
+    "displayName": _ReaderAndSetterForConceptDescription.read_and_set_display_name,
+    "description": _ReaderAndSetterForConceptDescription.read_and_set_description,
+    "administration": _ReaderAndSetterForConceptDescription.read_and_set_administration,
+    "id": _ReaderAndSetterForConceptDescription.read_and_set_id,
+    "embeddedDataSpecifications": _ReaderAndSetterForConceptDescription.read_and_set_embedded_data_specifications,
+    "isCaseOf": _ReaderAndSetterForConceptDescription.read_and_set_is_case_of,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForReference`
+_READ_AND_SET_DISPATCH_FOR_REFERENCE: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForReference, Element, Iterator[Tuple[str, Element]]], None
+    ],
+] = {
+    "type": _ReaderAndSetterForReference.read_and_set_type,
+    "referredSemanticId": _ReaderAndSetterForReference.read_and_set_referred_semantic_id,
+    "keys": _ReaderAndSetterForReference.read_and_set_keys,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForKey`
+_READ_AND_SET_DISPATCH_FOR_KEY: Mapping[
+    str,
+    Callable[[_ReaderAndSetterForKey, Element, Iterator[Tuple[str, Element]]], None],
+] = {
+    "type": _ReaderAndSetterForKey.read_and_set_type,
+    "value": _ReaderAndSetterForKey.read_and_set_value,
+}
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to concrete descendants of AbstractLangString
+_DISPATCH_FOR_ABSTRACT_LANG_STRING: Mapping[
+    str,
+    Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.AbstractLangString],
+] = {
+    "langStringDefinitionTypeIec61360": _read_lang_string_definition_type_iec_61360_as_sequence,
+    "langStringNameType": _read_lang_string_name_type_as_sequence,
+    "langStringPreferredNameTypeIec61360": _read_lang_string_preferred_name_type_iec_61360_as_sequence,
+    "langStringShortNameTypeIec61360": _read_lang_string_short_name_type_iec_61360_as_sequence,
+    "langStringTextType": _read_lang_string_text_type_as_sequence,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForLangStringNameType`
+_READ_AND_SET_DISPATCH_FOR_LANG_STRING_NAME_TYPE: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForLangStringNameType, Element, Iterator[Tuple[str, Element]]],
+        None,
+    ],
+] = {
+    "language": _ReaderAndSetterForLangStringNameType.read_and_set_language,
+    "text": _ReaderAndSetterForLangStringNameType.read_and_set_text,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForLangStringTextType`
+_READ_AND_SET_DISPATCH_FOR_LANG_STRING_TEXT_TYPE: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForLangStringTextType, Element, Iterator[Tuple[str, Element]]],
+        None,
+    ],
+] = {
+    "language": _ReaderAndSetterForLangStringTextType.read_and_set_language,
+    "text": _ReaderAndSetterForLangStringTextType.read_and_set_text,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForEnvironment`
+_READ_AND_SET_DISPATCH_FOR_ENVIRONMENT: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForEnvironment, Element, Iterator[Tuple[str, Element]]], None
+    ],
+] = {
+    "assetAdministrationShells": _ReaderAndSetterForEnvironment.read_and_set_asset_administration_shells,
+    "submodels": _ReaderAndSetterForEnvironment.read_and_set_submodels,
+    "conceptDescriptions": _ReaderAndSetterForEnvironment.read_and_set_concept_descriptions,
+}
+
+
+#: Dispatch XML class names to read-as-sequence functions
+#: corresponding to concrete descendants of DataSpecificationContent
+_DISPATCH_FOR_DATA_SPECIFICATION_CONTENT: Mapping[
+    str,
+    Callable[
+        [Element, Iterator[Tuple[str, Element]]], aas_types.DataSpecificationContent
+    ],
+] = {
+    "dataSpecificationIec61360": _read_data_specification_iec_61360_as_sequence,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForEmbeddedDataSpecification`
+_READ_AND_SET_DISPATCH_FOR_EMBEDDED_DATA_SPECIFICATION: Mapping[
+    str,
+    Callable[
+        [
+            _ReaderAndSetterForEmbeddedDataSpecification,
+            Element,
+            Iterator[Tuple[str, Element]],
+        ],
+        None,
+    ],
+] = {
+    "dataSpecification": _ReaderAndSetterForEmbeddedDataSpecification.read_and_set_data_specification,
+    "dataSpecificationContent": _ReaderAndSetterForEmbeddedDataSpecification.read_and_set_data_specification_content,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForLevelType`
+_READ_AND_SET_DISPATCH_FOR_LEVEL_TYPE: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForLevelType, Element, Iterator[Tuple[str, Element]]], None
+    ],
+] = {
+    "min": _ReaderAndSetterForLevelType.read_and_set_min,
+    "nom": _ReaderAndSetterForLevelType.read_and_set_nom,
+    "typ": _ReaderAndSetterForLevelType.read_and_set_typ,
+    "max": _ReaderAndSetterForLevelType.read_and_set_max,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForValueReferencePair`
+_READ_AND_SET_DISPATCH_FOR_VALUE_REFERENCE_PAIR: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForValueReferencePair, Element, Iterator[Tuple[str, Element]]],
+        None,
+    ],
+] = {
+    "value": _ReaderAndSetterForValueReferencePair.read_and_set_value,
+    "valueId": _ReaderAndSetterForValueReferencePair.read_and_set_value_id,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForValueList`
+_READ_AND_SET_DISPATCH_FOR_VALUE_LIST: Mapping[
+    str,
+    Callable[
+        [_ReaderAndSetterForValueList, Element, Iterator[Tuple[str, Element]]], None
+    ],
+] = {
+    "valueReferencePairs": _ReaderAndSetterForValueList.read_and_set_value_reference_pairs,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForLangStringPreferredNameTypeIEC61360`
+_READ_AND_SET_DISPATCH_FOR_LANG_STRING_PREFERRED_NAME_TYPE_IEC_61360: Mapping[
+    str,
+    Callable[
+        [
+            _ReaderAndSetterForLangStringPreferredNameTypeIEC61360,
+            Element,
+            Iterator[Tuple[str, Element]],
+        ],
+        None,
+    ],
+] = {
+    "language": _ReaderAndSetterForLangStringPreferredNameTypeIEC61360.read_and_set_language,
+    "text": _ReaderAndSetterForLangStringPreferredNameTypeIEC61360.read_and_set_text,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForLangStringShortNameTypeIEC61360`
+_READ_AND_SET_DISPATCH_FOR_LANG_STRING_SHORT_NAME_TYPE_IEC_61360: Mapping[
+    str,
+    Callable[
+        [
+            _ReaderAndSetterForLangStringShortNameTypeIEC61360,
+            Element,
+            Iterator[Tuple[str, Element]],
+        ],
+        None,
+    ],
+] = {
+    "language": _ReaderAndSetterForLangStringShortNameTypeIEC61360.read_and_set_language,
+    "text": _ReaderAndSetterForLangStringShortNameTypeIEC61360.read_and_set_text,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForLangStringDefinitionTypeIEC61360`
+_READ_AND_SET_DISPATCH_FOR_LANG_STRING_DEFINITION_TYPE_IEC_61360: Mapping[
+    str,
+    Callable[
+        [
+            _ReaderAndSetterForLangStringDefinitionTypeIEC61360,
+            Element,
+            Iterator[Tuple[str, Element]],
+        ],
+        None,
+    ],
+] = {
+    "language": _ReaderAndSetterForLangStringDefinitionTypeIEC61360.read_and_set_language,
+    "text": _ReaderAndSetterForLangStringDefinitionTypeIEC61360.read_and_set_text,
+}
+
+
+#: Dispatch XML property name to read & set method in
+#: :py:class:`_ReaderAndSetterForDataSpecificationIEC61360`
+_READ_AND_SET_DISPATCH_FOR_DATA_SPECIFICATION_IEC_61360: Mapping[
+    str,
+    Callable[
+        [
+            _ReaderAndSetterForDataSpecificationIEC61360,
+            Element,
+            Iterator[Tuple[str, Element]],
+        ],
+        None,
+    ],
+] = {
+    "preferredName": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_preferred_name,
+    "shortName": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_short_name,
+    "unit": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_unit,
+    "unitId": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_unit_id,
+    "sourceOfDefinition": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_source_of_definition,
+    "symbol": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_symbol,
+    "dataType": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_data_type,
+    "definition": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_definition,
+    "valueFormat": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_value_format,
+    "valueList": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_value_list,
+    "value": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_value,
+    "levelType": _ReaderAndSetterForDataSpecificationIEC61360.read_and_set_level_type,
+}
+
+
+# endregion
+
+
+# region Serialization
+
+
+class _Serializer(aas_types.AbstractVisitor):
+    """Encode instances as XML and write them to :py:attr:`~stream`."""
+
+    #: Stream to be written to when we visit the instances
+    stream: Final[TextIO]
+
+    #: Method pointer to be invoked for writing the start element with or without
+    #: specifying a namespace (depending on the state of the serializer)
+    _write_start_element: Callable[[str], None]
+
+    #: Method pointer to be invoked for writing an empty element with or without
+    #: specifying a namespace (depending on the state of the serializer)
+    _write_empty_element: Callable[[str], None]
+
+    # NOTE (mristin, 2022-10-14):
+    # The serialization procedure is quite rigid. We leverage the specifics of
+    # the serialization procedure to optimize the code a bit.
+    #
+    # Namely, we model the writing of the XML elements as a state machine.
+    # The namespace is only specified for the very first element. All the subsequent
+    # elements will *not* have the namespace specified. We implement that behavior by
+    # using pointers to methods, as Python treats the methods as first-class citizens.
+    #
+    # The ``_write_start_element`` will point to
+    # ``_write_first_start_element_with_namespace`` on the *first* invocation.
+    # Afterwards, it will be redirected to ``_write_start_element_without_namespace``.
+    #
+    # Analogously for ``_write_empty_element``.
+    #
+    # Please see the implementation for the details, but this should give you at least
+    # a rough overview.
+
+    def _write_first_start_element_with_namespace(self, name: str) -> None:
+        """
+        Write the start element with the tag name :paramref:`name` and specify
+        its namespace.
+
+        The :py:attr:`~_write_start_element` is set to
+        :py:meth:`~_write_start_element_without_namespace` after the first invocation
+        of this method.
+
+        :param name: of the element tag. Expected to contain no XML special characters.
+        """
+        self.stream.write(f'<{name} xmlns="{NAMESPACE}">')
+
+        # NOTE (mristin, 2022-10-14):
+        # Any subsequence call to `_write_start_element` or `_write_empty_element`
+        # should not specify the namespace of the element as we specified now already
+        # specified it.
+        self._write_start_element = self._write_start_element_without_namespace
+        self._write_empty_element = self._write_empty_element_without_namespace
+
+    def _write_start_element_without_namespace(self, name: str) -> None:
+        """
+        Write the start element with the tag name :paramref:`name`.
+
+        The first element, written *before* this one, is expected to have been
+        already written with the namespace specified.
+
+        :param name: of the element tag. Expected to contain no XML special characters.
+        """
+        self.stream.write(f"<{name}>")
+
+    def _escape_and_write_text(self, text: str) -> None:
+        """
+        Escape :paramref:`text` for XML and write it.
+
+        :param text: to be escaped and written
+        """
+        # NOTE (mristin, 2022-10-14):
+        # We ran ``timeit`` on manual code which escaped XML special characters with
+        # a dictionary, and on another snippet which called three ``.replace()``.
+        # The code with ``.replace()`` was an order of magnitude faster on our computers.
+        self.stream.write(
+            text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
+        )
+
+    def _write_end_element(self, name: str) -> None:
+        """
+        Write the end element with the tag name :paramref:`name`.
+
+        :param name: of the element tag. Expected to contain no XML special characters.
+        """
+        self.stream.write(f"</{name}>")
+
+    def _write_first_empty_element_with_namespace(self, name: str) -> None:
+        """
+        Write the first (and only) empty element with the tag name :paramref:`name`.
+
+        No elements are expected to be written to the stream afterwards. The element
+        includes the namespace specification.
+
+        :param name: of the element tag. Expected to contain no XML special characters.
+        """
+        self.stream.write(f'<{name} xmlns="{NAMESPACE}"/>')
+        self._write_empty_element = self._rase_if_write_element_called_again
+        self._write_start_element = self._rase_if_write_element_called_again
+
+    def _rase_if_write_element_called_again(self, name: str) -> None:
+        raise AssertionError(
+            f"We expected to call ``_write_first_empty_element_with_namespace`` "
+            f"only once. This is an unexpected second call for writing "
+            f"an (empty or non-empty) element with the tag name: {name!r}"
+        )
+
+    def _write_empty_element_without_namespace(self, name: str) -> None:
+        """
+        Write the empty element with the tag name :paramref:`name`.
+
+        The call to this method is expected to occur *after* the enclosing element with
+        a specified namespace has been written.
+
+        :param name: of the element tag. Expected to contain no XML special characters.
+        """
+        self.stream.write(f"<{name}/>")
+
+    def _write_bool_property(self, name: str, value: bool) -> None:
+        """
+        Write the :paramref:`value` of a boolean property enclosed in
+        the :paramref:`name` element.
+
+        :param name: of the corresponding element tag
+        :param value: of the property
+        """
+        self._write_start_element(name)
+        self.stream.write("true" if value else "false")
+        self._write_end_element(name)
+
+    def _write_int_property(self, name: str, value: int) -> None:
+        """
+        Write the :paramref:`value` of an integer property enclosed in
+        the :paramref:`name` element.
+
+        :param name: of the corresponding element tag
+        :param value: of the property
+        """
+        self._write_start_element(name)
+        self.stream.write(str(value))
+        self._write_end_element(name)
+
+    def _write_float_property(self, name: str, value: float) -> None:
+        """
+        Write the :paramref:`value` of a floating-point property enclosed in
+        the :paramref:`name` element.
+
+        :param name: of the corresponding element tag
+        :param value: of the property
+        """
+        self._write_start_element(name)
+
+        if value == math.inf:
+            self.stream.write("INF")
+        elif value == -math.inf:
+            self.stream.write("-INF")
+        elif math.isnan(value):
+            self.stream.write("NaN")
+        elif value == 0:
+            if math.copysign(1.0, value) < 0.0:
+                self.stream.write("-0.0")
+            else:
+                self.stream.write("0.0")
+        else:
+            self.stream.write(str(value))
+
+    def _write_str_property(self, name: str, value: str) -> None:
+        """
+        Write the :paramref:`value` of a string property enclosed in
+        the :paramref:`name` element.
+
+        :param name: of the corresponding element tag
+        :param value: of the property
+        """
+        self._write_start_element(name)
+        self._escape_and_write_text(value)
+        self._write_end_element(name)
+
+    def _write_bytes_property(self, name: str, value: bytes) -> None:
+        """
+        Write the :paramref:`value` of a binary-content property enclosed in
+        the :paramref:`name` element.
+
+        :param name: of the corresponding element tag
+        :param value: of the property
+        """
+        self._write_start_element(name)
+
+        # NOTE (mristin, 2022-10-14):
+        # We need to decode the result of the base64-encoding to ASCII since we are
+        # writing to an XML *text* stream. ``base64.b64encode(.)`` gives us bytes,
+        # not a string.
+        encoded = base64.b64encode(value).decode("ascii")
+
+        # NOTE (mristin, 2022-10-14):
+        # Base64 alphabet excludes ``<``, ``>`` and ``&``, so we can directly
+        # write the ``encoded`` content to the stream as XML text.
+        #
+        # See: https://datatracker.ietf.org/doc/html/rfc4648#section-4
+        self.stream.write(encoded)
+        self._write_end_element(name)
+
+    def __init__(self, stream: TextIO) -> None:
+        """
+        Initialize the visitor to write to :paramref:`stream`.
+
+        The first element will include the :py:attr:`~.NAMESPACE`. Every other
+        element will not have the namespace specified.
+
+        :param stream: where to write to
+        """
+        self.stream = stream
+        self._write_start_element = self._write_first_start_element_with_namespace
+        self._write_empty_element = self._write_first_empty_element_with_namespace
+
+    def _write_extension_as_sequence(self, that: aas_types.Extension) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for an_item in that.supplemental_semantic_ids:
+                    self.visit(an_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        self._write_str_property("name", that.name)
+
+        if that.value_type is not None:
+            self._write_str_property("valueType", that.value_type.value)
+
+        if that.value is not None:
+            self._write_str_property("value", that.value)
+
+        if that.refers_to is not None:
+            if len(that.refers_to) == 0:
+                self._write_empty_element("refersTo")
+            else:
+                self._write_start_element("refersTo")
+                for another_item in that.refers_to:
+                    self.visit(another_item)
+                self._write_end_element("refersTo")
+
+    def visit_extension(self, that: aas_types.Extension) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("extension")
+        self._write_extension_as_sequence(that)
+        self._write_end_element("extension")
+
+    def _write_administrative_information_as_sequence(
+        self, that: aas_types.AdministrativeInformation
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for an_item in that.embedded_data_specifications:
+                    self.visit(an_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        if that.version is not None:
+            self._write_str_property("version", that.version)
+
+        if that.revision is not None:
+            self._write_str_property("revision", that.revision)
+
+        if that.creator is not None:
+            self._write_start_element("creator")
+            self._write_reference_as_sequence(that.creator)
+            self._write_end_element("creator")
+
+        if that.template_id is not None:
+            self._write_str_property("templateId", that.template_id)
+
+    def visit_administrative_information(
+        self, that: aas_types.AdministrativeInformation
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        # We optimize for the case where all the optional properties are not set,
+        # so that we can simply output an empty element.
+        if (
+            that.embedded_data_specifications is None
+            and that.version is None
+            and that.revision is None
+            and that.creator is None
+            and that.template_id is None
+        ):
+            self._write_empty_element("administrativeInformation")
+        else:
+            self._write_start_element("administrativeInformation")
+            self._write_administrative_information_as_sequence(that)
+            self._write_end_element("administrativeInformation")
+
+    def _write_qualifier_as_sequence(self, that: aas_types.Qualifier) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for an_item in that.supplemental_semantic_ids:
+                    self.visit(an_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.kind is not None:
+            self._write_str_property("kind", that.kind.value)
+
+        self._write_str_property("type", that.type)
+
+        self._write_str_property("valueType", that.value_type.value)
+
+        if that.value is not None:
+            self._write_str_property("value", that.value)
+
+        if that.value_id is not None:
+            self._write_start_element("valueId")
+            self._write_reference_as_sequence(that.value_id)
+            self._write_end_element("valueId")
+
+    def visit_qualifier(self, that: aas_types.Qualifier) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("qualifier")
+        self._write_qualifier_as_sequence(that)
+        self._write_end_element("qualifier")
+
+    def _write_asset_administration_shell_as_sequence(
+        self, that: aas_types.AssetAdministrationShell
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.administration is not None:
+            the_administration = that.administration
+            # We optimize for the case where all the optional properties are not set,
+            # so that we can simply output an empty element.
+            if (
+                the_administration.embedded_data_specifications is None
+                and the_administration.version is None
+                and the_administration.revision is None
+                and the_administration.creator is None
+                and the_administration.template_id is None
+            ):
+                self._write_empty_element("administration")
+            else:
+                self._write_start_element("administration")
+                self._write_administrative_information_as_sequence(the_administration)
+                self._write_end_element("administration")
+
+        self._write_str_property("id", that.id)
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        if that.derived_from is not None:
+            self._write_start_element("derivedFrom")
+            self._write_reference_as_sequence(that.derived_from)
+            self._write_end_element("derivedFrom")
+
+        self._write_start_element("assetInformation")
+        self._write_asset_information_as_sequence(that.asset_information)
+        self._write_end_element("assetInformation")
+
+        if that.submodels is not None:
+            if len(that.submodels) == 0:
+                self._write_empty_element("submodels")
+            else:
+                self._write_start_element("submodels")
+                for yet_yet_yet_another_item in that.submodels:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("submodels")
+
+    def visit_asset_administration_shell(
+        self, that: aas_types.AssetAdministrationShell
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("assetAdministrationShell")
+        self._write_asset_administration_shell_as_sequence(that)
+        self._write_end_element("assetAdministrationShell")
+
+    def _write_asset_information_as_sequence(
+        self, that: aas_types.AssetInformation
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_str_property("assetKind", that.asset_kind.value)
+
+        if that.global_asset_id is not None:
+            self._write_str_property("globalAssetId", that.global_asset_id)
+
+        if that.specific_asset_ids is not None:
+            if len(that.specific_asset_ids) == 0:
+                self._write_empty_element("specificAssetIds")
+            else:
+                self._write_start_element("specificAssetIds")
+                for an_item in that.specific_asset_ids:
+                    self.visit(an_item)
+                self._write_end_element("specificAssetIds")
+
+        if that.asset_type is not None:
+            self._write_str_property("assetType", that.asset_type)
+
+        if that.default_thumbnail is not None:
+            self._write_start_element("defaultThumbnail")
+            self._write_resource_as_sequence(that.default_thumbnail)
+            self._write_end_element("defaultThumbnail")
+
+    def visit_asset_information(self, that: aas_types.AssetInformation) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("assetInformation")
+        self._write_asset_information_as_sequence(that)
+        self._write_end_element("assetInformation")
+
+    def _write_resource_as_sequence(self, that: aas_types.Resource) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_str_property("path", that.path)
+
+        if that.content_type is not None:
+            self._write_str_property("contentType", that.content_type)
+
+    def visit_resource(self, that: aas_types.Resource) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("resource")
+        self._write_resource_as_sequence(that)
+        self._write_end_element("resource")
+
+    def _write_specific_asset_id_as_sequence(
+        self, that: aas_types.SpecificAssetID
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for an_item in that.supplemental_semantic_ids:
+                    self.visit(an_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        self._write_str_property("name", that.name)
+
+        self._write_str_property("value", that.value)
+
+        if that.external_subject_id is not None:
+            self._write_start_element("externalSubjectId")
+            self._write_reference_as_sequence(that.external_subject_id)
+            self._write_end_element("externalSubjectId")
+
+    def visit_specific_asset_id(self, that: aas_types.SpecificAssetID) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("specificAssetId")
+        self._write_specific_asset_id_as_sequence(that)
+        self._write_end_element("specificAssetId")
+
+    def _write_submodel_as_sequence(self, that: aas_types.Submodel) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.administration is not None:
+            the_administration = that.administration
+            # We optimize for the case where all the optional properties are not set,
+            # so that we can simply output an empty element.
+            if (
+                the_administration.embedded_data_specifications is None
+                and the_administration.version is None
+                and the_administration.revision is None
+                and the_administration.creator is None
+                and the_administration.template_id is None
+            ):
+                self._write_empty_element("administration")
+            else:
+                self._write_start_element("administration")
+                self._write_administrative_information_as_sequence(the_administration)
+                self._write_end_element("administration")
+
+        self._write_str_property("id", that.id)
+
+        if that.kind is not None:
+            self._write_str_property("kind", that.kind.value)
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        if that.submodel_elements is not None:
+            if len(that.submodel_elements) == 0:
+                self._write_empty_element("submodelElements")
+            else:
+                self._write_start_element("submodelElements")
+                for yet_yet_yet_yet_yet_another_item in that.submodel_elements:
+                    self.visit(yet_yet_yet_yet_yet_another_item)
+                self._write_end_element("submodelElements")
+
+    def visit_submodel(self, that: aas_types.Submodel) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("submodel")
+        self._write_submodel_as_sequence(that)
+        self._write_end_element("submodel")
+
+    def _write_relationship_element_as_sequence(
+        self, that: aas_types.RelationshipElement
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        self._write_start_element("first")
+        self._write_reference_as_sequence(that.first)
+        self._write_end_element("first")
+
+        self._write_start_element("second")
+        self._write_reference_as_sequence(that.second)
+        self._write_end_element("second")
+
+    def visit_relationship_element(self, that: aas_types.RelationshipElement) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("relationshipElement")
+        self._write_relationship_element_as_sequence(that)
+        self._write_end_element("relationshipElement")
+
+    def _write_submodel_element_list_as_sequence(
+        self, that: aas_types.SubmodelElementList
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        if that.order_relevant is not None:
+            self._write_bool_property("orderRelevant", that.order_relevant)
+
+        if that.semantic_id_list_element is not None:
+            self._write_start_element("semanticIdListElement")
+            self._write_reference_as_sequence(that.semantic_id_list_element)
+            self._write_end_element("semanticIdListElement")
+
+        self._write_str_property(
+            "typeValueListElement", that.type_value_list_element.value
+        )
+
+        if that.value_type_list_element is not None:
+            self._write_str_property(
+                "valueTypeListElement", that.value_type_list_element.value
+            )
+
+        if that.value is not None:
+            if len(that.value) == 0:
+                self._write_empty_element("value")
+            else:
+                self._write_start_element("value")
+                for yet_yet_yet_yet_yet_another_item in that.value:
+                    self.visit(yet_yet_yet_yet_yet_another_item)
+                self._write_end_element("value")
+
+    def visit_submodel_element_list(self, that: aas_types.SubmodelElementList) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("submodelElementList")
+        self._write_submodel_element_list_as_sequence(that)
+        self._write_end_element("submodelElementList")
+
+    def _write_submodel_element_collection_as_sequence(
+        self, that: aas_types.SubmodelElementCollection
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        if that.value is not None:
+            if len(that.value) == 0:
+                self._write_empty_element("value")
+            else:
+                self._write_start_element("value")
+                for yet_yet_yet_yet_yet_another_item in that.value:
+                    self.visit(yet_yet_yet_yet_yet_another_item)
+                self._write_end_element("value")
+
+    def visit_submodel_element_collection(
+        self, that: aas_types.SubmodelElementCollection
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        # We optimize for the case where all the optional properties are not set,
+        # so that we can simply output an empty element.
+        if (
+            that.extensions is None
+            and that.category is None
+            and that.id_short is None
+            and that.display_name is None
+            and that.description is None
+            and that.semantic_id is None
+            and that.supplemental_semantic_ids is None
+            and that.qualifiers is None
+            and that.embedded_data_specifications is None
+            and that.value is None
+        ):
+            self._write_empty_element("submodelElementCollection")
+        else:
+            self._write_start_element("submodelElementCollection")
+            self._write_submodel_element_collection_as_sequence(that)
+            self._write_end_element("submodelElementCollection")
+
+    def _write_property_as_sequence(self, that: aas_types.Property) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        self._write_str_property("valueType", that.value_type.value)
+
+        if that.value is not None:
+            self._write_str_property("value", that.value)
+
+        if that.value_id is not None:
+            self._write_start_element("valueId")
+            self._write_reference_as_sequence(that.value_id)
+            self._write_end_element("valueId")
+
+    def visit_property(self, that: aas_types.Property) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("property")
+        self._write_property_as_sequence(that)
+        self._write_end_element("property")
+
+    def _write_multi_language_property_as_sequence(
+        self, that: aas_types.MultiLanguageProperty
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        if that.value is not None:
+            if len(that.value) == 0:
+                self._write_empty_element("value")
+            else:
+                self._write_start_element("value")
+                for yet_yet_yet_yet_yet_another_item in that.value:
+                    self.visit(yet_yet_yet_yet_yet_another_item)
+                self._write_end_element("value")
+
+        if that.value_id is not None:
+            self._write_start_element("valueId")
+            self._write_reference_as_sequence(that.value_id)
+            self._write_end_element("valueId")
+
+    def visit_multi_language_property(
+        self, that: aas_types.MultiLanguageProperty
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        # We optimize for the case where all the optional properties are not set,
+        # so that we can simply output an empty element.
+        if (
+            that.extensions is None
+            and that.category is None
+            and that.id_short is None
+            and that.display_name is None
+            and that.description is None
+            and that.semantic_id is None
+            and that.supplemental_semantic_ids is None
+            and that.qualifiers is None
+            and that.embedded_data_specifications is None
+            and that.value is None
+            and that.value_id is None
+        ):
+            self._write_empty_element("multiLanguageProperty")
+        else:
+            self._write_start_element("multiLanguageProperty")
+            self._write_multi_language_property_as_sequence(that)
+            self._write_end_element("multiLanguageProperty")
+
+    def _write_range_as_sequence(self, that: aas_types.Range) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        self._write_str_property("valueType", that.value_type.value)
+
+        if that.min is not None:
+            self._write_str_property("min", that.min)
+
+        if that.max is not None:
+            self._write_str_property("max", that.max)
+
+    def visit_range(self, that: aas_types.Range) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("range")
+        self._write_range_as_sequence(that)
+        self._write_end_element("range")
+
+    def _write_reference_element_as_sequence(
+        self, that: aas_types.ReferenceElement
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        if that.value is not None:
+            self._write_start_element("value")
+            self._write_reference_as_sequence(that.value)
+            self._write_end_element("value")
+
+    def visit_reference_element(self, that: aas_types.ReferenceElement) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        # We optimize for the case where all the optional properties are not set,
+        # so that we can simply output an empty element.
+        if (
+            that.extensions is None
+            and that.category is None
+            and that.id_short is None
+            and that.display_name is None
+            and that.description is None
+            and that.semantic_id is None
+            and that.supplemental_semantic_ids is None
+            and that.qualifiers is None
+            and that.embedded_data_specifications is None
+            and that.value is None
+        ):
+            self._write_empty_element("referenceElement")
+        else:
+            self._write_start_element("referenceElement")
+            self._write_reference_element_as_sequence(that)
+            self._write_end_element("referenceElement")
+
+    def _write_blob_as_sequence(self, that: aas_types.Blob) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        if that.value is not None:
+            self._write_bytes_property("value", that.value)
+
+        self._write_str_property("contentType", that.content_type)
+
+    def visit_blob(self, that: aas_types.Blob) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("blob")
+        self._write_blob_as_sequence(that)
+        self._write_end_element("blob")
+
+    def _write_file_as_sequence(self, that: aas_types.File) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        if that.value is not None:
+            self._write_str_property("value", that.value)
+
+        self._write_str_property("contentType", that.content_type)
+
+    def visit_file(self, that: aas_types.File) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("file")
+        self._write_file_as_sequence(that)
+        self._write_end_element("file")
+
+    def _write_annotated_relationship_element_as_sequence(
+        self, that: aas_types.AnnotatedRelationshipElement
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        self._write_start_element("first")
+        self._write_reference_as_sequence(that.first)
+        self._write_end_element("first")
+
+        self._write_start_element("second")
+        self._write_reference_as_sequence(that.second)
+        self._write_end_element("second")
+
+        if that.annotations is not None:
+            if len(that.annotations) == 0:
+                self._write_empty_element("annotations")
+            else:
+                self._write_start_element("annotations")
+                for yet_yet_yet_yet_yet_another_item in that.annotations:
+                    self.visit(yet_yet_yet_yet_yet_another_item)
+                self._write_end_element("annotations")
+
+    def visit_annotated_relationship_element(
+        self, that: aas_types.AnnotatedRelationshipElement
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("annotatedRelationshipElement")
+        self._write_annotated_relationship_element_as_sequence(that)
+        self._write_end_element("annotatedRelationshipElement")
+
+    def _write_entity_as_sequence(self, that: aas_types.Entity) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        if that.statements is not None:
+            if len(that.statements) == 0:
+                self._write_empty_element("statements")
+            else:
+                self._write_start_element("statements")
+                for yet_yet_yet_yet_yet_another_item in that.statements:
+                    self.visit(yet_yet_yet_yet_yet_another_item)
+                self._write_end_element("statements")
+
+        self._write_str_property("entityType", that.entity_type.value)
+
+        if that.global_asset_id is not None:
+            self._write_str_property("globalAssetId", that.global_asset_id)
+
+        if that.specific_asset_ids is not None:
+            if len(that.specific_asset_ids) == 0:
+                self._write_empty_element("specificAssetIds")
+            else:
+                self._write_start_element("specificAssetIds")
+                for yet_yet_yet_yet_yet_yet_another_item in that.specific_asset_ids:
+                    self.visit(yet_yet_yet_yet_yet_yet_another_item)
+                self._write_end_element("specificAssetIds")
+
+    def visit_entity(self, that: aas_types.Entity) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("entity")
+        self._write_entity_as_sequence(that)
+        self._write_end_element("entity")
+
+    def _write_event_payload_as_sequence(self, that: aas_types.EventPayload) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("source")
+        self._write_reference_as_sequence(that.source)
+        self._write_end_element("source")
+
+        if that.source_semantic_id is not None:
+            self._write_start_element("sourceSemanticId")
+            self._write_reference_as_sequence(that.source_semantic_id)
+            self._write_end_element("sourceSemanticId")
+
+        self._write_start_element("observableReference")
+        self._write_reference_as_sequence(that.observable_reference)
+        self._write_end_element("observableReference")
+
+        if that.observable_semantic_id is not None:
+            self._write_start_element("observableSemanticId")
+            self._write_reference_as_sequence(that.observable_semantic_id)
+            self._write_end_element("observableSemanticId")
+
+        if that.topic is not None:
+            self._write_str_property("topic", that.topic)
+
+        if that.subject_id is not None:
+            self._write_start_element("subjectId")
+            self._write_reference_as_sequence(that.subject_id)
+            self._write_end_element("subjectId")
+
+        self._write_str_property("timeStamp", that.time_stamp)
+
+        if that.payload is not None:
+            self._write_bytes_property("payload", that.payload)
+
+    def visit_event_payload(self, that: aas_types.EventPayload) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("eventPayload")
+        self._write_event_payload_as_sequence(that)
+        self._write_end_element("eventPayload")
+
+    def _write_basic_event_element_as_sequence(
+        self, that: aas_types.BasicEventElement
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        self._write_start_element("observed")
+        self._write_reference_as_sequence(that.observed)
+        self._write_end_element("observed")
+
+        self._write_str_property("direction", that.direction.value)
+
+        self._write_str_property("state", that.state.value)
+
+        if that.message_topic is not None:
+            self._write_str_property("messageTopic", that.message_topic)
+
+        if that.message_broker is not None:
+            self._write_start_element("messageBroker")
+            self._write_reference_as_sequence(that.message_broker)
+            self._write_end_element("messageBroker")
+
+        if that.last_update is not None:
+            self._write_str_property("lastUpdate", that.last_update)
+
+        if that.min_interval is not None:
+            self._write_str_property("minInterval", that.min_interval)
+
+        if that.max_interval is not None:
+            self._write_str_property("maxInterval", that.max_interval)
+
+    def visit_basic_event_element(self, that: aas_types.BasicEventElement) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("basicEventElement")
+        self._write_basic_event_element_as_sequence(that)
+        self._write_end_element("basicEventElement")
+
+    def _write_operation_as_sequence(self, that: aas_types.Operation) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        if that.input_variables is not None:
+            if len(that.input_variables) == 0:
+                self._write_empty_element("inputVariables")
+            else:
+                self._write_start_element("inputVariables")
+                for yet_yet_yet_yet_yet_another_item in that.input_variables:
+                    self.visit(yet_yet_yet_yet_yet_another_item)
+                self._write_end_element("inputVariables")
+
+        if that.output_variables is not None:
+            if len(that.output_variables) == 0:
+                self._write_empty_element("outputVariables")
+            else:
+                self._write_start_element("outputVariables")
+                for yet_yet_yet_yet_yet_yet_another_item in that.output_variables:
+                    self.visit(yet_yet_yet_yet_yet_yet_another_item)
+                self._write_end_element("outputVariables")
+
+        if that.inoutput_variables is not None:
+            if len(that.inoutput_variables) == 0:
+                self._write_empty_element("inoutputVariables")
+            else:
+                self._write_start_element("inoutputVariables")
+                for yet_yet_yet_yet_yet_yet_yet_another_item in that.inoutput_variables:
+                    self.visit(yet_yet_yet_yet_yet_yet_yet_another_item)
+                self._write_end_element("inoutputVariables")
+
+    def visit_operation(self, that: aas_types.Operation) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        # We optimize for the case where all the optional properties are not set,
+        # so that we can simply output an empty element.
+        if (
+            that.extensions is None
+            and that.category is None
+            and that.id_short is None
+            and that.display_name is None
+            and that.description is None
+            and that.semantic_id is None
+            and that.supplemental_semantic_ids is None
+            and that.qualifiers is None
+            and that.embedded_data_specifications is None
+            and that.input_variables is None
+            and that.output_variables is None
+            and that.inoutput_variables is None
+        ):
+            self._write_empty_element("operation")
+        else:
+            self._write_start_element("operation")
+            self._write_operation_as_sequence(that)
+            self._write_end_element("operation")
+
+    def _write_operation_variable_as_sequence(
+        self, that: aas_types.OperationVariable
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("value")
+        self.visit(that.value)
+        self._write_end_element("value")
+
+    def visit_operation_variable(self, that: aas_types.OperationVariable) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("operationVariable")
+        self._write_operation_variable_as_sequence(that)
+        self._write_end_element("operationVariable")
+
+    def _write_capability_as_sequence(self, that: aas_types.Capability) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.semantic_id is not None:
+            self._write_start_element("semanticId")
+            self._write_reference_as_sequence(that.semantic_id)
+            self._write_end_element("semanticId")
+
+        if that.supplemental_semantic_ids is not None:
+            if len(that.supplemental_semantic_ids) == 0:
+                self._write_empty_element("supplementalSemanticIds")
+            else:
+                self._write_start_element("supplementalSemanticIds")
+                for yet_yet_another_item in that.supplemental_semantic_ids:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("supplementalSemanticIds")
+
+        if that.qualifiers is not None:
+            if len(that.qualifiers) == 0:
+                self._write_empty_element("qualifiers")
+            else:
+                self._write_start_element("qualifiers")
+                for yet_yet_yet_another_item in that.qualifiers:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("qualifiers")
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+    def visit_capability(self, that: aas_types.Capability) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        # We optimize for the case where all the optional properties are not set,
+        # so that we can simply output an empty element.
+        if (
+            that.extensions is None
+            and that.category is None
+            and that.id_short is None
+            and that.display_name is None
+            and that.description is None
+            and that.semantic_id is None
+            and that.supplemental_semantic_ids is None
+            and that.qualifiers is None
+            and that.embedded_data_specifications is None
+        ):
+            self._write_empty_element("capability")
+        else:
+            self._write_start_element("capability")
+            self._write_capability_as_sequence(that)
+            self._write_end_element("capability")
+
+    def _write_concept_description_as_sequence(
+        self, that: aas_types.ConceptDescription
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.extensions is not None:
+            if len(that.extensions) == 0:
+                self._write_empty_element("extensions")
+            else:
+                self._write_start_element("extensions")
+                for an_item in that.extensions:
+                    self.visit(an_item)
+                self._write_end_element("extensions")
+
+        if that.category is not None:
+            self._write_str_property("category", that.category)
+
+        if that.id_short is not None:
+            self._write_str_property("idShort", that.id_short)
+
+        if that.display_name is not None:
+            if len(that.display_name) == 0:
+                self._write_empty_element("displayName")
+            else:
+                self._write_start_element("displayName")
+                for another_item in that.display_name:
+                    self.visit(another_item)
+                self._write_end_element("displayName")
+
+        if that.description is not None:
+            if len(that.description) == 0:
+                self._write_empty_element("description")
+            else:
+                self._write_start_element("description")
+                for yet_another_item in that.description:
+                    self.visit(yet_another_item)
+                self._write_end_element("description")
+
+        if that.administration is not None:
+            the_administration = that.administration
+            # We optimize for the case where all the optional properties are not set,
+            # so that we can simply output an empty element.
+            if (
+                the_administration.embedded_data_specifications is None
+                and the_administration.version is None
+                and the_administration.revision is None
+                and the_administration.creator is None
+                and the_administration.template_id is None
+            ):
+                self._write_empty_element("administration")
+            else:
+                self._write_start_element("administration")
+                self._write_administrative_information_as_sequence(the_administration)
+                self._write_end_element("administration")
+
+        self._write_str_property("id", that.id)
+
+        if that.embedded_data_specifications is not None:
+            if len(that.embedded_data_specifications) == 0:
+                self._write_empty_element("embeddedDataSpecifications")
+            else:
+                self._write_start_element("embeddedDataSpecifications")
+                for yet_yet_another_item in that.embedded_data_specifications:
+                    self.visit(yet_yet_another_item)
+                self._write_end_element("embeddedDataSpecifications")
+
+        if that.is_case_of is not None:
+            if len(that.is_case_of) == 0:
+                self._write_empty_element("isCaseOf")
+            else:
+                self._write_start_element("isCaseOf")
+                for yet_yet_yet_another_item in that.is_case_of:
+                    self.visit(yet_yet_yet_another_item)
+                self._write_end_element("isCaseOf")
+
+    def visit_concept_description(self, that: aas_types.ConceptDescription) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("conceptDescription")
+        self._write_concept_description_as_sequence(that)
+        self._write_end_element("conceptDescription")
+
+    def _write_reference_as_sequence(self, that: aas_types.Reference) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_str_property("type", that.type.value)
+
+        if that.referred_semantic_id is not None:
+            self._write_start_element("referredSemanticId")
+            self._write_reference_as_sequence(that.referred_semantic_id)
+            self._write_end_element("referredSemanticId")
+
+        if len(that.keys) == 0:
+            self._write_empty_element("keys")
+        else:
+            self._write_start_element("keys")
+            for an_item in that.keys:
+                self.visit(an_item)
+            self._write_end_element("keys")
+
+    def visit_reference(self, that: aas_types.Reference) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("reference")
+        self._write_reference_as_sequence(that)
+        self._write_end_element("reference")
+
+    def _write_key_as_sequence(self, that: aas_types.Key) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_str_property("type", that.type.value)
+
+        self._write_str_property("value", that.value)
+
+    def visit_key(self, that: aas_types.Key) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("key")
+        self._write_key_as_sequence(that)
+        self._write_end_element("key")
+
+    def _write_lang_string_name_type_as_sequence(
+        self, that: aas_types.LangStringNameType
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_str_property("language", that.language)
+
+        self._write_str_property("text", that.text)
+
+    def visit_lang_string_name_type(self, that: aas_types.LangStringNameType) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("langStringNameType")
+        self._write_lang_string_name_type_as_sequence(that)
+        self._write_end_element("langStringNameType")
+
+    def _write_lang_string_text_type_as_sequence(
+        self, that: aas_types.LangStringTextType
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_str_property("language", that.language)
+
+        self._write_str_property("text", that.text)
+
+    def visit_lang_string_text_type(self, that: aas_types.LangStringTextType) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("langStringTextType")
+        self._write_lang_string_text_type_as_sequence(that)
+        self._write_end_element("langStringTextType")
+
+    def _write_environment_as_sequence(self, that: aas_types.Environment) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if that.asset_administration_shells is not None:
+            if len(that.asset_administration_shells) == 0:
+                self._write_empty_element("assetAdministrationShells")
+            else:
+                self._write_start_element("assetAdministrationShells")
+                for an_item in that.asset_administration_shells:
+                    self.visit(an_item)
+                self._write_end_element("assetAdministrationShells")
+
+        if that.submodels is not None:
+            if len(that.submodels) == 0:
+                self._write_empty_element("submodels")
+            else:
+                self._write_start_element("submodels")
+                for another_item in that.submodels:
+                    self.visit(another_item)
+                self._write_end_element("submodels")
+
+        if that.concept_descriptions is not None:
+            if len(that.concept_descriptions) == 0:
+                self._write_empty_element("conceptDescriptions")
+            else:
+                self._write_start_element("conceptDescriptions")
+                for yet_another_item in that.concept_descriptions:
+                    self.visit(yet_another_item)
+                self._write_end_element("conceptDescriptions")
+
+    def visit_environment(self, that: aas_types.Environment) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        # We optimize for the case where all the optional properties are not set,
+        # so that we can simply output an empty element.
+        if (
+            that.asset_administration_shells is None
+            and that.submodels is None
+            and that.concept_descriptions is None
+        ):
+            self._write_empty_element("environment")
+        else:
+            self._write_start_element("environment")
+            self._write_environment_as_sequence(that)
+            self._write_end_element("environment")
+
+    def _write_embedded_data_specification_as_sequence(
+        self, that: aas_types.EmbeddedDataSpecification
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("dataSpecification")
+        self._write_reference_as_sequence(that.data_specification)
+        self._write_end_element("dataSpecification")
+
+        self._write_start_element("dataSpecificationContent")
+        self.visit(that.data_specification_content)
+        self._write_end_element("dataSpecificationContent")
+
+    def visit_embedded_data_specification(
+        self, that: aas_types.EmbeddedDataSpecification
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("embeddedDataSpecification")
+        self._write_embedded_data_specification_as_sequence(that)
+        self._write_end_element("embeddedDataSpecification")
+
+    def _write_level_type_as_sequence(self, that: aas_types.LevelType) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_bool_property("min", that.min)
+
+        self._write_bool_property("nom", that.nom)
+
+        self._write_bool_property("typ", that.typ)
+
+        self._write_bool_property("max", that.max)
+
+    def visit_level_type(self, that: aas_types.LevelType) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("levelType")
+        self._write_level_type_as_sequence(that)
+        self._write_end_element("levelType")
+
+    def _write_value_reference_pair_as_sequence(
+        self, that: aas_types.ValueReferencePair
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_str_property("value", that.value)
+
+        self._write_start_element("valueId")
+        self._write_reference_as_sequence(that.value_id)
+        self._write_end_element("valueId")
+
+    def visit_value_reference_pair(self, that: aas_types.ValueReferencePair) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("valueReferencePair")
+        self._write_value_reference_pair_as_sequence(that)
+        self._write_end_element("valueReferencePair")
+
+    def _write_value_list_as_sequence(self, that: aas_types.ValueList) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if len(that.value_reference_pairs) == 0:
+            self._write_empty_element("valueReferencePairs")
+        else:
+            self._write_start_element("valueReferencePairs")
+            for an_item in that.value_reference_pairs:
+                self.visit(an_item)
+            self._write_end_element("valueReferencePairs")
+
+    def visit_value_list(self, that: aas_types.ValueList) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("valueList")
+        self._write_value_list_as_sequence(that)
+        self._write_end_element("valueList")
+
+    def _write_lang_string_preferred_name_type_iec_61360_as_sequence(
+        self, that: aas_types.LangStringPreferredNameTypeIEC61360
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_str_property("language", that.language)
+
+        self._write_str_property("text", that.text)
+
+    def visit_lang_string_preferred_name_type_iec_61360(
+        self, that: aas_types.LangStringPreferredNameTypeIEC61360
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("langStringPreferredNameTypeIec61360")
+        self._write_lang_string_preferred_name_type_iec_61360_as_sequence(that)
+        self._write_end_element("langStringPreferredNameTypeIec61360")
+
+    def _write_lang_string_short_name_type_iec_61360_as_sequence(
+        self, that: aas_types.LangStringShortNameTypeIEC61360
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_str_property("language", that.language)
+
+        self._write_str_property("text", that.text)
+
+    def visit_lang_string_short_name_type_iec_61360(
+        self, that: aas_types.LangStringShortNameTypeIEC61360
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("langStringShortNameTypeIec61360")
+        self._write_lang_string_short_name_type_iec_61360_as_sequence(that)
+        self._write_end_element("langStringShortNameTypeIec61360")
+
+    def _write_lang_string_definition_type_iec_61360_as_sequence(
+        self, that: aas_types.LangStringDefinitionTypeIEC61360
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        self._write_str_property("language", that.language)
+
+        self._write_str_property("text", that.text)
+
+    def visit_lang_string_definition_type_iec_61360(
+        self, that: aas_types.LangStringDefinitionTypeIEC61360
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("langStringDefinitionTypeIec61360")
+        self._write_lang_string_definition_type_iec_61360_as_sequence(that)
+        self._write_end_element("langStringDefinitionTypeIec61360")
+
+    def _write_data_specification_iec_61360_as_sequence(
+        self, that: aas_types.DataSpecificationIEC61360
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
+        XML elements.
+
+        Each element in the sequence corresponds to a property. If no properties
+        are set, nothing is written to the :py:attr:`~stream`.
+
+        :param that: instance to be serialized
+        """
+        if len(that.preferred_name) == 0:
+            self._write_empty_element("preferredName")
+        else:
+            self._write_start_element("preferredName")
+            for an_item in that.preferred_name:
+                self.visit(an_item)
+            self._write_end_element("preferredName")
+
+        if that.short_name is not None:
+            if len(that.short_name) == 0:
+                self._write_empty_element("shortName")
+            else:
+                self._write_start_element("shortName")
+                for another_item in that.short_name:
+                    self.visit(another_item)
+                self._write_end_element("shortName")
+
+        if that.unit is not None:
+            self._write_str_property("unit", that.unit)
+
+        if that.unit_id is not None:
+            self._write_start_element("unitId")
+            self._write_reference_as_sequence(that.unit_id)
+            self._write_end_element("unitId")
+
+        if that.source_of_definition is not None:
+            self._write_str_property("sourceOfDefinition", that.source_of_definition)
+
+        if that.symbol is not None:
+            self._write_str_property("symbol", that.symbol)
+
+        if that.data_type is not None:
+            self._write_str_property("dataType", that.data_type.value)
+
+        if that.definition is not None:
+            if len(that.definition) == 0:
+                self._write_empty_element("definition")
+            else:
+                self._write_start_element("definition")
+                for yet_another_item in that.definition:
+                    self.visit(yet_another_item)
+                self._write_end_element("definition")
+
+        if that.value_format is not None:
+            self._write_str_property("valueFormat", that.value_format)
+
+        if that.value_list is not None:
+            self._write_start_element("valueList")
+            self._write_value_list_as_sequence(that.value_list)
+            self._write_end_element("valueList")
+
+        if that.value is not None:
+            self._write_str_property("value", that.value)
+
+        if that.level_type is not None:
+            self._write_start_element("levelType")
+            self._write_level_type_as_sequence(that.level_type)
+            self._write_end_element("levelType")
+
+    def visit_data_specification_iec_61360(
+        self, that: aas_types.DataSpecificationIEC61360
+    ) -> None:
+        """
+        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.
+
+        The enclosing XML element designates the class of the instance, where its
+        children correspond to the properties of the instance.
+
+        :param that: instance to be serialized
+        """
+        self._write_start_element("dataSpecificationIec61360")
+        self._write_data_specification_iec_61360_as_sequence(that)
+        self._write_end_element("dataSpecificationIec61360")
+
+
+def write(instance: aas_types.Class, stream: TextIO) -> None:
+    """
+    Write the XML representation of :paramref:`instance` to :paramref:`stream`.
+
+    Example usage:
+
+    .. code-block::
+
+        import pathlib
+
+        import aas_core3.types as aas_types
+        import aas_core3.xmlization as aas_xmlization
+
+        instance = Extension(
+           ... # some constructor arguments
+        )
+
+        pth = pathlib.Path(...)
+        with pth.open("wt") as fid:
+            aas_xmlization.write(instance, fid)
+
+    :param instance: to be serialized
+    :param stream: to write to
+    """
+    serializer = _Serializer(stream)
+    serializer.visit(instance)
+
+
+def to_str(that: aas_types.Class) -> str:
+    """
+    Serialize :paramref:`that` to an XML-encoded text.
+
+    :param that: instance to be serialized
+    :return: :paramref:`that` serialized to XML serialized to text
+    """
+    writer = io.StringIO()
+    write(that, writer)
+    return writer.getvalue()
+
+
+# endregion
```

### Comparing `aas-core3.0-1.0.0rc1/aas_core3.0.egg-info/PKG-INFO` & `aas-core3.0-1.0.0rc2/aas_core3.0.egg-info/PKG-INFO`

 * *Files 11% similar despite different names*

```diff
@@ -1,55 +1,52 @@
-Metadata-Version: 2.1
-Name: aas-core3.0
-Version: 1.0.0rc1
-Summary: Manipulate, verify and de/serialize Asset Administration Shells.
-Home-page: https://github.com/aas-core-works/aas-core3.0-python
-Author: Marko Ristin
-Author-email: marko@ristin.ch
-License: License :: OSI Approved :: MIT License
-Keywords: asset administration shell sdk industry 4.0 industrie i4.0 industry iot iiot
-Platform: UNKNOWN
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-License-File: LICENSE
-
-**********************
-aas-core3.0-python
-**********************
-
-.. image:: https://github.com/aas-core-works/aas-core3.0-python/actions/workflows/ci.yml/badge.svg
-    :target: https://github.com/aas-core-works/aas-core3.0-python/actions/workflows/ci.yml
-    :alt: Continuous integration
-
-.. image:: https://coveralls.io/repos/github/aas-core-works/aas-core3.0-python/badge.svg?branch=main
-    :target: https://coveralls.io/github/aas-core-works/aas-core3.0-python?branch=main
-    :alt: Test coverage
-
-.. image:: https://badge.fury.io/py/aas-core3.0.svg
-    :target: https://badge.fury.io/py/aas-core3.0
-    :alt: PyPI - version
-
-.. image:: https://img.shields.io/pypi/pyversions/aas-core3.0.svg
-    :alt: PyPI - Python Version
-
-.. image:: https://readthedocs.org/projects/aas-core30-python/badge/?version=latest
-    :target: https://aas-core30-python.readthedocs.io/en/latest/?badge=latest
-    :alt: Documentation
-
-This is a software development kit (SDK) to manipulate, verify and de/serialize Asset Administration Shells based on the version 3.0 of the meta-model.
-
-The documentation is available on: https://aas-core30-python.readthedocs.io/en/latest/.
-
-The majority of the code has been automatically generated by `aas-core-codegen`_.
-
-If you want to contribute, see our `contributing guide`_.
-
-.. _aas-core-codegen: https://github.com/aas-core-works/aas-core-codegen
-
-.. _contributing guide: https://aas-core30-python.readthedocs.io/en/latest/contributing.html
-
-
+Metadata-Version: 2.1
+Name: aas-core3.0
+Version: 1.0.0rc2
+Summary: Manipulate, verify and de/serialize Asset Administration Shells.
+Home-page: https://github.com/aas-core-works/aas-core3.0-python
+Author: Marko Ristin
+Author-email: marko@ristin.ch
+License: License :: OSI Approved :: MIT License
+Keywords: asset administration shell sdk industry 4.0 industrie i4.0 industry iot iiot
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+License-File: LICENSE
+
+**********************
+aas-core3.0-python
+**********************
+
+.. image:: https://github.com/aas-core-works/aas-core3.0-python/actions/workflows/ci.yml/badge.svg
+    :target: https://github.com/aas-core-works/aas-core3.0-python/actions/workflows/ci.yml
+    :alt: Continuous integration
+
+.. image:: https://coveralls.io/repos/github/aas-core-works/aas-core3.0-python/badge.svg?branch=main
+    :target: https://coveralls.io/github/aas-core-works/aas-core3.0-python?branch=main
+    :alt: Test coverage
+
+.. image:: https://badge.fury.io/py/aas-core3.0.svg
+    :target: https://badge.fury.io/py/aas-core3.0
+    :alt: PyPI - version
+
+.. image:: https://img.shields.io/pypi/pyversions/aas-core3.0.svg
+    :alt: PyPI - Python Version
+
+.. image:: https://readthedocs.org/projects/aas-core30-python/badge/?version=latest
+    :target: https://aas-core30-python.readthedocs.io/en/latest/?badge=latest
+    :alt: Documentation
+
+This is a software development kit (SDK) to manipulate, verify and de/serialize Asset Administration Shells based on the version 3.0 of the meta-model.
+
+The documentation is available on: https://aas-core30-python.readthedocs.io/en/latest/.
+
+The majority of the code has been automatically generated by `aas-core-codegen`_.
+
+If you want to contribute, see our `contributing guide`_.
+
+.. _aas-core-codegen: https://github.com/aas-core-works/aas-core-codegen
+
+.. _contributing guide: https://aas-core30-python.readthedocs.io/en/latest/contributing.html
```

### Comparing `aas-core3.0-1.0.0rc1/setup.py` & `aas-core3.0-1.0.0rc2/setup.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-"""A setuptools based setup module.
-
-See:
-https://packaging.python.org/en/latest/distributing.html
-https://github.com/pypa/sampleproject
-"""
-import os
-import sys
-
-from setuptools import setup, find_packages
-
-# pylint: disable=redefined-builtin
-
-here = os.path.abspath(os.path.dirname(__file__))
-
-with open(os.path.join(here, "README.rst"), encoding="utf-8") as fid:
-    long_description = fid.read()
-
-setup(
-    name="aas-core3.0",
-    # Synchronize with __init__.py and changelog.rst!
-    version="1.0.0rc1",
-    description="Manipulate, verify and de/serialize Asset Administration Shells.",
-    long_description=long_description,
-    url="https://github.com/aas-core-works/aas-core3.0-python",
-    author="Marko Ristin",
-    author_email="marko@ristin.ch",
-    classifiers=[
-        "Development Status :: 5 - Production/Stable",
-        "License :: OSI Approved :: MIT License",
-        "Programming Language :: Python :: 3.7",
-        "Programming Language :: Python :: 3.8",
-        "Programming Language :: Python :: 3.9",
-        "Programming Language :: Python :: 3.10",
-        "Programming Language :: Python :: 3.11",
-    ],
-    license="License :: OSI Approved :: MIT License",
-    keywords="asset administration shell sdk industry 4.0 industrie i4.0 industry iot iiot",
-    packages=find_packages(exclude=["tests", "continuous_integration", "dev_scripts"]),
-    install_requires=[] if sys.version_info >= (3, 8) else ["typing_extensions"],
-    py_modules=["aas_core3"],
-    package_data={"aas_core3": ["py.typed"]},
-)
+"""A setuptools based setup module.
+
+See:
+https://packaging.python.org/en/latest/distributing.html
+https://github.com/pypa/sampleproject
+"""
+import os
+import sys
+
+from setuptools import setup, find_packages
+
+# pylint: disable=redefined-builtin
+
+here = os.path.abspath(os.path.dirname(__file__))
+
+with open(os.path.join(here, "README.rst"), encoding="utf-8") as fid:
+    long_description = fid.read()
+
+setup(
+    name="aas-core3.0",
+    # Synchronize with __init__.py and changelog.rst!
+    version="1.0.0rc2",
+    description="Manipulate, verify and de/serialize Asset Administration Shells.",
+    long_description=long_description,
+    url="https://github.com/aas-core-works/aas-core3.0-python",
+    author="Marko Ristin",
+    author_email="marko@ristin.ch",
+    classifiers=[
+        "Development Status :: 5 - Production/Stable",
+        "License :: OSI Approved :: MIT License",
+        "Programming Language :: Python :: 3.7",
+        "Programming Language :: Python :: 3.8",
+        "Programming Language :: Python :: 3.9",
+        "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
+    ],
+    license="License :: OSI Approved :: MIT License",
+    keywords="asset administration shell sdk industry 4.0 industrie i4.0 industry iot iiot",
+    packages=find_packages(exclude=["tests", "continuous_integration", "dev_scripts"]),
+    install_requires=[] if sys.version_info >= (3, 8) else ["typing_extensions"],
+    py_modules=["aas_core3"],
+    package_data={"aas_core3": ["py.typed"]},
+)
```

